Speck码是一类轻量级的[分组密码](../Page/分组密码.md "wikilink")；最早由[美国国家安全局](../Page/美国国家安全局.md "wikilink")（NSA）于2013年6月提出\[1\]。如今Speck码较多应用于软件实现，而其姊妹算法西蒙算法则多用于硬件实现。

## 编码描述

Speck支持多种分组密文长度。单个分组总是包含两个单字，每个单字可以由16位、24位、32位、48位或64位比特组成。相关密文由2、3或4个词汇组成。编码的循环函数包含两次反转计算：将右单字添加到左单字，异或密文与左单字；之后异或左单字与右单字。循环的次数取决于参数的选择如下\[2\]：

| 块大小(bits) | 秘钥大小(bits) | 循环次数 |
| --------- | ---------- | ---- |
| 2×16=32   | 4×16=64    | 22   |
| 2×24=48   | 3×24=72    | 22   |
| 4×24=96   | 23         |      |
| 2×32=64   | 3×32=96    | 26   |
| 4×32=128  | 27         |      |
| 2×48=96   | 2×48=96    | 28   |
| 3×48=144  | 29         |      |
| 2×64=128  | 2×64=128   | 32   |
| 3×64=192  | 33         |      |
| 4×64=256  | 34         |      |

密码次序表与主块密码使用相同的循环函数。

## 参考代码

以下是编码算法实现的设计参考，使用C语言编写，其具有128比特的分组大小与密文。

``` c
#include <stdint.h>

#define ROR(x, r) ((x >> r) | (x << (64 - r)))
#define ROL(x, r) ((x << r) | (x >> (64 - r)))
#define R(x, y, k) (x = ROR(x, 8), x += y, x ^= k, y = ROL(y, 3), y ^= x)
#define ROUNDS 32

void encrypt(uint64_t ct[2],
             uint64_t const pt[2],
             uint64_t const K[2])
{
   uint64_t y = pt[0], x = pt[1], b = K[0], a = K[1];

   R(x, y, b);
   for (int i = 0; i < ROUNDS - 1; i++) {
      R(a, b, i);
      R(x, y, b);
   }

   ct[0] = y;
   ct[1] = x;
}
```

## 参考文献

[Category:分组密码](https://zh.wikipedia.org/wiki/Category:分组密码 "wikilink") [Category:美国国家安全局密码](https://zh.wikipedia.org/wiki/Category:美国国家安全局密码 "wikilink")

1.

2.
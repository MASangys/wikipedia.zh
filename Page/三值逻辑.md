> 本文内容由[三值逻辑](https://zh.wikipedia.org/wiki/三值逻辑)转换而来。


在[邏輯學中的](https://zh.wikipedia.org/wiki/邏輯 "wikilink")**三值**邏輯（three-valued，也稱為三元（ternary），或三价（trivalent）邏輯，有時縮寫為3VL）是幾個[多值逻辑](../Page/多值逻辑.md "wikilink")系統中的其中之一。有三種狀態來表示真、假和一個表示不確定的第三值；这相对於基礎的二元邏輯（比如[布尔逻辑](../Page/布尔逻辑.md "wikilink")，它只提供真假兩種狀態）。概念形式和基本思想最初由 JanŁukasiewicz和 C. I. Lewis創建。 然後這些由 Grigore Moisil以公理代數形式重新制定，並在 1945年擴展到 \(n\)值邏輯。

## 值的表示符號

同二值逻辑一样，在三值逻辑中的真值可以使用各种[三进制系统表示来数值表示](https://zh.wikipedia.org/wiki/三进制 "wikilink")。一些常见的例子有：

  - 1用于真，2用于假，0用于“未知”、“无关”或“二者”。\[1\]
  - 0用于假，1用于真，第三值使用非整数符号比如\# 或½。\[2\]
  - [平衡三进制](https://zh.wikipedia.org/wiki/平衡三进制 "wikilink")：= -1用于假，1用于真，0用于第三值；这些值还可以分别简化为 -、+和0。\[3\]

本文主要闡述了一個基于 {false，unknown，true} 狀態的[克莱尼三值](https://zh.wikipedia.org/wiki/克莱尼 "wikilink")[命题逻辑](../Page/命题逻辑.md "wikilink")系统，並將一般的布爾連接詞擴展到三值上下文語境中。三值邏輯也有謂詞；這些可能具有與經典（二元）謂詞邏輯不同的量詞讀數，也可能包含替代量詞。

## 真值表

如果布爾邏輯具有 2<sup>2</sup> = 4 個單元運算符，則在三值邏輯中添加第三個狀態值，則導致在單個輸入值上共有 3<sup>3</sup> = 27 個不同的運算符。類似地，在布爾邏輯具有 2<sup>2<sup>2</sup></sup> = 16個不同的二元運算符（具有2個輸入的運算符）的情況下，三值邏輯具有 3<sup>3<sup>2</sup></sup> = 19,683 個這樣的運算符。當布爾運算符已有很多固有的名稱（例如否定、並且、或者，排除，等價、蘊含）的情況下，對三值邏輯中的運算符嘗試給予名稱，是不甚合理的。

下面是给有true（T）/false（F）/unknown（?）状态的系统的一些逻辑运算的[真值表](../Page/真值表.md "wikilink")。

| *A* | *B* | *A* ∨ *B* | *A* ∧ *B* | ¬ *A* |
| --- | --- | --------- | --------- | ----- |
| T   | T   | T         | T         | F     |
| T   | ?   | T         | ?         | F     |
| T   | F   | T         | F         | F     |
| ?   | T   | T         | ?         | ?     |
| ?   | ?   | ?         | ?         | ?     |
| ?   | F   | ?         | F         | ?     |
| F   | T   | T         | F         | T     |
| F   | ?   | ?         | F         | T     |
| F   | F   | F         | F         | T     |

在这个真值表中，UNKNOWN状态可以被比拟认为是一个密封的盒子，其中包含要么一个明确的TRUE值要么一个明确的FALSE值。不能随时及时获得任何特定UNKNOWN状态秘密的表示TRUE还是FALSE的知识。但是，特定逻辑运算可以生成一个明确的结果，即使它们涉及到了至少一个UNKNOWN操作数（参看[捷徑求值](../Page/短路求值.md "wikilink")）。例如，因为TRUE ∨ TRUE等于TRUE，而TRUE ∨ FALSE等于TRUE，你同样可以推出TRUE ∨ UNKNOWN等于TRUE。在这个例子中，因为两个二价状态都可以被UNKNOWN状态暗含，但两个状态都生成相同的结果，在所有这三种情况下都是一个明确的TRUE结果。

## 在数据库应用中的三值逻辑

[数据查询语言](../Page/数据查询语言.md "wikilink") SQL 实用了三值逻辑，作为处理字段内容值為 [NULL的一种方式](https://zh.wikipedia.org/wiki/Null_\(SQL\) "wikilink")。最初使用 NULL值的意圖来表示在数据库中缺失数据，即假設現實中有值存在，但該值當前並未記錄在數據庫中；注意缺失的值不同于数值零，或长度為零的空字串值，这两者都表示已知的值。SQL 使用 Kleene K3 邏輯的通用片段，僅限於 AND，OR 和 NOT表。在 SQL中 NULL 值應被解釋為未知(UNKNOWN)。若以 NULL 與欄位值做關係比較，包括和另一個 NULL的比較，結果都是狀態為未知的。然而，這種語義選擇在某些集合操作中被放棄了，例如，UNION 或 INTERSECT，其中 NULL 被視為彼此相等。批評者斷言，這種不一致的性質剝奪了 SQL在處理 NULL 時直觀的語義。例如，考虑下列 SQL表达式：

  -
    `City = 'Paris'`

SQL 中在 City 字段中的 NULL 值表示理论中导致这个表达式，被确认为要么 TRUE（比如 City 包含 'Paris'），要么FALSE（比如 City 包含 'Philadelphia'）的一缺失值。样例 SQL 表达式依据如下规则确认：

  - 对于在 City 字段中有字串 'Paris'的任何记录，结果为 TRUE
  - 对于在 City 字段中有 NULL的任何记录，结果为 UNKNOWN
  - 在所有其他情况，结果为 FALSE

在SQL [数据操纵语言中](https://zh.wikipedia.org/wiki/数据操纵语言 "wikilink")，表达式（比如在`WHERE`子句中）的TRUE真值状态发起在这个行上一个动作（比如返回这一行），而UNKNOWN或FALSE的真值状态不做事情。\[4\]三值逻辑以这种方式来实现在SQL中，而对于SQL用户表现得如同二值逻辑。

但是，SQL的[检查约束有不同的表现](https://zh.wikipedia.org/wiki/检查约束 "wikilink")。只有FALSE真值状态导致违反检查约束。TRUE或UNKNOWN真值状态指示一行已经成功的通过检查约束验证。\[5\]

在文章 **[Null](https://zh.wikipedia.org/wiki/Null_\(SQL\) "wikilink")**中深入讨论了三值逻辑的 SQL实现。

## 参见

  - [数字电路](../Page/数字电路.md "wikilink")
  - [三进制](https://zh.wikipedia.org/wiki/三进制 "wikilink")
  - [三进制计算机](https://zh.wikipedia.org/wiki/三进制计算机 "wikilink")
  - [布尔代数](../Page/布尔代数.md "wikilink")
  - [布尔函数](../Page/布尔函数.md "wikilink")
  - [二值逻辑](https://zh.wikipedia.org/wiki/二值逻辑 "wikilink")

## 引用

## 外部链接

  - [Trinary Computer Systems](http://xyzzy.freeshell.org/trinary/)
  - [TriINTERCAL](https://web.archive.org/web/20070701123014/http://www.progsoc.uts.edu.au/~sbg/intercal/ick5.html) - the intentionally-obfuscated INTERCAL programming language supports an implementation of ternary logic
  - [Boost.Tribool](http://www.boost.org/doc/html/tribool.html) – an implementation of ternary logic in [C++](../Page/C++.md "wikilink")
  - [Team-R2D2](https://web.archive.org/web/20070904054933/http://www.inria.fr/rapportsactivite/RA2004/r2d22004/uid51.html) - a French institute that fabricated the first full-ternary logic chip (a 64-tert SRAM and 4-tert adder) in 2004

[Category:形式逻辑系统](https://zh.wikipedia.org/wiki/Category:形式逻辑系统 "wikilink")

1.
2.
3.
4.
5.
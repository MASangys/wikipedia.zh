**乘積累加運算**（）是在[-{zh-hans:数字信号;
zh-hant:數位信號;}-處理器或一些](../Page/數字信號處理器.md "wikilink")[微處理器中的特殊運算](../Page/微處理器.md "wikilink")。實作此運算操作的硬體電路單元，被稱為「乘数累加器」。這種運算的操作，是將乘法的乘積結果和[累加器](../Page/累加器.md "wikilink")
A 的值相加，再存入累加器：

\[a \leftarrow a + b \times c\]

若沒有使用 MAC 指令，上述的程序可能需要二個[指令](../Page/指令.md "wikilink")，但 MAC
指令可以使用一個指令完成。而許多運算（例如[卷积运算](../Page/卷积.md "wikilink")、[点积运算](../Page/点积.md "wikilink")、[矩阵运算](../Page/矩阵.md "wikilink")、[数字滤波器运算](../Page/数字滤波器.md "wikilink")、乃至[多项式的求值运算](../Page/多项式.md "wikilink")）都可以分解為數個
MAC 指令，因此可以提高上述运算的效率。

MAC指令的輸入及輸出的[數據類型可以是](../Page/數據類型.md "wikilink")[整數](../Page/整數.md "wikilink")、[定點數或是](../Page/定點數.md "wikilink")[浮點數](../Page/浮點數.md "wikilink")。若處理浮點數時，會有兩次的[數值修約](../Page/數值修約規則.md "wikilink")（Rounding），這在很多典型的DSP上很常見。若一條MAC指令在處理浮點數時只有一次的數值修約，則這種指令稱為「融合乘加運算」/「積和熔加运算」（fused
multiply-add, FMA）或「熔合乘法累积运算」（fused multiply–accumulate, FMAC）。

## 积和熔加运算

融合乘加運算的操作和乘積累加的基本一樣，對於浮點數的操作也是一條指令完成。但不同的是，非融合乘加的乘積累加運算，處理浮點數時，會先完成b×c的乘積，將其結果數值修約到N個位元，然後才將修約後的結果與暫存器a的數值相加，再把結果修約到N個位元；融合乘加則是先完成a+b×c的操作，獲得最終的完整結果後方才修約到N個位元。由於減少了數值修約次數，這種操作可以提高運算結果的精度，以及提高運算效率和速率。

積和融加運算可以顯著提升像是這些運算的性能和精度：

  - [點積](../Page/點積.md "wikilink")
  - [矩陣乘法](../Page/矩陣乘法.md "wikilink")
  - [多項式方程求解](../Page/数学机械化自动推理平台#多项式方程求解.md "wikilink")（像是[秦九韶算法等](../Page/秦九韶算法.md "wikilink")）
  - [牛頓法求解](../Page/牛頓法.md "wikilink")-{[函數](../Page/函數.md "wikilink")}-的[零點](../Page/零點.md "wikilink")

積和融加運算通常被依靠用來取得更精確的運算結果。然而，Kahan指出，如果不加思索地使用這種運算操作，在某些情況下可能會帶來問題。\[1\]像是[平方差公式](../Page/平方差.md "wikilink")，它等價於，若果x與y已知數值，使用積和融加運算來求結果，哪怕
*y*}}時，因為在進行首次乘法操作時無視低位的有效位元，可能會使運算結果出錯，如果是多步運算，第一步就出錯則會連累後續的運算結果接連出錯，比如前述的平方差求值後，再取結果的[平方根](../Page/平方根.md "wikilink")，那麼這個結果也會出錯。

## 參考資料

## 参见

  - [熔合乘法累积指令集](../Page/熔合乘法累积指令集.md "wikilink")
  - [BLAS](../Page/BLAS.md "wikilink")

[Category:計算機算術](https://zh.wikipedia.org/wiki/Category:計算機算術 "wikilink")
[Category:数字信号处理](https://zh.wikipedia.org/wiki/Category:数字信号处理 "wikilink")

1.
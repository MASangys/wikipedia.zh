**互質因子算法**（Prime-factor FFT algorithm, PFA），又稱為Good-Thomas算法\[1\]
\[2\]，是一種[快速傅立葉變換](https://zh.wikipedia.org/wiki/快速傅立葉變換 "wikilink")（FFT），把*N*
=
*N*<sub>1</sub>*N*<sub>2</sub>大小的[離散傅立葉變換重新表示為](https://zh.wikipedia.org/wiki/離散傅立葉變換 "wikilink")*N*<sub>1</sub>
\*
*N*<sub>2</sub>大小的[二維離散傅立葉變換](../Page/离散傅里叶变换.md "wikilink")，其中*N*<sub>1</sub>與*N*<sub>2</sub>需[互質](../Page/互質.md "wikilink")。變成*N*<sub>1</sub>和*N*<sub>2</sub>大小的傅立葉變換後，可以繼續遞迴使用PFA，或用其他[快速傅立葉變換算法來計算](https://zh.wikipedia.org/wiki/快速傅立葉變換 "wikilink")。

較流行的[Cooley-Tukey算法經由mixed](../Page/库利－图基快速傅里叶变换算法.md "wikilink")-radix一般化後，也是把*N*
=
*N*<sub>1</sub>*N*<sub>2</sub>大小的[離散傅立葉變換分割為](https://zh.wikipedia.org/wiki/離散傅立葉變換 "wikilink")*N*<sub>1</sub>和*N*<sub>2</sub>大小的轉換，但和互質因子算法
(PFA)作法並不相同，不應混淆。[Cooley-Tukey算法的](../Page/库利－图基快速傅里叶变换算法.md "wikilink")*N*<sub>1</sub>與*N*<sub>2</sub>不需[互質](../Page/互質.md "wikilink")，可以是任何整數。然而有個缺點是比PFA多出一些乘法，和[單位根](https://zh.wikipedia.org/wiki/單位根 "wikilink")[twiddle
factors相乘](https://zh.wikipedia.org/wiki/:en:Twiddle_factor "wikilink")。相對的，PFA的缺點則是*N*<sub>1</sub>與*N*<sub>2</sub>需[互質](../Page/互質.md "wikilink")
(例如*N*
是2次方就不適用)，而且要藉由[中國剩餘定理來進行較複雜的re](../Page/中国剩余定理.md "wikilink")-indexing。互質因子算法
(PFA)可以和mixed-radix
[Cooley-Tukey算法相結合](../Page/库利－图基快速傅里叶变换算法.md "wikilink")，前者將*N*
分解為[互質的](../Page/互質.md "wikilink")[因數](../Page/因數.md "wikilink")，後者則用在重複[質因數上](https://zh.wikipedia.org/wiki/質因子 "wikilink")。

PFA也與nested [Winograd
FFT算法密切相關](../Page/威諾格拉德快速傅立葉變換演算法.md "wikilink")，後者使用更為精巧的二維[摺積技巧分解成](../Page/卷积.md "wikilink")*N*<sub>1</sub>
\* *N*<sub>2</sub>的轉換。因而一些較古老的論文把Winograd算法稱為PFA FFT。

儘管PFA和Cooley-Tukey算法並不相同，但有趣的是Cooley和Tukey在他們1965年發表的有名的論文中，沒有發覺到[高斯和其他人更早的研究](../Page/卡爾·弗里德里希·高斯.md "wikilink")，只引用Good在1958年發表的PFA作為前人的FFT結果。剛開始的時候人們對這兩種作法是否不同有點困惑。

## 算法

[離散傅立葉變換](https://zh.wikipedia.org/wiki/離散傅立葉變換 "wikilink")（DFT）的定義如下:

\[X_k = \sum_{n=0}^{N-1} x_n e^{-\frac{2\pi i}{N} nk }
\qquad
k = 0,\dots,N-1\]

PFA將輸入和輸出re-indexing，代入DFT公式後轉換成二維DFT。

### Re-indexing

設*N* =
*N*<sub>1</sub>*N*<sub>2</sub>，*N*<sub>1</sub>與*N*<sub>2</sub>兩者[互質](../Page/互質.md "wikilink")，然後把輸入*n*
和輸出*k* [一一對應到](../Page/双射.md "wikilink")

\[n = n_1 N_2 + n_2 N_1 \mod N\]

因*N*<sub>1</sub>與*N*<sub>2</sub>
[互質](../Page/互質.md "wikilink")，故根據[最大公因數表現定理](../Page/貝祖等式.md "wikilink")，對每個*n*
都存在滿足上式的整數*n*<sub>1</sub>與*n*<sub>2</sub>，且在[同餘](../Page/同餘.md "wikilink")*N*
之下*n*<sub>1</sub>可以調整至0～*N*<sub>1</sub>
–1之間，*n*<sub>2</sub>可以調整至0～*N*<sub>2</sub>
–1之間。並根據[同餘理論易知滿足上式且在以上範圍內的整數](../Page/同餘.md "wikilink")*n*<sub>1</sub>與*n*<sub>2</sub>是唯一的。這稱為*Ruritanian*
[映射](https://zh.wikipedia.org/wiki/映射 "wikilink") (或*Good's* 映射)，

\[k = k_1 \mod N_1\]

\[k = k_2 \mod N_2\]

舉例來說:

如果\(N=15, N_1=5, N_2=3, n=0,1,2,...,12, 13,14,\)對於任一 \(n\) 都可以對應到

\(n = n_1 N_2 + n_2 N_1 \mod N, n_1=0,1,...,N_1-1, n_2=0,1,...,N_2-1\)

\(0=0\centerdot N_2+0\centerdot N_1 \mod 15\)

\(1=2\centerdot N_2+2\centerdot N_1 \mod 15\)

\(2=4\centerdot N_2+1\centerdot N_1 \mod 15\)

\(3=1\centerdot N_2+0\centerdot N_1 \mod 15\)

\(4=3\centerdot N_2+2\centerdot N_1 \mod 15\)

\(5=0\centerdot N_2+1\centerdot N_1 \mod 15\)

\(6=2\centerdot N_2+0\centerdot N_1 \mod 15\)

\(7=4\centerdot N_2+2\centerdot N_1 \mod 15\)

\(8=1\centerdot N_2+1\centerdot N_1 \mod 15\)

\(9=3\centerdot N_2+0\centerdot N_1 \mod 15\)

\(10=0\centerdot N_2+2\centerdot N_1 \mod 15\)

\(11=2\centerdot N_2+1\centerdot N_1 \mod 15\)

\(12=4\centerdot N_2+0\centerdot N_1 \mod 15\)

\(13=1\centerdot N_2+2\centerdot N_1 \mod 15\)

\(14=3\centerdot N_2+1\centerdot N_1 \mod 15\)

因*N*<sub>1</sub>與*N*<sub>2</sub>
[互質](../Page/互質.md "wikilink")，故根據[中國剩餘定理](../Page/中国剩余定理.md "wikilink")，對於每組
( *k*<sub>1</sub> , *k*<sub>2</sub> )
(其中*k*<sub>1</sub>在0～*N*<sub>1</sub> – 1之間,
*k*<sub>2</sub>在0～*N*<sub>2</sub> – 1之間)，都有存在且唯一的*k* 在0～*N* -
1之間且滿足上兩式。這稱為[*CRT*](../Page/中国剩余定理.md "wikilink") 映射。
[*CRT*](../Page/中国剩余定理.md "wikilink") 映射的另一種表示法如下

\[k = k_1 N_2^{-1} N_2 + k_2 N_1^{-1} N_1 \mod N\]

其中*N*<sub>1</sub><sup>-1</sup>表示*N*<sub>1</sub>在[模](../Page/同餘.md "wikilink")*N*<sub>2</sub>之下的[反元素](../Page/逆元素.md "wikilink")，*N*<sub>2</sub><sup>-1</sup>反之。

( 也可以改成對輸入*n* 用[*CRT*映射以及對輸出](../Page/中国剩余定理.md "wikilink")*k*
用*Ruritanian* 映射)

對於有效re-indexing
(理想上是達到[原地](../Page/原地算法.md "wikilink"))的方法有許多研究\[3\]，以減少耗費時間的[模運算](../Page/同餘.md "wikilink")。

### DFT re-expression

表示方法一:

將以上的re-indexing代入DFT公式裡指數部分的*nk* 之中，

\[e^{-\frac{2\pi i}{N} nk } = e^{-\frac{2\pi i}{N} ( n_1 N_2 + n_2 N_1 )k} = e^{-\frac{2\pi i}{N_1} k n_1} e^{-\frac{2\pi i}{N_2} k n_2} = e^{-\frac{2\pi i}{N_1} k_1 n_1} e^{-\frac{2\pi i}{N_2} k_2 n_2}\]

( 因為*e*<sup>2π*i*</sup> = 1，所以兩個指數的*k*
部份可以分別[模](../Page/同餘.md "wikilink")*N*<sub>1</sub>與*N*<sub>2</sub>
)。剩下的部分變成

\[X_{k_1 , k_2 } =
 \sum_{n_1=0}^{N_1-1}
   \left( \sum_{n_2=0}^{N_2-1} x_{n_1 N_2 + n_2 N_1}
           e^{-\frac{2\pi i}{N_2} n_2 k_2 } \right)
   e^{-\frac{2\pi i}{N_1} n_1 k_1 }.\]

則內部和外部的[總和分別轉換成大小為](https://zh.wikipedia.org/wiki/總和 "wikilink")*N*<sub>2</sub>與*N*<sub>1</sub>的DFT。

表示方法二:

如果令 \(k=k_1 N_2 + k_2 N_1 \quad for\quad k=0,1,...,N-1,\)

令 \(n = ((n_1 N_2 + n_2 N_1))_N\)，\((\cdot)_N\)相當於取
\(N\)的餘數，\(n_1 = 0,\dots,N_1-1\), \(n_2 = 0,\dots,N_2-1\)

\(X[((k_1 N_2+k_2 N_1))_N]=\sum_{n=0}^{N-1}x[((n_1 N_2+n_2 N_1))_N]e^{-j \frac{2 \pi}{N_2 N_1}(k_1 N_2+k_2 N_1)(n_1 N_2+n_2 N_1)}\)

\(=\sum_{n=0}^{N-1}x[((n_1 N_2 + n_2 N_1))_N]e^{-j \frac{2 \pi}{N_2 N_1}(k_1 n_1 N_2 N_2 + k_2 n_2 N_1 N_1 + k_1 n_2 N_2 N_1 + k_2 n_1 N_1 N_2)}\)

\(=\sum_{n=0}^{N-1}x[((n_1 N_2 + n_2 N_1))_N]e^{-j \frac{2 \pi}{N_1}(k_1 n_1 N_2)}e^{-j \frac{2 \pi}{N_2}(k_2 n_2 N_1)}\)

\(=\sum_{n_2=0}^{N_2-1}\{\sum_{n_1=0}^{N_1-1}x[((n_1 N_2 + n_2 N_1))_N]e^{-j \frac{2 \pi}{N_1}(k_1 n_1 N_2)}\}e^{-j \frac{2 \pi}{N_2}(k_2 n_2 N_1)}.\)

對於每一個 \(n_2\) 都要做一個 \(N_1\) 點的 \(DFT\)，而因為 \(n_2 = 0,\dots,N_2-1\)有
\(N_2\)個，所以需要 \(N_2\) 個 \(N_1\) 點 \(DFT\),

對於每一組\(((k_1N_2))_{N_1}\)都要做一個 \(N_2\) 點的 \(DFT\)，而因為
\(N_2\)為常數，\(k_1 = 0,\dots,N_1-1\)有 \(N_1\) 個，所以需要 \(N_1\) 個
\(N_2\) 點 \(DFT\)，

因此如果要計算複雜度，可以乘法器的數量當作考量,

假設\(N_1\) 點的 \(DFT\) 需要 \(M_1\)個乘法器,

假設\(N_2\) 點的 \(DFT\) 需要 \(M_2\)個乘法器,

則總共需要 \(N_2 M_1 + N_1 M_2\)個乘法器。

### 範例

以*N* = 6為例，有兩種可能，*N*<sub>1</sub> = 2, *N*<sub>2</sub> =
3或*N*<sub>1</sub> = 3, *N*<sub>2</sub> = 2。

[PFA2by3.PNG](https://zh.wikipedia.org/wiki/File:PFA2by3.PNG "fig:PFA2by3.PNG")
[PFA3by2.PNG](https://zh.wikipedia.org/wiki/File:PFA3by2.PNG "fig:PFA3by2.PNG")

第一種情形所產生的流程圖如左圖所示。先做2次3點DFT後再做3次2點DFT。

第二種情形所產生的流程圖如右圖所示。先做3次2點DFT後再做2次3點DFT。

其中2點DFT的部份因構造單純，皆以交錯的[蝴蝶圖來顯示](https://zh.wikipedia.org/wiki/:en:Butterfly_diagram "wikilink")。

可以看出即使在這個簡單的例子中，輸入和輸出的index也都經過有點複雜的重新排列。

## 與Cooley-Tukey算法的比較

如首段所述，[Cooley-Tukey算法和互質因子算法](https://zh.wikipedia.org/wiki/:en:Cooley-Tukey_FFT_algorithm "wikilink")
(PFA)曾被誤認為很類似。兩者皆有各自優點可適用於不同狀況，因此分辨它們的不同是很重要的。在1965年著名的論文中發表的[Cooley-Tukey算法](https://zh.wikipedia.org/wiki/Cooley-Tukey算法 "wikilink")，是在DFT的定義

\[X_k = \sum_{n=0}^{N-1} x_n e^{-\frac{2\pi i}{N} nk }
\qquad
k = 0,\dots,N-1\]

中代入*n* = *n*<sub>1</sub> + *n*<sub>2</sub>*N*<sub>1</sub> , *k* =
*k*<sub>1</sub>*N*<sub>2</sub> + *k*<sub>2</sub>，則

\[e^{-\frac{2\pi i}{N} nk } = e^{-\frac{2\pi i}{N} ( n_1 + n_2 N_1 )( k_1 N_2 + k_2 )} = e^{-\frac{2\pi i}{N_1} n_1 k_1} e^{-\frac{2\pi i}{N} n_1 k_2} e^{-\frac{2\pi i}{N_2} n_2 k_2}\]

\[X_{k_1N_2 + k_2} =
 \sum_{n_1=0}^{N_1-1}
   \left( \sum_{n_2=0}^{N_2-1} x_{n_1 + n_2 N_1}
           e^{-\frac{2\pi i}{N_2} n_2 k_2 } \right) e^{-\frac{2\pi i}{N} n_1 k_2}
   e^{-\frac{2\pi i}{N_1} n_1 k_1 }\]

比PFA多了一些要乘的因子\(e^{-\frac{2\pi i}{N} n_1 k_2}\) (稱為[twiddle
factors](https://zh.wikipedia.org/wiki/:en:Twiddle_factor "wikilink")
)，但index較為簡單，且適用於任何*N*<sub>1</sub>、*N*<sub>2</sub>。在J.
Cooley稍後發表的關於FFT歷史探討的論文\[4\]中使用*N* =
24點FFT為例，顯示兩種作法在index結構上的不同。

## 相關條目

  - [快速傅立葉變換](https://zh.wikipedia.org/wiki/快速傅立葉變換 "wikilink")
  - [中國剩餘定理](../Page/中国剩余定理.md "wikilink")
  - [Bézout引理](../Page/貝祖等式.md "wikilink")

## 注釋

## 參考文獻

1.
## 外部連結

  - [fft note by Burrus](http://www.jjj.de/fft/fftnote.txt)
  - [cnx](http://cnx.org/content/m12033/latest/)

[Category:数字信号处理](https://zh.wikipedia.org/wiki/Category:数字信号处理 "wikilink")

1.
2.
3.  .
4.
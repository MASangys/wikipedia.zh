**优先级继承**是[实时计算中去除](../Page/实时计算.md "wikilink")[优先级翻转的一种方法](https://zh.wikipedia.org/wiki/优先转置 "wikilink")。[进程调度](../Page/调度_\(计算机\).md "wikilink")[算法对获取到临界资源的进程](../Page/算法.md "wikilink")(A)增加其优先级为所有等待该资源的进程中的最高优先级。
一旦进程(A)释放了该资源，就恢复到原来的优先级。\[1\]

## 例子

考虑下例:

| Job Name | Priority |
| -------- | -------- |
| H        | High     |
| M        | Medium   |
| L        | Low      |

假定L获取到共享资源后，H申请该资源不得而被阻塞。优先级继承协议把L的优先级升级到H的级别。M将不能[抢先L因而M被阻塞](https://zh.wikipedia.org/wiki/抢占式多任务处理 "wikilink")。当L释放资源后，恢复到低优先级并唤醒H。H有高优先级因而抢先了L的执行权。随后M、L依次恢复执行。

## 参考文献

  - "[Priority Inheritance: The Real
    Story](https://web.archive.org/web/20070706071045/http://www.linuxdevices.com/articles/AT5698775833.html)"
    by
  - "[Against Priority
    Inheritance](https://web.archive.org/web/20070706071207/http://www.linuxdevices.com/articles/AT7168794919.html)"
    by
  - "[Implementing Concurrency Control With Priority Inheritance in
    Real-Time
    CORBA](http://rtdoc.cs.uri.edu/downloads/wohlever_thesis.pdf)" by ,
    and Russell Johnston
  - "[Priority Inheritance Spin Locks for Multiprocessor Real-Time
    Systems](http://citeseer.ist.psu.edu/108383.html)" by ,  and
  - "[Hardware Support for Priority
    Inheritance](http://doi.ieeecomputersociety.org/10.1109/REAL.2003.1253271)"
    by , ,  and

[Category:实时计算](https://zh.wikipedia.org/wiki/Category:实时计算 "wikilink")
[Category:并发控制](https://zh.wikipedia.org/wiki/Category:并发控制 "wikilink")

1.
在[类UNIX系统中](https://zh.wikipedia.org/wiki/类UNIX系统 "wikilink")，**僵尸进程**是指完成执行（通过[`exit`](https://zh.wikipedia.org/wiki/exit_\(Unix\) "wikilink")[系统调用](https://zh.wikipedia.org/wiki/系统调用 "wikilink")，或运行时发生[致命错误或收到终止](https://zh.wikipedia.org/wiki/致命错误 "wikilink")[信号所致](https://zh.wikipedia.org/wiki/信号_\(计算机科学\) "wikilink")）但在操作系统的进程表中仍然有一个表项（[进程控制块PCB](https://zh.wikipedia.org/wiki/进程控制块 "wikilink")），处于""的进程。这发生于[子进程](../Page/子进程.md "wikilink")需要保留表项以允许其[父进程](../Page/父进程.md "wikilink")读取子进程的[exit status](https://zh.wikipedia.org/wiki/exit_status "wikilink")：一旦退出态通过[`wait`](https://zh.wikipedia.org/wiki/wait_\(Unix\) "wikilink")[系统调用读取](https://zh.wikipedia.org/wiki/系统调用 "wikilink")，僵尸进程条目就从进程表中删除，称之为"**回收**（reaped）"。正常情况下，进程直接被其父进程`wait`并由系统回收。进程长时间保持僵尸状态一般是错误的并导致。

英文术语*zombie process*源自[喪屍](../Page/喪屍.md "wikilink") — 不死之人，隐喻子进程已死但仍然没有被收割。与正常进程不同，[`kill`](https://zh.wikipedia.org/wiki/kill_\(command\) "wikilink")命令对僵尸进程无效。[孤儿进程](../Page/孤儿进程.md "wikilink")不同于僵尸进程，其父进程已经死掉，但孤儿进程仍能正常执行，但并不会变为僵尸进程，因为被[`init`](https://zh.wikipedia.org/wiki/init "wikilink")（进程ID号为1）收养并`wait`其退出。

子进程死后，系统会发送[SIGCHLD](https://zh.wikipedia.org/wiki/SIGCHLD "wikilink") [信号给父进程](https://zh.wikipedia.org/wiki/signal.h "wikilink")，父进程对其默认处理是忽略。如果想响应这个消息，父进程通常在[SIGCHLD](https://zh.wikipedia.org/wiki/SIGCHLD "wikilink") [信号事件处理程序中](https://zh.wikipedia.org/wiki/signal.h "wikilink")，使用[`wait`](https://zh.wikipedia.org/wiki/wait_\(Unix\) "wikilink")[系统调用来响应子进程的终止](https://zh.wikipedia.org/wiki/系统调用 "wikilink")。

僵尸进程被收割后，其进程号(PID)与在进程表中的表项都可以被系统重用。但如果父进程没有调用`wait`，僵尸进程将保留进程表中的表项，导致了。某些情况下这反倒是期望的：父进程创建了另外一个子进程，并希望具有不同的进程号。如果父进程通过设置事件处理函数为`SIG_IGN`显式忽略SIGCHLD信号，而不是隐式默认忽略该信号，或者具有`SA_NOCLDWAIT`标志，所有子进程的退出状态信息将被抛弃并且直接被系统回收。

UNIX命令[`ps`](https://zh.wikipedia.org/wiki/ps_\(Unix\) "wikilink")列出的进程的状态（"STAT"）栏标示为 "`Z`"则为僵尸进程。\[1\]

收割僵尸进程的方法是通过`kill`命令手工向其父进程发送SIGCHLD[信号](https://zh.wikipedia.org/wiki/signal.h "wikilink")。如果其父进程仍然拒绝收割僵尸进程，则终止父进程，使得`init`进程收养僵尸进程。`init`进程周期执行`wait`系统调用收割其收养的所有僵尸进程。

为避免产生僵尸进程，实际应用中一般采取的方式是：

1.  将父进程中对SIGCHLD信号的处理函数设为SIG_IGN（忽略信号）；
2.  fork两次并杀死一级子进程，令二级子进程成为孤儿进程而被init所“收养”、清理\[2\]。

## 例子

``` c_mac
#include <sys/wait.h>
#include <stdlib.h>
#include <unistd.h>

int main(void)
{
    pid_t pids[10];
    int i;

    for (i = 9; i >= 0; --i) {
        pids[i] = fork();
        if (pids[i] == 0) {
            sleep(i+1);
            _exit(0);
        }
    }

    for (i = 9; i >= 0; --i)
        waitpid(pids[i], NULL, 0);

    return 0;
}
```

## 参见

  - [Fork炸弹](../Page/Fork炸弹.md "wikilink")

  -
## 参考文献

  -
## 外部链接

  - [Zombie process usenet post](http://yarchive.net/comp/zombie_process.html)
  - [UNIX FAQ Question 3.13: How do I get rid of zombie processes that persevere?](http://www.faqs.org/faqs/unix-faq/faq/part3/section-13.html)

[Category:进程](https://zh.wikipedia.org/wiki/Category:进程 "wikilink")

1.
2.  [UNIX环境高级编程](https://zh.wikipedia.org/wiki/UNIX环境高级编程 "wikilink")（*Advanced Programming in the UNIX Environment*），[理查德·史蒂文斯](../Page/理查德·史蒂文斯.md "wikilink")著，1992，ISBN 0-201-56317-7
**Kruskal演算法**是一種用來尋找[最小生成樹的演算法](https://zh.wikipedia.org/wiki/最小生成樹 "wikilink")，由Joseph Kruskal在1956年發表。用來解決同樣問題的還有[Prim演算法和](https://zh.wikipedia.org/wiki/Prim演算法 "wikilink")等。三種演算法都是[贪心算法的應用](https://zh.wikipedia.org/wiki/贪心法 "wikilink")。和Boruvka演算法不同的地方是，Kruskal演算法在圖中存在相同權值的邊時也有效。

## 步驟

1.  新建圖\(G\)，\(G\)中擁有原圖中相同的節點，但沒有邊
2.  將原圖中所有的邊按權值從小到大排序
3.  從權值最小的邊開始，如果這條邊連接的兩個節點於圖\(G\)中不在同一個連通分量中，則添加這條邊到圖\(G\)中
4.  重複3，直至圖\(G\)中所有的節點都在同一個連通分量中

## 證明

1.  這樣的步驟保證了選取的每條邊都是橋，因此圖\(G\)構成一個樹。
2.  為什麼這一定是最小生成樹呢？關鍵還是步驟3中對邊的選取。演算法中總共選取了\(n-1\)條邊，每條邊在選取的當時，都是連接兩個不同的連通分量的權值最小的邊
3.  要證明這條邊一定屬於最小生成樹，可以用反證法：如果這條邊不在最小生成樹中，它連接的兩個連通分量最終還是要連起來的，通過其他的連法，那麼另一種連法與這條邊一定構成了環，而環中一定有一條權值大於這條邊的邊，用這條邊將其替換掉，圖仍舊保持連通，但總權值減小了。也就是說，如果不選取這條邊，最後構成的生成樹的總權值一定不會是最小的。

## 時間複雜度

平均时间复杂度为\(\Omicron(|E| \log |V|)\)，其中\(E\)和\(V\)分别是图的边集和点集。

## 示例

| 图例                                                                                                                    | 说明                                                                                                                  |
| --------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| [Kruskal_Algorithm_1.svg](https://zh.wikipedia.org/wiki/File:Kruskal_Algorithm_1.svg "fig:Kruskal_Algorithm_1.svg") | **AD**和**CE**是最短的两条边，长度为5，其中**AD**被任意选出，以高亮表示。                                                                      |
| [Kruskal_Algorithm_2.svg](https://zh.wikipedia.org/wiki/File:Kruskal_Algorithm_2.svg "fig:Kruskal_Algorithm_2.svg") | 现在**CE**是不属于环的最短边，长度为5，因此第二个以高亮表示。                                                                                  |
| [Kruskal_Algorithm_3.svg](https://zh.wikipedia.org/wiki/File:Kruskal_Algorithm_3.svg "fig:Kruskal_Algorithm_3.svg") | 下一条边是长度为6的**DF**，同样地以高亮表示。                                                                                          |
| [Kruskal_Algorithm_4.svg](https://zh.wikipedia.org/wiki/File:Kruskal_Algorithm_4.svg "fig:Kruskal_Algorithm_4.svg") | 接下来的最短边是**AB**和**BE**，长度均为7。**AB**被任意选中，并以高亮表示。边**BD**用红色高亮表示，因为**B**和**D**之间已经存在一条（标为绿色的）路径，如果选择它将会构成一个环（**ABD**）。 |
| [Kruskal_Algorithm_5.svg](https://zh.wikipedia.org/wiki/File:Kruskal_Algorithm_5.svg "fig:Kruskal_Algorithm_5.svg") | 以高亮表示下一条最短边**BE**，长度为7。这时更多的边用红色高亮标出：会构成环**BCE**的**BC**、会构成环**DBEA**的**DE**以及会构成环**FEBAD**的**FE**。                  |
| [Kruskal_Algorithm_6.svg](https://zh.wikipedia.org/wiki/File:Kruskal_Algorithm_6.svg "fig:Kruskal_Algorithm_6.svg") | 最终，标记长度为9的边**EG**，得到最小生成树，结束算法过程。                                                                                   |

## 演算法

`-{}-`
`KRUSKAL-FUNCTION(G, w)`
`1    F := 空集合`
`2    `**`for``   ``each`**` 图 G 中的顶点 v`
`3        `**`do`**` 將 v 加入森林 F`
`4    所有的边(u, v) ∈ E依权重 w 递增排序`
`5    `**`for``   ``each`**` 边(u, v) ∈ E`
`6        `**`do``   ``if`**` u 和 v 不在同一棵子树`
`7            `**`then`**` F := F ∪ {(u, v)}`
`8                將 u 和 v 所在的子树合并`

[Category:图算法](https://zh.wikipedia.org/wiki/Category:图算法 "wikilink")
在[程序设计](../Page/程序设计.md "wikilink")中，**前向声明**（**Forward Declaration**）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。

## 例子

一個簡單的C/C++例子：

``` c
void printThisInteger(int);
```

在[C++](../Page/C++.md "wikilink")中, 上行代码是一个函数的前向声明，也是该函数的原型。编译器处理该行源码后，允许程序员在随后的程序中引用函数`print`; 不过程序员必须在某处提供这个被声明的函数的定义:

``` c
void printThisInteger(int x) {
   printf("%d\n", x);
}
```

在[Pascal与其它](https://zh.wikipedia.org/wiki/Pascal_\(编程语言\) "wikilink")[Wirth型的编程语言中](../Page/尼克劳斯·维尔特.md "wikilink"), 一般规则是所有实体必须在使用前被声明. [C语言适用同样的规则](https://zh.wikipedia.org/wiki/C语言 "wikilink"), 但存在未声明的函数与不完备的数据类型这样的特例. 因此，C语言允许(虽然不够明智)实现一对相互递归函数:

``` c
int first(int x) {
   if (x == 0)
      return 1;

   return second(x-1);
}

int second(int x) {
   if (x == 0)
      return 0;

   return first(x-1);
}
```

在Pascal程序中, 同样的实现要求在`first`引用`second`前，必须有一个`second`的前向声明. 如果没有这个前向声明, 编译器将产生编译错误，指出标识符`second`未经声明即被使用.

## 前向引用

**前向引用**()有时被用作前向声明的同义词\[1\]。但是，它更经常被用作一个实体在声明前即被实际使用; 例如, 上述代码中`second`第一次使用就是前向引用\[2\]\[3\]。因此，可以说在Pascal中, 前向声明是强制要求，前向引用是被禁止的.

C++中前向引用的例子:

``` cpp
class C {
public:
   void mutator(int x) { myValue = x; }
   int accessor() { return myValue; }
private:
   int myValue;
};
```

在此例中，对`myValue`的两次引用早于它的声明. C++一般禁止前向引用, 但是允许在类成员的特殊场合下使用前向引用。因此，成员函数`accessor`不能被编译直到编译器获知成员变量`myValue`的类型, 编译器有责任记住`accessor`的定义直到它看到`myValue`的声明.

允许前向引用大大增加了编译器的复杂度与内存需求，并且使它不能成为一次通过型的编译器。

## 参考资料

<references/>

[Category:计算机编程](https://zh.wikipedia.org/wiki/Category:计算机编程 "wikilink")

1.  \[<http://msdn2.microsoft.com/en-us/library/15k227ta(VS.71>).aspx MSDN: Converting to a Forward-Reference Class Type\]
2.  [1](http://pages.cs.wisc.edu/~fischer/cs536.s07/lectures/Lecture25.4up.pdf)
3.  [Thinking in C++: Inlines & the compiler](http://www.codeguru.com/cpp/tic/tic0103.shtml)
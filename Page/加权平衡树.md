在[计算机科学里面](../Page/计算机科学.md "wikilink")，**加权平衡树**（）是一种可以用来实现[集合](https://zh.wikipedia.org/wiki/集合 "wikilink")、[字典](../Page/字典.md "wikilink")（映射）和序列的[平衡树](../Page/平衡树.md "wikilink")。\[1\]这些树结构在20世纪70年代被Nievergelt和Reingold作为**有界限的自平衡树**或**BB\[α\]树**提出。\[2\]\[3\]让这些结构普及的是[高德纳](../Page/高德纳.md "wikilink")。\[4\]

就像其他自平衡树一样，加权平衡树储存的账簿信息可以在树结构被插入和删除操作打乱时，通过平衡结点和操作[树旋转来使树结构重新达到平衡](../Page/树旋转.md "wikilink")。特别的地方是，加权平衡树的每个结点储存这个结点下子树的大小，并且这个结点左右子树的大小保持着某种内在联系。不同于[AVL树](../Page/AVL树.md "wikilink")（储存子树的高度）和[红黑树](../Page/红黑树.md "wikilink")（储存虚构的“颜色”位），加权平衡树储存记账信息的方式是对应用真正有用的属性：一棵树下元素的数量等于它的根的大小，然而这个根的大小是一个用来实现[顺序统计树操作的有用数据](../Page/顺序统计树.md "wikilink")，也就是说，可以得到一个大小为的集合下的最大元素或者决定一个顺序结构下一个元素的索引。\[5\]

加权平衡树在[函数程式语言社区下面非常受欢迎以及被用来实现](https://zh.wikipedia.org/wiki/函数程式语言 "wikilink")[MIT
Scheme的集合和映射结构还有](../Page/Scheme.md "wikilink")[Haskell语言的实现](../Page/Haskell.md "wikilink")。\[6\]\[7\]

## 描述

加权平衡树是一种储存子树大小的[二叉搜索树](https://zh.wikipedia.org/wiki/二叉搜索树 "wikilink")。那就是说，一个结点包含以下字段：

  - 键（*key*），任何可排序的类型
  - 值（*value*，可选，只作映射作用）
  - 左子树（*left*），右子树（*right*），结点的指针
  - 大小（*size*），整数类型

从定义上来说，树上叶子（没有子结点的元素）的大小（典型地用一个空指针表示）是0。一个内部结点的大小是它的两棵子树的大小，再加一 （
size\[n.left\] + size\[n.right\] + 1}}）。一个结点的权重取决于它的大小或者等于它的大小，或
size\[n\] + 1}}。

[BinaryTreeRotations.svg](https://zh.wikipedia.org/wiki/File:BinaryTreeRotations.svg "fig:BinaryTreeRotations.svg")\]\]
修改树的操作必须使用与[AVL树中相同的操作来保证左子树和右子树的大小相互存在某种内在因子](../Page/AVL树.md "wikilink")，也就是旋转和两次选择。形式上来说，结点平衡操作如下定义：

  -
    如果一个结点满足以及，那么就说这个结点是加权平衡的。\[8\]

在这里，是一个在实现加权平衡树是用来做决定的数值参数。的值越小，意味着这棵树“更加平衡”，但不是所有的值都是合适的；Nievergelt和Reingold曾经证明过满足

\[\alpha < 1 - \frac{1}{\sqrt{2}}\]

是一个平衡算法成功工作的重要状态。他们往后的工作展示了的一个下界是，几时它可以无限小如果使用一个自定义（更加复杂的）的再平衡算法。

若平衡被正确实现，一棵含有个元素的加权平衡树的高度满足

\[h \le \log_{\frac{1}{1-\alpha}} n = \frac{\log_2 n}{\log_2 \left( \frac{1}{1-\alpha} \right)} = O(\log n)\]

加权平衡树次插入和删除操作中，平衡的次数是线性的，为。也就是说，加权平衡树的平衡操作[均摊开销是恒定的](../Page/平摊分析.md "wikilink")。\[9\]

## 引用

1.

2.

3.

4.

5.

6.

7.
8.

9.
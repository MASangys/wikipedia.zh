在[计算机科学中](../Page/计算机科学.md "wikilink"), **动态内存分配**（Dynamic memory
allocation）又称为**堆内存分配**，是指[计算机程序在](../Page/计算机程序.md "wikilink")[运行期中分配使用](https://zh.wikipedia.org/wiki/运行期 "wikilink")[内存](https://zh.wikipedia.org/wiki/内存 "wikilink")。它可以当成是一种分配有限内存资源所有权的方法。

动态分配的内存在被程序员明确释放或被[垃圾回收之前一直有效](https://zh.wikipedia.org/wiki/垃圾回收_\(计算机科学\) "wikilink")。与[静态内存分配的区别在于没有一个固定的生存期](https://zh.wikipedia.org/wiki/静态内存分配 "wikilink")。这样被分配的对象称之为有一个「动态生存期」。

## 细节

分配过程包括寻找一块足够大未被使用的内存。

  - 分配过程当中的问题
      - 内部和外部[碎片](https://zh.wikipedia.org/wiki/碎片（计算机） "wikilink")。
          - 减少碎片需要特别处理，从而导致更复杂的实现(参考
            [算法效率](https://zh.wikipedia.org/wiki/算法效率 "wikilink"))。
      - 分配器的[元数据需要占用额外的空间](../Page/元数据.md "wikilink")。
          - 尝试[组块来减轻这个效应](https://zh.wikipedia.org/wiki/组块 "wikilink")。

通常，内存是从一个被称为**堆**的内存池中分配出来的。高级语言封装了内存地址的概念，内存通常是通过[指针来间接访问的](https://zh.wikipedia.org/wiki/指针 "wikilink")。分配算法经常将组织分配释放组块等操作封装成抽象的接口供上层函数调用。

## 效率

堆分配的效率与分配算法的优劣关系很大。

## 实现

### 定长分配

定长分配通常被称为内存池分配，使用一个[链表来保存空闲内存块信息](../Page/链表.md "wikilink")(通常每块内存大小相同)。这种方法在简单的[嵌入式系统中效果很好](../Page/嵌入式系统.md "wikilink")。

### 伙伴系统

在这种分配方式下，内存从一个2的N次幂大的内存块中分配。当内存块比要分配的长度大两倍以上，内存块平均分裂成两块。选中其中一半，重复这个过程（检查长度，满足条件则分裂）直到内存块刚好等于需要的长度。

所有的块信息保存在一个排序过的[链表或者](../Page/链表.md "wikilink")[二叉树中](../Page/二叉树.md "wikilink")。当一个块被释放的时候与他的相邻块进行比较。如果他们都被释放，就合并成一个大块放进更大的一个块列表
中。每当分配结束，分配器会从尽量小的块重新开始分配，以避免产生不必要的碎片。

## 参见

  - [自动内存分配](https://zh.wikipedia.org/wiki/自动内存分配 "wikilink")
  - [Dynamic
    array](https://zh.wikipedia.org/wiki/Dynamic_array "wikilink")
  - [垃圾回收](https://zh.wikipedia.org/wiki/垃圾回收_\(计算机科学\) "wikilink")
  - [Hazard
    pointer](https://zh.wikipedia.org/wiki/Hazard_pointer "wikilink")
  - [Heap
    overflow](https://zh.wikipedia.org/wiki/Heap_overflow "wikilink")
  - [Hoard memory
    allocator](https://zh.wikipedia.org/wiki/Hoard_memory_allocator "wikilink")
  - [Java Virtual Machine
    heap](https://zh.wikipedia.org/wiki/Java_Virtual_Machine_heap "wikilink")
  - [`malloc`](https://zh.wikipedia.org/wiki/malloc "wikilink")
  - [内存池](https://zh.wikipedia.org/wiki/内存池 "wikilink")
  - [`mmap`](https://zh.wikipedia.org/wiki/mmap "wikilink")
  - [new (C++)](https://zh.wikipedia.org/wiki/new_\(C++\) "wikilink")
  - [obstack](https://zh.wikipedia.org/wiki/obstack "wikilink")
  - [Slab
    allocation](https://zh.wikipedia.org/wiki/Slab_allocation "wikilink")
  - [SLOB](https://zh.wikipedia.org/wiki/SLOB "wikilink")
  - [栈内存分配](https://zh.wikipedia.org/wiki/栈内存分配 "wikilink")

## 外部链接

  - [Sample bit-mapped arena memory allocator in
    C](http://code.google.com/p/arena-memory-allocation/downloads/list)
  - [TLSF: a constant time allocator for real-time
    systems](https://web.archive.org/web/20110426050202/http://rtportal.upv.es/rtmalloc/)
  - [Slides for knowing about Dynamic memory
    allocation](https://users.cs.jmu.edu/bernstdh/web/common/lectures/slides_cpp_dynamic-memory.php)
  - [Inside A Storage
    Allocator](http://www.flounder.com/inside_storage_allocation.htm)

## 补充阅读

  - ["Dynamic Storage Allocation: A Survey and Critical
    Review"](http://www.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf),
    Department of Computer Sciences [University of Texas at
    Austin](https://zh.wikipedia.org/wiki/University_of_Texas_at_Austin "wikilink")

## 参考文献

  - [Donald
    Knuth](https://zh.wikipedia.org/wiki/Donald_Knuth "wikilink").
    *Fundamental Algorithms*, Third Edition. Addison-Wesley, 1997. ISBN
    0-201-89683-4. Section 2.5: Dynamic Storage Allocation, pp. 435–456.

  - [Simple Memory Allocation
    Algorithms](https://web.archive.org/web/20060409094110/http://www.osdcom.info/content/view/31/39/)
    on OSDEV Community

  -
  -
  -
'''

[en:Memory management\#Dynamic memory
allocation](https://zh.wikipedia.org/wiki/en:Memory_management#Dynamic_memory_allocation "wikilink")

[Category:記憶體管理](https://zh.wikipedia.org/wiki/Category:記憶體管理 "wikilink")
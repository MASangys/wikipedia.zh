**匿名函数**（）在计算机编程中是指一类无需定义[标识符](https://zh.wikipedia.org/wiki/标识符 "wikilink")（函数名）的[函数或](../Page/函数.md "wikilink")[子程序](../Page/子程序.md "wikilink")，普遍存在于多种编程语言中。

1958年[LISP首先采用匿名函数](../Page/LISP.md "wikilink")，自此之后，越来越多编程语言陆续采用，主流的编程语言如[PHP](../Page/PHP.md "wikilink")\[1\]和[C++](../Page/C++.md "wikilink")\[2\]也在不久前采用。

## 用途

### 排序

尝试将类按名称排序：

``` python
a = [10, '10', 10.0]
a.sort(lambda x,y: cmp(x.__class__.__name__, y.__class__.__name__))
print a
[10.0, 10, '10']
```

上述 `10.0` 的类名是“`float`”，`10` 的类名是“`int`”而 `'10'`
的类名是“`str`”，排列后的顺序为“`float`”“`int`”，接着是“`str`”。

该示例中的匿名函数就是lambda表达式：

``` python
lambda x,y: cmp(...)
```

该匿名函数接受两个变量 `x` 和 `y` ，通过内部函数 `cmp()` 返回两者的比较值，下面的例子将按长度为字符串列表排序：

``` python
a = ['three', 'two', 'four']
a.sort(lambda x,y: cmp(len(x), len(y)))
print a
['two', 'four', 'three']
```

## 语言列表

<table>
<thead>
<tr class="header">
<th><p>语言</p></th>
<th></th>
<th><p>备注</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><a href="../Page/ActionScript.md" title="wikilink">ActionScript</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="https://zh.wikipedia.org/wiki/C语言" title="wikilink">C</a></p></td>
<td></td>
<td><p>在有<a href="https://zh.wikipedia.org/wiki/clang" title="wikilink">clang和llvm的compiler</a>-rt程序库的环境下支援</p></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/C♯.md" title="wikilink">C#</a></p></td>
<td></td>
<td><p>從C# 3.0 （.Net Farmework 3.5）開始支援</p></td>
</tr>
<tr class="even">
<td><p><a href="../Page/C++.md" title="wikilink">C++</a></p></td>
<td></td>
<td><p>从<a href="../Page/C++11.md" title="wikilink">C++11开始支援</a>，标准中称之为<strong>lambda表达式</strong>（lambda expression）<ref>{{cite web</p></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Clojure" title="wikilink">Clojure</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="https://zh.wikipedia.org/wiki/Curl语言" title="wikilink">Curl</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/D语言" title="wikilink">D</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/Object_Pascal.md" title="wikilink">Delphi</a></p></td>
<td></td>
<td><p>从Delphi 2009开始支援</p></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Dylan语言" title="wikilink">Dylan</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="https://zh.wikipedia.org/wiki/Erlang语言" title="wikilink">Erlang</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/F♯.md" title="wikilink">F#</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="https://zh.wikipedia.org/wiki/Frink" title="wikilink">Frink</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Go语言" title="wikilink">Go</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="https://zh.wikipedia.org/wiki/Haskell语言" title="wikilink">Haskell</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Java语言" title="wikilink">Java</a></p></td>
<td></td>
<td><p>从<a href="https://zh.wikipedia.org/wiki/Java_8" title="wikilink">Java 8开始支援</a><ref>{{cite web</p></td>
</tr>
<tr class="even">
<td><p><a href="../Page/JavaScript.md" title="wikilink">JavaScript</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Lisp语言" title="wikilink">Lisp</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="https://zh.wikipedia.org/wiki/Logtalk" title="wikilink">Logtalk</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Lua语言" title="wikilink">Lua</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="https://zh.wikipedia.org/wiki/Mathematica" title="wikilink">Mathematica</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Matlab" title="wikilink">Matlab</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/ML语言.md" title="wikilink">ML语言</a><br />
(<a href="https://zh.wikipedia.org/wiki/Objective_Caml" title="wikilink">Objective Caml</a>, <a href="https://zh.wikipedia.org/wiki/Standard_ML" title="wikilink">Standard ML</a>, etc.)</p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/GNU_Octave.md" title="wikilink">Octave</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/Object_Pascal.md" title="wikilink">Object Pascal</a></p></td>
<td></td>
<td><p>原生支援匿名函数，其正式名称为“匿名方法”（anonymous method）。<a href="https://zh.wikipedia.org/wiki/Oxygene" title="wikilink">Oxygene</a> Object Pascal也支持匿名函数。</p></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/Objective-C.md" title="wikilink">Objective-C</a> (Mac OS X 10.6+)</p></td>
<td></td>
<td><p>称作“块”（block）</p></td>
</tr>
<tr class="even">
<td><p><a href="https://zh.wikipedia.org/wiki/Pascal语言" title="wikilink">Pascal</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/Perl.md" title="wikilink">Perl</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/PHP.md" title="wikilink">PHP</a></p></td>
<td></td>
<td><p>从PHP 5.3.0开始支援真匿名函数，之前则只支持部分匿名函数</p></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Python语言" title="wikilink">Python</a></p></td>
<td></td>
<td><p>Python用lambda语法定义匿名函数，只需用表达式而无需声明</p></td>
</tr>
<tr class="even">
<td><p><a href="../Page/R语言.md" title="wikilink">R</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Ruby语言" title="wikilink">Ruby</a></p></td>
<td></td>
<td><p>Ruby的匿名函数源自<a href="../Page/Smalltalk.md" title="wikilink">Smalltalk</a>，也同样叫“块”（block）。</p></td>
</tr>
<tr class="even">
<td><p><a href="../Page/Rust.md" title="wikilink">Rust</a></p></td>
<td></td>
<td><p>Rust的匿名函式可以使用“<a href="https://zh.wikipedia.org/wiki/閉包" title="wikilink">閉包</a>”（Closures）來實現。</p></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Scala语言" title="wikilink">Scala</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="https://zh.wikipedia.org/wiki/Scheme语言" title="wikilink">Scheme</a></p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/Smalltalk.md" title="wikilink">Smalltalk</a></p></td>
<td></td>
<td><p>Smalltalk的匿名函数称为“块”（block）</p></td>
</tr>
<tr class="even">
<td><p><a href="../Page/Visual_Basic_.NET.md" title="wikilink">Visual Basic .NET</a> v9</p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/Visual_Prolog.md" title="wikilink">Visual Prolog</a> v 7.2</p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="https://zh.wikipedia.org/wiki/Vala语言" title="wikilink">Vala</a></p></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

## 示例

### Python

[Python用lambda语法定义匿名函数](../Page/Python.md "wikilink")，只需用表达式而无需声明

``` python
# 以下两种相等同
# 1.不使用匿名函数
def f(x):
    return x * x
# 2.使用匿名函数
lambda x: x * x
```

### JavaScript

[JavaScript支持匿名函数](../Page/JavaScript.md "wikilink")。

``` javascript
alert((function(x){
    return x*x;
})(10)); // 提示100
```

[小书签也经常使用这种结构](../Page/小书签.md "wikilink")，例如下面的一个小书签就将当前网页的标题显示为其URL：

``` javascript
javascript:document.title=location.href;
```

然而，由于该赋值语句返回了一个值（即URL本身），很多浏览器会同时创建一个新的页面显示这个值。

取而代之，下面的匿名函数就可以做到不返回任何值：

``` javascript
javascript:(function(){document.title=location.href;})();
```

第一对圆括号中的函数（“(function(){document.title=location.href;})”）用作声明一个匿名函数，而最后的一对圆括号则用来执行这个函数。同等用法有：

``` javascript
javascript:var f = function(){document.title=location.href;}; f();
```

### PHP

PHP 4.0.1之前不支持匿名函数\[3\]。

#### 4.0.1 至 5.3

PHP
4.0.1新增加了`create_function`函数，这是匿名函数的雏形。该函数能创建一个随机命名的新函数并以字符串形式返回新函数的函数名。

``` php
$foo = create_function('$x', 'return $x*$x;');
$bar = create_function("\$x", "return \$x*\$x;");
echo $foo(10);
```

要注意的是，新函数本身及其变量都要放在单引号里面，如果要放在双引号之内，美元符号“$”则需要转码成为“\\$”。

#### 5.3

PHP
5.3新增加了`Closure`类，以及能使类的实例可被调用的“魔术方法”`__invoke()`\[4\]。Lambda函数都是编译器的一种“花招”\[5\]，它能产生新的能被调用的`Closure`实例，就像函数能被调用一样。

``` php
$x = 3;
$func = function($z) { return $z *= 2; };
echo $func($x); // 输出结果为6
```

上述例子中的`$func`是`Closure`类的一个实例，而`echo
$func()`则相当于是`$func->__invoke($z)`。PHP
5.3模仿使用匿名函数，但并非支持真匿名函数，因为PHP的函数仍非第一类函数。

虽然PHP 5.3支持闭包，但还需要像这样明确标识其变量：

``` php
$x = 3;
$func = function() use(&$x) { $x *= 2; };
$func();
echo $x; // 输出结果为6
```

`$func`引用了变量`$x`（&$x），在调用的时候就会修改原来的$x，其结果在函数以外的地方也是可见的。

### C++

#### C++ 98/03

C++
98/03标准并不原生支持匿名函数。不过可以利用[Boost库的Boost](../Page/Boost_C++_Libraries.md "wikilink").Lambda来实现一个匿名函数\[6\]。

#### C++ 11

[C++11标准提供了匿名函數的支持](../Page/C++11.md "wikilink")，在《ISO/IEC
14882:2011》（C++11标准文档）中叫做**lambda表達式**\[7\]。一個lambda表達式有如下的形式：

``` cpp
[capture] (parameters) mutable exception attribute -> return_type { body }
```

必须用方括号括起来的capture列表来开始一个lambda表达式的定义。

lambda函数的形参表比普通函数的形参表多了3条限制：

1.  参数不能有缺省值
2.  不能有可变长参数列表
3.  不能有无名参数

如果lambda函数沒有形參且没有mutable、exception或attribute声明，那麼参数的空圆括號可以省略。但如果需要给出mutable、exception或attribute声明，那么参数即使为空，圆括号也不能省略。

如果函數體只有一個return語句，或者返回值類型為void，那麼返回值類型声明可以被省略：

``` cpp
[capture](parameters){body}
```

一個lambda函數的例子如下：

``` cpp
[](int x, int y) { return x + y; } // 從return語句中隱式獲得的返回值類型
[](int& x) { ++x; }   // 沒有return語句 -> lambda函數的返回值為void
[]() { ++global_x; }  // 沒有參數，僅僅是訪問一個全局變量
[]{ ++global_x; }     // 與前者相同，()可以被省略
```

在上面的第一個例子中這個無名函數的返回值是`decltype(x+y)`。如果lambda函數體的形式是` return
 `*`expression`*，或者甚麼也没返回，或者所有返回語句用`decltype`都能檢測到同一類型，那麼返回值類型可以被省略。

返回值類型可以显式指定，如下所示：

``` cpp
[](int x, int y) -> int { int z = x + y; return z; }
```

在這個例子中，一個臨時變量，`z`，被創建來儲存中間過程。與一般的函數一樣，中間值在調用的前後並不存在。甚麼也沒有返回的lambda表達式無需顯式指定返回值，沒有必要寫`->
void`代碼。

lambda函數可以捕获lambda函數外的具有automatic storage
duration的变量，即函数的局部变量与函数形参变量。函数体与這些變量的集合合起来称做[閉包](../Page/闭包_\(计算机科学\).md "wikilink")。这些外部变量在聲明lambda表達式時列在在方括號`[`和`]`中。空的方括号表示没有外界变量被capture或者按照默认方式捕获外界变量。這些變量被傳值捕獲或者引用捕獲。对于传值捕获的变量，默认为只读（这是由于lambda表达式生成的为一个函数对象，它的`operator()`成员缺省有const属性）。修改这些傳值捕獲变量将导致编译报错。但在lambda表达式的参数表的圆括号后面使用mutable关键字，就允许lambda函数体内的语句修改傳值捕獲变量，这些修改与lambda表达式（实际上是用函数对象实现）有相同的生命期，但不影响被传值捕获的外部变量的值。lambda函数可以直接使用具有static存储期的变量。如果在lambda函数的捕获列表中给出了static存储期的变量，编译时会给出警告，仍然按照lambda函数直接使用这些外部变量来处理。因此具有static存储期的变量即使被声明为传值捕获，修改该变量实际上直接修改了这些外部变量。编译器生成lambda函數对应的函数对象时，不会用函数对象的数据成员来保持被“捕获”的static存储期的变量。示例：

``` cpp
[]        // 沒有定義任何變量，但必须列出空的方括号。在Lambda表達式中嘗試使用任何外部變量都會導致編譯錯誤。
[x, &y]   // x是按值傳遞，y是按引用傳遞
[&]       // 任何被使用到的外部變量都按引用傳入。
[=]       // 任何被使用到的外部變量都按值傳入。
[&, x]    // x按值傳入。其它變量按引用傳入。
[=, &z]   // z按引用傳入。其它變量按值傳入。
```

下面這個例子展示了lambda表達式的使用：

``` cpp
std::vector<int> some_list{ 1, 2, 3, 4, 5 };
int total = 0;
std::for_each(begin(some_list), end(some_list),
                 [&total](int x) {  total += x; }
              );
```

在类的非静态成员函数中定义的lambda表达式可以显式或隐式捕捉`this`指针，从而可以引用所在类对象的数据成员与函数成员。

lambda函数的函数体中，可以访问下述变量：

  - 函数参数
  - 局部声明的变量
  - 类数据成员：要求lambda表达式声明在类成员函数中，对象的this指针必需显式捕获声明。
  - 具有静态存储期的变量（如全局变量）
  - 被捕获的外部变量
      - 显式捕获的变量
      - 隐式捕获的变量，使用默认捕获模式（传值或引用）来访问。

lambda函数的数据类型是[函数对象](../Page/函数对象.md "wikilink")，保存时必须用`std::function`模板类型或`auto`关键字。
例如：

``` cpp
#include <functional>
#include <vector>
#include <iostream>

double eval(std::function <double(double)> f, double x = 2.0)
{
    return f(x);
}

int main()
{
    std::function<double(double)> f0    = [](double x){return 1;};
    auto                          f1    = [](double x){return x;};
    decltype(f0)                  fa[3] = {f0,f1,[](double x){return x*x;}};
    std::vector<decltype(f0)>     fv    = {f0,f1};
    fv.push_back                  ([](double x){return x*x;});
    for(int i=0;i<fv.size();i++)
        std::cout << fv[i](2.0) << std::endl;
    for(int i=0;i<3;i++)
        std::cout << fa[i](2.0) << std::endl;
    for(auto &f : fv)
        std::cout << f(2.0) << std::endl;
    for(auto &f : fa)
        std::cout << f(2.0) << std::endl;
    std::cout << eval(f0) << std::endl;
    std::cout << eval(f1) << std::endl;
    std::cout << eval([](double x){return x*x;}) << std::endl;
    return 0;
}
```

一个lambda函数的捕捉表达式为空，则可以用普通函数指针存储或调用。例如：

``` cpp
auto a_lambda_func = [](int x) { /*...*/ };
void (* func_ptr)(int) = a_lambda_func;
func_ptr(4); //calls the lambda.
```

#### C++14

[C++14增加了广义捕获](../Page/C++14.md "wikilink")(Generalized
capture)。\[8\]即在捕获子句（capture
clause）中增加并初始化新的变量，该变量不需要在lambda表达式所处的闭包域（enclosing
scope）中存在；即使在闭包域中存在也会被新变量覆盖(override)。新变量类型由它的初始化表达式推导。一个用途是可以从闭包域中捕获只供[移动的变量并使用它](https://zh.wikipedia.org/wiki/移动语义 "wikilink")。

C++14还允许lambda函数的形参使用`auto`关键字作为其类型，这实质上是函数对象的`operator()`成员作为模板函数；并且允许[可变参数模板](../Page/可变参数模板.md "wikilink")。

``` cpp
auto a_lambda_func = [data1=101](int x) { /*...*/ }; //广义捕获，实质上是在函数对象中增加了数据成员data1并初始化

auto ptr = std::make_unique<int>(10); //See below for std::make_unique
auto lambda1 = [ptr = std::move(ptr)] {return *ptr;}
          //大致等效于：
auto lambda2 = [ptr = std::make_unique<int>(10)] {return *ptr;}

auto lambda3 = [](auto x, auto y) {return x + y;} //lambda函数的形参类型为auto
struct unnamed_lambda                            //这相当于函数对象：
{
  template<typename T, typename U>
    auto operator()(T x, U y) const {return x + y;}
};

auto lambda4 = [](auto&&... params)             //可变参数的函数模板
  {
     return (foo(std::forward<decltype(params)>(params)...));
  }
```

### [Visual Basic.NET](https://zh.wikipedia.org/wiki/Visual_Basic.NET "wikilink")

匿名函数或lambda表达式即无名的函数或过程，作为表达式的值。可以写为一行或多行。例如：

``` vb.net
 Dim func1=Function(i As integer) i+10
 Dim action = sub()
   End Sub
 Dim func2 = Function()
   End Function
```

可以在声明匿名函数的同时调用它。单行的lambda表达式不能使用Return关键字，其返回类型是自动推导得出；其参数要么都是用As关键字指明类型，要么全部是自动推导出类型。

lambda表达式在定义时可以使用所在上下文（context，即C++语言的闭包closure）的局部变量、参数、属性、Me等等的值，即使lambda表达式离开了定义时所在的context，这些被使用的局部变量等的值仍然有效。这是因为lambda表达式在定义时把所用到的context的值保存到它自己的定义类中。lambda表达式可以嵌套定义。

## 参考资料

## 外部链接

  - [《深入理解PHP内核》第四章 函数的实现 第四节
    匿名函数及闭包](http://www.php-internal.com/book/?p=chapt04/04-04-anonymous-function)

[Category:数据类型](https://zh.wikipedia.org/wiki/Category:数据类型 "wikilink")
[Category:函数编程](https://zh.wikipedia.org/wiki/Category:函数编程 "wikilink")
[Category:Lambda演算](https://zh.wikipedia.org/wiki/Category:Lambda演算 "wikilink")
[Category:子程序](https://zh.wikipedia.org/wiki/Category:子程序 "wikilink")
[Category:C++](https://zh.wikipedia.org/wiki/Category:C++ "wikilink")

1.
2.
3.  <http://php.net/create_function> the top of the page indicates this
    with "(PHP 4 \>= 4.0.1, PHP 5)"
4.  <http://wiki.php.net/rfc/closures>
5.  <http://wiki.php.net/rfc/closures#zend_internal_perspective>
6.
7.  该标准文档可以在[ISO/IEC 14882:2011 - Information technology -- Programming
    languages --
    C++](http://www.iso.org/iso/catalogue_detail.htm?csnumber=50372)购买，或者可参看2012年一月份的标准草案文件[N3337](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf)，第5.1.2节的Lambda
    expressions
8.  MSDN: In C++14, you can introduce and initialize new variables in
    the capture clause, without the need to have those variables exist
    in the lambda function’s enclosing scope. The initialization can be
    expressed as any arbitrary expression; the type of the new variable
    is deduced from the type produced by the expression. One benefit of
    this feature is that in C++14 you can capture move-only variables
    (such as std::unique_ptr) from the surrounding scope and use them
    in a lambda.
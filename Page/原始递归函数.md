> 本文内容由[原始递归函数](https://zh.wikipedia.org/wiki/原始递归函数)转换而来。


在[可计算性理论](../Page/可计算性理论.md "wikilink")中，**原始递归函数**（）对计算的完全的形式化而言是形成重要构造板块的一类函数。它们使用[递归](../Page/递归.md "wikilink")和[复合作为中心运算来定义](https://zh.wikipedia.org/wiki/函数复合 "wikilink")，并且是[递归函数](../Page/递归函数.md "wikilink")的严格的[子集](../Page/子集.md "wikilink")，它们完全是[可计算函数](../Page/可计算函数.md "wikilink")。通过补充允许[偏函数和介入无界查找运算可以定义出递归函数的更广泛的类](https://zh.wikipedia.org/wiki/偏函数 "wikilink")。

通常在[数论](../Page/数论.md "wikilink")中研究的很多函数，近似于实数值函数，比如[加法](../Page/加法.md "wikilink")、[除法](../Page/除法.md "wikilink")、[阶乘](https://zh.wikipedia.org/wiki/阶乘 "wikilink")、[指数](https://zh.wikipedia.org/wiki/指数 "wikilink")，找到第 *n* 个素数等等是原始递归的（Brainerd and Landweber, 1974）。实际上，很难设计不是原始递归的函数，尽管某些函数是已知的(比如[阿克曼函数](https://zh.wikipedia.org/wiki/阿克曼函数 "wikilink"))。所以，通过研究它们，我们能发现有广泛影响的结论的那些性质。

原始递归函数可以用总是停机的[图灵机](../Page/图灵机.md "wikilink")计算，而递归函数需要[图灵完全系统](https://zh.wikipedia.org/wiki/图灵完全 "wikilink")。

原始递归函数的集合在[计算复杂性理论中叫做](https://zh.wikipedia.org/wiki/计算复杂性理论 "wikilink")[PR](https://zh.wikipedia.org/wiki/PR_\(複雜度\) "wikilink")。

## 定义

原始递归函数接受[自然数](../Page/自然数.md "wikilink")或自然数的[元组作为参数并生成自然数](https://zh.wikipedia.org/wiki/元组 "wikilink")。接受 *n* 个参数的函数叫做 *n*-[元函数](../Page/元数.md "wikilink")。基本原始递归函数用如下[公理](../Page/公理.md "wikilink")给出:

1.  **常数函数**: 0 元[常数函数](https://zh.wikipedia.org/wiki/常数函数 "wikilink") 0 是原始递归的。
2.  **后继函数**: 1 元[后继函数](https://zh.wikipedia.org/wiki/后继函数 "wikilink") *S*，它接受一个参数并返回[皮亚诺公理](../Page/皮亚诺公理.md "wikilink")给出的后继数，是原始递归的。
3.  **投影函数**: 对于所有 *n*≥1 和每个 1≤*i*≤*n* 的 *i*，*n* 元投影函数 *P*<sub>*i*</sub><sup>*n*</sup>，它接受 *n* 个参数并返回它们中的第 *i* 个参数，是原始递归的。

更加复杂的递归函数可以通过应用下列公理给出的[运算来获得](https://zh.wikipedia.org/wiki/运算 "wikilink"):

1.  **复合**: 给定*k* 元原始递归函数 *f*，和 *k* 个 *m* 元原始递归函数 *g*<sub>1</sub>,...,*g*<sub>*k*</sub>，*f* 和 *g*<sub>1</sub>,...,*g*<sub>*k*</sub> 的[复合](https://zh.wikipedia.org/wiki/函数复合 "wikilink")，也就是 *m* 元函数 *h*(*x*<sub>1</sub>,...,*x*<sub>*m*</sub>) = *f*(*g*<sub>1</sub>(*x*<sub>1</sub>,...,*x*<sub>*m*</sub>),...,*g*<sub>*k*</sub>(*x*<sub>1</sub>,...,*x*<sub>*m*</sub>)), 是原始递归的。
2.  **原始递归**: 给定 *k* 元原始递归函数 *f*，和 *k*+2 元原始递归函数 *g*，定义为 *f* 和 *g* 的原始递归的 *k*+1 元函数，也就是函数 *h* 这里的 *h*(0,*x*<sub>1</sub>,...,*x*<sub>*k*</sub>) = *f*(*x*<sub>1</sub>,...,*x*<sub>*k*</sub>) 并且 *h*(*S*(*n*),*x*<sub>1</sub>,...,*x*<sub>*k*</sub>) = *g*(*h*(*n*,*x*<sub>1</sub>,...,*x*<sub>*k*</sub>),*n*,*x*<sub>1</sub>,...,*x*<sub>*k*</sub>), 是原始递归的。

服从这些公理的函数是原始递归的，如果它是上述基本函数之一，或者它可以通过应用有限次数的运算获得自基本函数。

### 投影函数的作用

投影函数可用来避免采用上述明显刻板的函数[元数](../Page/元数.md "wikilink")方式；通过使用各种投影函数的复合，有可能把一个函数的参数子集传递到另一个函数。例如，如果 *g* 和 *h* 是二元原始递归函数，则

\[f(a,b,c) = g(h(a,c),h(a,b)) \!\] 也是原始递归的。使用投影函数的一个形式定义为

\[f(a,b,c) = g(h(P^3_1(a,b,c),P^3_3(a,b,c)),h(P^3_1(a,b,c),P^3_2(a,b,c)))\].

### 转换谓词到数值函数

在某些设置中，自然的考虑接受混合了数值和真值{ t= true, f=false } 的参数，或生成真值作为输出的原始递归函数(参见 Kleene \[1952 pp.226-227\])。这可以通过把真值识别为任何固定方式的数值来完成。例如，通常把真值*t* 识别为 *1* 和真值 *f* 识别为 *0*。一旦作出这种识别，集合 *A* 的[特征函数](../Page/指示函数.md "wikilink")，它在文字上返回 *1* 或 *0*，可以被看作判定一个数是否在集合 *A* 中的谓词。把谓词识别为数值函数的这种方式将假定于本文余下部分。

## 例子

### [加法](../Page/加法.md "wikilink")

直觉上我们会把加法递归的定义为:

  -
    add(0,*x*)=*x*
    add(*n*+1,*x*)=add(*n*,*x*)+1

为了使它适合于严格的原始递归定义,我们定义:

  -
    add(0,*x*)=*P*<sub>1</sub><sup>1</sup>(*x*)
    add(S(*n*),*x*)=*S*(*P*<sub>1</sub><sup>3</sup>(add(*n*,*x*),*n*,*x*))

(注意: 这里的 *P*<sub>1</sub><sup>3</sup> 是一个函数，它接受 3 个参数并返回第一个。)

*P*<sub>1</sub><sup>1</sup> 是简单的[恒等函数](https://zh.wikipedia.org/wiki/恒等函数 "wikilink")；包含它是上述原始递归运算定义的要求；它扮演了 *f* 的角色。*S* 和 *P*<sub>1</sub><sup>3</sup> 的复合，它是原始递归的，它扮演了 *g* 的角色。

### [减法](https://zh.wikipedia.org/wiki/减法 "wikilink")

我们可以定义*有限减法*，就是说，截止到 0 的减法(因为我们还没有负数的概念呢)。首先我们必须定义"前驱" 函数，它担任后继函数的对立物。

直觉上我们会把前驱定义为:

  -
    pred(0)=0
    pred(*n*+1)=*n*

为了使它适合正式的原始递归定义，我们写:

  -
    pred(0)=0
    pred(S(*n*))=*P*<sub>2</sub><sup>2</sup>(pred(*n*),*n*)

现在我们以类似加法的方式定义减法。

  -
    sub(0,*x*)=*P*<sub>1</sub><sup>1</sup>(*x*)
    sub(S(*n*),*x*)=pred(*P*<sub>1</sub><sup>3</sup>(sub(*n*,*x*),*n*,*x*))

出于简单的缘故，切换了"标准"定义的参数次序来适合原始递归的要求，就是说， sub(*a*,*b*) 对应于 *b*-*a*。这可以轻易的使用适当的投影来矫正。

很多类似的函数可以被证明是原始递归的；一些例子包括[条件](https://zh.wikipedia.org/wiki/条件 "wikilink")、[指数](https://zh.wikipedia.org/wiki/指数 "wikilink")、[素数检验和](https://zh.wikipedia.org/wiki/素数检验 "wikilink")[数学归纳法](../Page/数学归纳法.md "wikilink")，并且原始递归函数可以被扩展来运算在其他对象上比如整数和有理数。

#### 在整数和有理数上的运算

通过使用[哥德尔数](../Page/哥德尔数.md "wikilink")，原始递归函数可以被扩展到在其他对象比如整数和[有理数](../Page/有理数.md "wikilink")上的运算上。如果以标准方式编码整数用哥德尔数，算术运算包括加法、减法、乘法都是原始递归的。类似的，如果以哥德尔数表示有理数，则[域运算都是原始递归的](https://zh.wikipedia.org/wiki/域_\(数学\) "wikilink")。

## 与递归函数的联-{}-系

通过介入[无界查找算子可定义更广泛的](https://zh.wikipedia.org/wiki/mu算子 "wikilink")[偏递归函数类](https://zh.wikipedia.org/wiki/偏递归函数 "wikilink")。这个算子的使用可以导致[偏函数](https://zh.wikipedia.org/wiki/偏函数 "wikilink")，就是说，对每个参数有最多一个值，但是不同于全函数，不必须对参数有值的关系(参见[定义域](../Page/定义域.md "wikilink"))。一个等价的定义声称偏递归函数是可以被[图灵机](../Page/图灵机.md "wikilink")就算的函数。全递归函数是对所有输入有定义的偏递归函数。

所有原始递归函数都是全递归的，但不是所有全递归函数都是原始递归的。[阿克曼函数](https://zh.wikipedia.org/wiki/阿克曼函数 "wikilink") *A*(*m*,*n*)是周知的不是原始递归的全递归函数。原始递归函数有作为使用阿克曼函数的全递归函数的子集的一个特征。这个特征声称一个函数是原始递归的，当且仅当有一个自然数 *m* 使得这个函数可以被总在 A(*m*,*n*) 或更少步骤内停机的图灵机计算，这里的 *n* 是原始递归函数的参数的总数。

## 限制

原始递归函数意图紧密对应于我们直觉上可计算函数应该的样子。当然函数的初始集合在直觉上是可计算的(因为它们非常简单)，而你能用来建立新原始递归函数的两个运算也是非常直接的。但是原始递归函数的集合不包含所有可能的可计算函数 — 这可以看作康拖尔[对角论证法的变体](https://zh.wikipedia.org/wiki/对角论证法 "wikilink")。这个论证提供了一个不是原始递归的可计算函数。证明的梗概如下:

原始递归函数集合可以[被计算枚举](../Page/递归可枚举集合.md "wikilink")。这个编号方案在函数定义上是唯一的，尽管在实际函数自身上不是唯一的(因为所有的函数都可以有无限数目的定义 — 考虑简单的由[恒等函数构成](https://zh.wikipedia.org/wiki/恒等函数 "wikilink"))。这个编码在可计算性的形式模型，比如[递归函数](../Page/递归函数.md "wikilink")或[图灵机](../Page/图灵机.md "wikilink")下定义的意义上是可计算的，[邱奇-图灵论题涉及的任何机器都可以](https://zh.wikipedia.org/wiki/邱奇-图灵论题 "wikilink")。

现在考虑一个矩阵，这里的行是在这个编号方案下的有一个参数的原始递归函数，而列是自然数。则每个元素 (*i*, *j*) 对应于计算于数 *j* 之上的第 *i* 个一元原始递归函数。我们可以写为 *f*<sub>*i*</sub>(*j*)。

现在我们考虑函数 *g*(*x*) = S(*f*<sub>*x*</sub>(*x*))。*g* 位于这个矩阵的对角线上，并简单的对它找到的值加一。这个函数是可计算的(按上述定义)，但是明显的没有计算它的原始递归函数存在，因为它与每个可能的原始递归函数都有至少一个值不同。所以，必然存在不是原始递归的可计算函数。

这个论证可以应用于能用这种方式枚举的任何一类的可计算(全)函数上。所以，任何这种可计算(全)函数的明确列表都不可能是完全的，比如那些可以用[总是停机的机器计算的函数](../Page/判定器.md "wikilink")。但是要注意，*偏*可计算函数集合(那些不需要对所有参数有定义的函数)可以被明确的枚举，例如通过枚举[图灵机](../Page/图灵机.md "wikilink")编码。

可以明确展示的一个简单的 1-元可计算函数[阿克曼函數](../Page/阿克曼函數.md "wikilink")，它是对任何自然数递归定义的，但不是原始递归的。

## 参考

  - Brainerd, W.S., Landweber, L.H. (1974), *Theory of Computation*, Wiley, ISBN 0471095850

## 参见

  - [判定器](../Page/判定器.md "wikilink")

## 引-{}-用

  - Brainerd, W.S., Landweber, L.H. (1974), *Theory of Computation*, Wiley, ISBN 0-471-09585-0
  - Robert I. Soare, *Recursively Enumerable Sets and Degrees*, Springer-Verlag, 1987. ISBN 0-387-15299-7
  - [Stephen Kleene](https://zh.wikipedia.org/wiki/Stephen_Kleene "wikilink") (1952) *Introduction to Metamathematics*, North-Holland Publishing Company, New York, 11th reprint 1971: (2nd edition notes added on 6th reprint). In Chapter XI. General Recursive Functions §57
  - [George Boolos](https://zh.wikipedia.org/wiki/George_Boolos "wikilink"), [John Burgess](https://zh.wikipedia.org/wiki/John_Burgess "wikilink"), [Richard Jeffrey](https://zh.wikipedia.org/wiki/Richard_Jeffrey "wikilink") (2002), *Computability and Logic: Fourth Edition*, Cambridge University Press, Cambridge, UK. Cf pp. 70-71.

[Category:递归论](https://zh.wikipedia.org/wiki/Category:递归论 "wikilink") [Category:函数](https://zh.wikipedia.org/wiki/Category:函数 "wikilink")
> 本文内容由[反射 \(计算机科学\)](https://zh.wikipedia.org/wiki/反射_\(计算机科学\))转换而来。


在[计算机学中](https://zh.wikipedia.org/wiki/计算机学 "wikilink")，**反射**（）是指[计算机程序](../Page/计算机程序.md "wikilink")在[运行时](https://zh.wikipedia.org/wiki/运行时 "wikilink")（）可以访问、检测和修改它本身状态或行为的一种能力。\[1\]用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。

要注意术语“反射”和“[内省](https://zh.wikipedia.org/wiki/内省_\(计算机科学\) "wikilink")”（）的关系。内省（或称“自省”）机制仅指程序在运行时对自身信息（称为[元数据](../Page/元数据.md "wikilink")）的检测；反射机制不仅包括要能在运行时对程序自身信息进行检测，还要求程序能进一步根据这些信息改变程序状态或结构。\[2\]

## 概况

反射用于观察并修改程序在[运行时的行为](https://zh.wikipedia.org/wiki/运行时 "wikilink")。一个面向反射的（reflection-oriented）程序组件可以监测一个范围内的[代码](../Page/代码.md "wikilink")执行情况，可以根据获取的目标对象信息及与此相关的范围修改自身。这可通过在运行时动态分配程序代码实现。

在类型检测严格的[面向对象的](../Page/面向对象程序设计.md "wikilink")[编程语言](../Page/编程语言.md "wikilink")如[Java](../Page/Java.md "wikilink")中，一般需要在编译期间对程序中需要调用的对象的具体类型、接口、字段和方法的合法性进行检查。反射技术则允许将对需要调用的对象的信息检查工作从编译期间推迟到运行期间再现场执行。这样一来，可以在编译期间先不明确目标对象的[接口名称](../Page/介面_\(程式設計\).md "wikilink")、[字段](https://zh.wikipedia.org/wiki/字段 "wikilink")（fields，即对象的成员变量）、可用[方法](../Page/方法_\(電腦科學\).md "wikilink")，然后在运行根据目标对象自身的信息决定如何处理。它还允许根据判断结果进行[实例化新对象和相关方法的调用](https://zh.wikipedia.org/wiki/实例化 "wikilink")。

反射主要用途就是使给定的程序动态地适应不同的运行情况。利用面向对象建模中的[多态性也可以简化编写分别适用于多种不同情形的功能代码](https://zh.wikipedia.org/wiki/多态_\(计算机科学\) "wikilink")，但是反射可以解决多态性并不适用的更普遍情形，从而更大程度地避免[硬编码](https://zh.wikipedia.org/wiki/硬编码 "wikilink")（即把代码的细节“写死”，缺乏灵活性）的代码风格。

反射也是[元编程](../Page/元编程.md "wikilink")的一个关键策略。

## 示例

考虑一个面向对象风格的应用程序，它可以分别使用功能类X、功能类Y、功能类Z来执行相似的操作。如果事先创建并传递给它的工具是类A的实例，它就调用类A实例具有的方法完成功能；如果事先创建的是类B的实例，它就调用类B实例具有的方法完成功能，如果事先创建的是类C的实例，它就调用类C实例完成功能。如果它们完成相似功能的方法名称都相同，或方法都继承自同一个父类并实现了[多态性](https://zh.wikipedia.org/wiki/多态_\(计算机科学\) "wikilink")，那么只需调用名称唯一的目标方法即可，问题已经解决；如果这些条件并不满足，我们碰到的问题变成要根据情况从不同对象中调用名称上存在区别、功能却相似的方法，此时只能分别判断3种不同情况然后挨个进行[硬编码](https://zh.wikipedia.org/wiki/硬编码 "wikilink")，或者考虑使用更优雅的反射技巧。分别判断并硬编码的做法是：在主程序中对不同的功能类进行差异化对待，在运行主程序的时候判断当前可用的工具是不是类A的实例，如果是就以明确“指名道姓”的方式调用它的特定方法，如果不是就继续判断可用的工具是不是类B的实例，如果是就调用B的特定方法，如果也不是就将其视为类C的实例并调用对应的方法。如果可能的类型更多的话，就需要写更多的条件分支语句。然而，如果使用反射式的编程技术，应用程序可以在只写出主要流程、但不写死具体方法名称的情况下，在运行时期灵活地获取可用的目标对象信息，根据目标方法的大致特征自动识别和调用需要的方法，并自动调用目标对象的对应方法解决问题。

## 历史背景

早期计算机的原生[汇编语言](../Page/汇编语言.md "wikilink")本质上就具有反射特性。因为它是由定义编程指令作为数据，如动态修改指令或对它们进行分析等等的反射功能是很平常的。编程发展到如[C语言等高抽象层次的语言时](https://zh.wikipedia.org/wiki/C语言 "wikilink")，这种实践消失了，带有反射特性的高级编程语言要到更晚的时候才出现。

1982年，布莱恩·史密斯（Brian Cantwell Smith）在其博士论文《编程语言中的步骤式反射》("Procedural Reflection in Programming Languages")中介绍了“编程语言的计算反射”概念，并且引入meta-circular解释器的概念用作3-Lisp的一个组成部分。

## 特点

### 优点

支持反射的语言提供了一些在早期高级语言中难以实现的运行时特性。

  - 可以在一定程度上避免硬编码，提供灵活性和通用性。\[3\]
  - 可以作为一个[第一類物件](../Page/第一類物件.md "wikilink")发现并修改源代码的结构（如代码块、类、方法、协议等）。
  - 可以在运行时像对待源代码语句一样动态解析字符串中可执行的代码（类似[JavaScript](../Page/JavaScript.md "wikilink")的eval()函数），进而可将跟class或function匹配的字符串转换成class或function的调用或引用。
  - 可以创建一个新的语言字节码解释器来给编程结构一个新的意义或用途。

### 劣势

  - 此技术的学习成本高。面向反射的编程需要较多的高级知识，包括框架、关系映射和对象交互，以实现更通用的代码执行。
  - 同样因为反射的概念和语法都比较抽象，过多地滥用反射技术会使得代码难以被其他人读懂，不利于合作与交流。\[4\]
  - 由于将部分信息检查工作从编译期推迟到了运行期，此举在提高了代码灵活性的同时，牺牲了一点点运行效率。\[5\]

通过深入学习反射的特性和技巧，它的劣势可以尽量避免，但这需要许多时间和经验的积累。\[6\]

## 常见应用

  - 反射经常作为[软件测试](../Page/软件测试.md "wikilink")的一部分，比如运行时创建/实例化模拟对象。
  - Java语言解析[XML](../Page/XML.md "wikilink")文件的技术用到了反射。

## 参见

  - [程序自修改](https://zh.wikipedia.org/wiki/程序自修改 "wikilink")
  - [反射式编程语言和平台列表](../Page/反射式编程语言和平台列表.md "wikilink")

## 参考资料

### 引用

### 来源

  -
## 外部链接

  - 。

[Category:編程典範](https://zh.wikipedia.org/wiki/Category:編程典範 "wikilink")

1.  见。
2.
3.
4.  见。
5.
6.
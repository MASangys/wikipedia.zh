**因数**（又称**约数**)是一个常见的[数学名词](../Page/数学.md "wikilink")，用于描述非零[整数](../Page/整数.md "wikilink")
\(a\) 和[整数](../Page/整数.md "wikilink") \(b\)
之间存在的[整除关系](https://zh.wikipedia.org/wiki/整除 "wikilink")，即
\(b\) 可以被 \(a\) [整除](https://zh.wikipedia.org/wiki/整除 "wikilink")。这里我们称
\(b\) 是 \(a\) 的**倍数**，\(a\) 是 \(b\) 的**因数**、**约数**或**因子**.

## 定义

设 \(a,b\) 满足 \(a\in \mathbb{N}^*,b\in \mathbb{N}\). 若存在
\(q\in \mathbb{N}\) 使得 \(b=aq\), 那么就说 \(b\) 是 \(a\)
的[倍数](https://zh.wikipedia.org/wiki/倍数 "wikilink")， \(a\) 是 \(b\)
的[约数](https://zh.wikipedia.org/wiki/约数 "wikilink")。这种关系记作
\(a|b\),读作“\(a\) [整除](https://zh.wikipedia.org/wiki/整除 "wikilink")
\(b\)”.

例如 \(24=3\times 8,\;1150=25\times 46\). 所以 \(3|24,\;25|1150\)，同时 \(3\) 是
\(24\) 的因数；\(25\) 是 \(1150\) 的因数。

## 性质

  - 若 \(a|b,\;b|c\) 那么 \(a|c\).

<!-- end list -->

  - 若 \(a|b,\;a|c\) 且 \(x,y\in\mathbb{Z}\), 有 \(a|(bx+cy)\).

<!-- end list -->

  - 若 \(a|b\), 设 \(t\not= 0\), 那么 \((ta)|(tb)\).

<!-- end list -->

  - 若 \(b=qd+c\), 那么 \(d|b\)
    的[充要条件是](https://zh.wikipedia.org/wiki/充要条件 "wikilink")
    \(d|c\)

<!-- end list -->

  - 若 \(x,y\in\mathbb{Z}\) 满足 \(ax+by=1,\;a|n.\;b|n\) 那么 \(ab|n\).

这里对最后一条性质进行证明:

\(\because a|n,\;b|n\quad\therefore ab|bn,\;ab|an\quad\therefore ab|(anx+bny)\)

\(\because ax+by=1\quad\therefore ab|n\)

证毕。

## 相关定理

### 整数的[唯一分解定理](https://zh.wikipedia.org/wiki/唯一分解定理 "wikilink")

任何一个[正整数都有且仅有一种方式写出它所有](https://zh.wikipedia.org/wiki/正整数 "wikilink")[素数因子的](../Page/素数.md "wikilink")[乘积表达式](https://zh.wikipedia.org/wiki/乘积表达式 "wikilink")。这个过程称为[质因数分解](https://zh.wikipedia.org/wiki/质因数分解 "wikilink")

如果 \(A\in\mathbb{N}^{+}\), 那么

\(A=\prod_{i=1}^n p_i^{a_i}\), 其中 \(p_i\)
是一个[素数](../Page/素数.md "wikilink").

这种表示方法是唯一的。

### 因数个数

[自然数](../Page/自然数.md "wikilink") \(N\) 的因数个数以 \(d(n)\) 表示。

若 \(N\) 唯一分解为
\(N=p_1^{a_1}\times p_2^{a_2}\times p_3^{a_3}\times\cdots\times p_n^{a_n}=\prod_{i=1}^n p_i^{k_i}\),
则
\(d(N)=(a_1+1)\times (a_2+1)\times (a_3+1)\times\cdots\times (a_n+1)=\prod_{i=1}^n\left (a_i+1\right )\).

例如 \(2646=2 \times 3^3 \times 7^2\)，则其正因数个数
\(d(2646)=(1+1)\times(3+1)\times(2+1)=24\)。

### 因数和

[自然数](../Page/自然数.md "wikilink")的正因数和，以[因数函数](https://zh.wikipedia.org/wiki/因数函数 "wikilink")
\(\sigma (N)\) 表示。由质因数分解而得。

若 \(N\) 唯一分解为
\(N=p_1^{a_1}\times p_2^{a_2}\times p_3^{a_3}\times\cdots\times p_n^{a_n}=\prod_{i=1}^n p_i^{k_i}\),
则 \(\sigma (N)=\prod_{i=1}^n\left (\sum_{j=0}^{a_i} p_i^j\right )\).

再由[等比级数求和公式可知](https://zh.wikipedia.org/wiki/等比级数 "wikilink")，上式亦可写成：

\(\begin{align}
\sigma (N) &=\frac{p_1^{a_1+1}-1}{p_1-1} \times \frac{p_2^{a_2+1}-1}{p_2-1} \times \cdots \times \frac{p_n^{a_n+1}-1}{p_n-1}
&\end{align}\)

例如\(2646=2 \times 3^3 \times 7^2\)，则其正因数之和

\(\begin{align}\sigma(2646)
&=(1+2)\times(1+3+9+27)\times(1+7+49)\\
&=\frac{2^2-1}{2-1} \times \frac{3^4-1}{3-1} \times \frac{7^3-1}{7-1}\\
&=3 \times 40 \times 57\\
&=6840
\end{align}\)。

## 其他

  - 所有*n*的正因數都是n的[質因數的](https://zh.wikipedia.org/wiki/質因子 "wikilink")[積的一些](https://zh.wikipedia.org/wiki/積 "wikilink")[冪](../Page/冪.md "wikilink")。這是[算術基本定理的結果](https://zh.wikipedia.org/wiki/算術基本定理 "wikilink")。

<!-- end list -->

  - 1是所有整數的正因數，-1是所有整數的負因數，因為\(x=1x=-1\times(-x)\)

由上式同樣可證明，一個整數及其[相反數必然為自身的因數](https://zh.wikipedia.org/wiki/相反數 "wikilink")，叫做明顯因數。

  - *n*的正因數數目是[積性函數](../Page/積性函數.md "wikilink")*d(n)*，正因數之和則是另一個積性函數*σ(n)*。詳見[除數函數](../Page/除數函數.md "wikilink")

<!-- end list -->

  - 質數\(p\)只有2個正因數：1, \(p\)。\(p\)
    的[平方數只有三個正因數](https://zh.wikipedia.org/wiki/平方數 "wikilink")：1,
    \(p\), \(p^2\)。

## \-{zh-cn:程序;zh-hant:程式}-參考

### 给定整数的所有因数

这个程序可以打印给定正整数 \(n\) 的所有正因数。时间复杂度为 \(O(N)\)

#### [C語言](https://zh.wikipedia.org/wiki/C語言 "wikilink")

``` cpp
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
 int n=0,i;
 printf("請輸入一個正整數Ｎ:");
 scanf("%d",&n);
 for(i=1;i<=n;i++)
  {
    if(n%i==0)printf("%d \n",i);
  }
 system("pause");
 return 0;
}
```

### \(A^B\) 的因数和 \[1\]

这个程序可以打印 \(A^B\) 的所有因数之和，由于这个答案可能很大，所以会对一个整数取模，默认为 2147483648.

#### [C++](../Page/C++.md "wikilink")

``` cpp
#include<bits/stdc++.h>

constexpr auto mod = 2147483648LL;
long int a, b;
long long n[10001], p[10001];

template<typename T>
T Prid(T a, T b) {
    T sum = 1;
    for (; b > 0; b >>= 1) {
        if (b & 1)sum = sum * a%mod;
        a = a * a%mod;
    }
    return sum;
}

template<typename T>
T Get_Sum(T p, T n) {
    if (n == 0)return 1;
    if (n & 1)return (Get_Sum(p, (n >> 1))*(1 + Prid(p, (n >> 1) + 1))) % mod;
    else return (Get_Sum(p, (n >> 1) - 1)*(1 + Prid(p, (n >> 1) + 1)) + Prid(p, (n >> 1))) % mod;
}

int main()
{
    std::cin >> a >> b;
    unsigned int nowAt = 0;

    for (int i = 2; i*i <= a; i += (i == 2 ? 1 : 2))
        if (a%i == 0) {
            p[nowAt] = i;
            n[nowAt] = 0;
            while (a%i == 0) { ++n[nowAt]; a /= i; }
            ++nowAt;
        }
    if (a != 1) {
        p[nowAt] = a; n[nowAt++] = 1;
    }

    long long ans = 1;
    for (int i = 0; i < nowAt; i++)
        ans = (ans*Get_Sum(p[i], n[i] * b)) % mod;

    std::cout << ans << std::endl;

    system("pause");
    return 0;
}
```

#### [C\#](https://zh.wikipedia.org/wiki/C# "wikilink")

``` C#
using System;
namespace DS
{
    class Program
    {
        public static class Global
        {
            public static readonly Int64 mod = 2147483648;
        }

        static void Main(string[] args)
        {
            string[] div = Console.ReadLine().Split(' ');
            Int64 a = Convert.ToInt64(div[0]), b = Convert.ToInt64(div[1]);
            uint nowAt = 0;

            Int64[] p = new Int64[10001], n = new Int64[10001];

            for (int i = 2; i * i <= a; i += (i == 2 ? 1 : 2))
                if (a % i == 0)
                {
                    p[nowAt] = i;
                    n[nowAt] = 0;
                    while (a % i == 0) { ++n[nowAt]; a /= i; }
                    ++nowAt;
                }
            if (a != 1)
            {
                p[nowAt] = a; n[nowAt++] = 1;
            }

            Int64 ans = 1;
            for (int i = 0; i < nowAt; i++)
                ans = (ans * Get_Sum(p[i], n[i] * b)) % Global.mod;

            Console.WriteLine(ans.ToString());
        }

        static Int64 Prid(Int64 a,Int64 b)
        {
            Int64 sum = 1;
            for (; b > 0; b >>= 1)
            {
                if ((b & 1) == 1) sum = sum * a % Global.mod;
                a = a * a % Global.mod;
            }return sum;
        }

        static Int64 Get_Sum(Int64 p,Int64 n)
        {
            if (n == 0) return 1;
            if ((n & 1) == 1) return (Get_Sum(p, (n >> 1)) * (1 + Prid(p, (n >> 1) + 1))) % Global.mod;
            else return (Get_Sum(p, (n >> 1) - 1) * (1 + Prid(p, (n >> 1) + 1)) + Prid(p, (n >> 1))) % Global.mod;
        }
    }
}
```

## 相關條目

  - 因數判別法可參照[整除規則](https://zh.wikipedia.org/wiki/整除規則 "wikilink")。
  - [質數](https://zh.wikipedia.org/wiki/質數 "wikilink")
  - [同余](https://zh.wikipedia.org/wiki/同余 "wikilink")
  - [質因數](https://zh.wikipedia.org/wiki/質因子 "wikilink")
  - [公倍數](https://zh.wikipedia.org/wiki/公倍數 "wikilink")、[最小公倍數](../Page/最小公倍數.md "wikilink")
  - [公因數](https://zh.wikipedia.org/wiki/公因數 "wikilink")、[最大公因數](../Page/最大公因數.md "wikilink")

[Category:初等数论](https://zh.wikipedia.org/wiki/Category:初等数论 "wikilink")
[Category:除法](https://zh.wikipedia.org/wiki/Category:除法 "wikilink")

1.  <http://poj.org/problem?id=1845>
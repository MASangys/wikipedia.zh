**复制省略**或者译作“省略不必要的复制”（copy
elision），是[C++](../Page/C++.md "wikilink")语言标准中定义的编译优化技术。

当一个[class类型的](../Page/类_\(计算机科学\).md "wikilink")的临时对象用于初始化同类型的对象\[1\][ISO](https://zh.wikipedia.org/wiki/ISO "wikilink")/[IEC](https://zh.wikipedia.org/wiki/IEC "wikilink")
(2003). *[ISO/IEC 14882:2003(E): Programming Languages -
C++](https://zh.wikipedia.org/wiki/ISO/IEC_14882 "wikilink") §12.8
Copying class objects \[class.copy\]* para.
15</ref>时，复制初始化通常优化为直接初始化；但在语义上仍然需要[复制构造函数是可访问的](https://zh.wikipedia.org/wiki/复制构造函数 "wikilink")。\[2\]
例如：

``` cpp
#include <iostream>

struct C {
  explicit C(int) {}
  C(const C&) { std::cout<<"copy constructor"<<std::endl; } // the copy constructor has a visible side effect
};                     // it modifies an object with static storage duration

int main() {
  C c1(42); // direct-initialization, calls C::C(42)
  C c2 = C(42); // copy-initialization elision as direct-initialization, so as to call C::C(42)

  return 0;
}
```

上例，在g++与Visual C++默认都是复制省略。

throw语句抛出一个异常对象，catch语句匹配一个异常对象，默认是要执行复制构造函数的。如下例：

``` cpp
#include <iostream>

struct C {
  C() {}
  C(const C&) { std::cout << "Hello World!\n"; }
};

void f() {
  C c;
  throw c; // copying the named object c into the exception object.
}          // 由于异常对象保存在线程信息块TIB中，这里的复制构造不可省略. 这使得调用栈上压栈保存的函数都有机会处理这个异常对象

int main() {
  try {
    f();
  }
  catch(C c) {  // copying the exception object into the temporary in the exception declaration.
  }             // 由于这里是传值的catch批配，因此复制初始化不可省略. 通常用于catch块可能会修改异常对象的内容，但又需要把原来的异常对象重新抛出(re-throw)
}
```

上例默认应该打印输出两次"Hello World\!"

[GCC](../Page/GCC.md "wikilink")的编译选项`-fno-elide-constructors`关闭复制省略。

## 参考文献

[Category:C++](https://zh.wikipedia.org/wiki/Category:C++ "wikilink")

1.
2.  {{ cite book | first1 = Herb | last1 = Sutter | authorlink1 = Herb
    Sutter | year = 2001 | title = More Exceptional C++ | publisher =
    Addison-Wesley }}
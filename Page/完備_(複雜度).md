在[計算複雜性理論內](../Page/計算複雜性理論.md "wikilink")，一個[計算問題](https://zh.wikipedia.org/wiki/計算問題 "wikilink")(computational
problem)對一個[複雜度類是](https://zh.wikipedia.org/wiki/複雜度類 "wikilink")**完備**或者**完全**的，用比較不正式的解釋，是說這問題在此複雜度類裡面是一個"最難的"或者"最代表性的"題目。如果一個問題的解法可以允許你快速解決這個複雜度類的其他問題的話，我們說這問題對此類別是**難**(hard)的題目。

更正式的說法是，如果在一個給定的[歸約方式之下](../Page/歸約.md "wikilink")，所有複雜度類
*C*裡面的問題都存在某種歸約方式，可以歸約到某個問題*p*，我們說這個問題*p*
是*C*的**難**問題。如果一個問題是此類別的，且本身是這個類別裡面的一員，則這個問題就是對這個複雜度類完備的(在給定的歸約條件之下)。

一個問題如果對複雜度類C是完備的話，我們會說這個問題是**C-完備**或者**C完全**(C-complete)的問題，至於這一些對C是完備問題的集合我們也稱為**C-完備**。
第一個且是最有名的是[NP完全](../Page/NP完全.md "wikilink")：一個包含許多實際但是不容易的題目。相同的，我們習慣用**C難**(C-hard)這種用詞稱呼包含所有**C難**(C-hard)的問題，例如說，[NP難](https://zh.wikipedia.org/wiki/NP難 "wikilink")。

正常來說我們都假設歸約過程在計算複雜度上面不會比起問題本身要難。因此之故，如果我們對一個*C-完備*問題有"計算上簡單"的解法的話，則所有在"C"這類別裡面的問題都有"簡單"的解法。

一般說來，有遞歸可枚舉(recursive
enumeration)的複雜度類都會有已知的完備問題，而並非如此的類別則沒有已知的完備問題。舉例來說，[NP](../Page/NP_\(複雜度\).md "wikilink")，[反NP](../Page/反NP.md "wikilink")，[PLS](https://zh.wikipedia.org/wiki/PLS_\(複雜度\) "wikilink")，[PPA](https://zh.wikipedia.org/wiki/PPA_\(複雜度\) "wikilink")
都有已知的完備問題，而[RP](../Page/RP_\(複雜度\).md "wikilink")，[ZPP](../Page/ZPP_\(複雜度\).md "wikilink")，[BPP和](../Page/BPP_\(複雜度\).md "wikilink")[TFNP則沒有已知的完備問題](https://zh.wikipedia.org/wiki/TFNP "wikilink")(雖然這不代表未來不會發現完備問題)。

有一些複雜度類是沒有完備問題存在的。舉例來說，Sipser證明了存在一個語言**M**令**BPP**<sup>**M**</sup>
(**BPP**加上一個**M**的[諭示](https://zh.wikipedia.org/wiki/諭示機 "wikilink"))
是沒有完備問題的。\[1\]

## 參考資料

[Category:計算複雜性理論](https://zh.wikipedia.org/wiki/Category:計算複雜性理論 "wikilink")

1.  M. Sipser. On relativization and the existence of complete sets,
    Proceedings of ICALP'82, Springer-Verlag Lecture Notes in Computer
    Science volume 140, pp. 523-531, 1982.
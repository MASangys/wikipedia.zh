在[计算机学](https://zh.wikipedia.org/wiki/计算机学 "wikilink")，**尾调用**是指一个函数里的最后一个动作是返回一个[函数的调用结果的情形](../Page/子程序.md "wikilink")，即最后一步新调用的返回值直接被当前函数的返回结果。\[1\]此时，该尾部调用位置被称为**尾位置**。尾调用中有一种重要而特殊的情形叫做**尾递归**。经过适当处理，尾递归形式的函数的运行效率可以被极大地优化。\[2\]尾调用原则上都可以通过简化函数[调用栈的结构而获得性能优化](https://zh.wikipedia.org/wiki/调用栈 "wikilink")（称为“尾调用消除”），但是优化尾调用是否方便可行取决于运行环境对此类优化的支持程度如何。

## 概述

在[计算机科学](../Page/计算机科学.md "wikilink")，**尾调用**是指一个函数里的最后一个动作是一个[函数调用的情形](../Page/子程序.md "wikilink")：即这个调用的返回值直接被当前函数返回的情形。这种情形下称该调用位置为**尾位置**。若这个函数在尾位置调用本身（或是一个尾调用本身的其他函数等等），则称这种情况为**尾递归**，是[递归](../Page/递归.md "wikilink")的一种特殊情形。尾调用不一定是递归调用，但是尾递归特别有用，也比较容易实现。

在程序运行时，计算机会为应用程序分配一定的内存空间；应用程序则会自行分配所获得的内存空间，其中一部分被用于记录程序中正在调用的各个函数的运行情况，这就是函数的[调用栈](https://zh.wikipedia.org/wiki/调用栈 "wikilink")。常规的函数调用总是会在调用栈最上层添加一个新的堆栈帧（stack
frame，也翻译为“栈帧”或简称为“帧”），这个过程被称作“入栈”或“压栈”（意即把新的帧压在栈顶）。当函数的调用层数非常多时，调用栈会消耗不少内存，甚至会撑爆内存空间（[栈溢出](https://zh.wikipedia.org/wiki/栈溢出 "wikilink")）\[3\]，造成程序严重卡顿或意外崩溃。尾调用的调用栈则特别易于优化，从而可减少内存空间的使用，也能提高运行速度。\[4\]其中，对尾递归情形的优化效果最为明显，尤其是递归算法非常复杂的情形。\[5\]

一般来说，尾调用消除是可选的，可以用，也可以不用。然而，在[函数编程语言中](https://zh.wikipedia.org/wiki/函数编程语言 "wikilink")，语言标准通常会要求编译器或运行平台实现尾调用消除。这让程序员可以用递归取代[循环而不丧失性能](https://zh.wikipedia.org/wiki/程序循環 "wikilink")。

## 定义与说明

### 定义

尾调用 （tail call）
指的是一个函数的最后一条语句也是一个返回调用函数的语句。在函数体末尾被返回的可以是对另一个函数的调用，也可以是对自身调用（即自身递归调用）。\[6\]

### 特征与简单示例

尾调用可能位于一个函数语法上最后的位置：

``` javascript
function foo(data) {
    a(data);
    return b(data);
}
```

在这里，`a(data)`、`b(data)` 都是函数调用，但是 `b(data)`
是函式返回前的最后运行的东西，所以也是所谓的尾位置。然后，并非所有的尾调用都必须在一个函数语法上最后的位置。考虑：

``` javascript
function bar(data) {
    if ( a(data) ) {
        return b(data);
    }
    return c(data);
}
```

在这里，`b`、`c` 的调用都在尾位置。这是因为尽管 `b(data)` 不在 `bar` 语法上最后的位置，它是 `if`
叙述其中一个分支最后的位置

1.
2.
3.
4.
5.
6.
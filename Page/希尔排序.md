[Shell_sorting_algorithm_color_bars.svg](https://zh.wikipedia.org/wiki/File:Shell_sorting_algorithm_color_bars.svg "fig:Shell_sorting_algorithm_color_bars.svg")
**希尔排序**，也称**递减增量排序算法**，是[插入排序的一种更高效的改进版本](../Page/插入排序.md "wikilink")。希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

  - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到[线性排序的效率](../Page/线性排序.md "wikilink")
  - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

## 历史

希尔排序按其设计者[希尔](../Page/唐纳德.希尔.md "wikilink")（Donald
Shell）的名字命名，该算法由1959年公布。一些老版本教科书和参考手册把该算法命名为Shell-Metzner，即包含[Marlene
Metzner
Norton的名字](../Page/Marlene_Metzner_Norton.md "wikilink")，但是根据Metzner本人的说法，“我没有为这种算法做任何事，我的名字不应该出现在算法的名字中。”

## 算法实现

原始的算法实现在最坏的情况下需要进行[O](../Page/大O符号.md "wikilink")(*n*<sup>2</sup>)的比较和交换。V.
Pratt的书\[1\]对算法进行了少量修改，可以使得性能提升至O(*n* log<sup>2</sup>
*n*)。这比最好的[比较算法的O](../Page/比较算法.md "wikilink")(*n*
log *n*)要差一些。

希尔排序通过将比较的全部元素分为几个区域来提升[插入排序的性能](../Page/插入排序.md "wikilink")。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的[插入排序](../Page/插入排序.md "wikilink")，但是到了这步，需排序的数据几乎是已排好的了（此时[插入排序较快](../Page/插入排序.md "wikilink")）。

假设有一个很小的数据在一个已按升序排好序的[数组的末端](../Page/数组.md "wikilink")。如果用复杂度为O(*n*<sup>2</sup>)的排序（[冒泡排序或](../Page/冒泡排序.md "wikilink")[插入排序](../Page/插入排序.md "wikilink")），可能会进行*n*次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。

一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用[插入排序](../Page/插入排序.md "wikilink")）。重复这过程，不过每次用更长的-{zh-hans:列;
zh-hant:行;}-来进行。最后整个表就只有一-{zh-hans:列;
zh-hant:行;}-了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用`i
+= step_size`而不是`i++`）。

例如，假设有这样一组数\[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10
\]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5-{zh-hans:列;
zh-hant:行;}-的表中来更好地描述算法，这样他们就应该看起来是这样：

    13 14 94 33 82
    25 59 94 65 23
    45 27 73 25 39
    10

然后我们对每-{zh-hans:列; zh-hant:行;}-进行排序：

    10 14 73 25 23
    13 27 94 33 39
    25 59 94 65 82
    45

將上述四-{zh-hans:行; zh-hant:列;}-数字，依序接在一起时我们得到：\[ 10 14 73 25 23 13 27 94
33 39 25 59 94 65 82 45 \].这时10已经移至正确位置了，然后再以3为步长进行排序：

    10 14 73
    25 23 13
    27 94 33
    39 25 59
    94 65 82
    45

排序之后变为：

    10 14 13
    25 23 33
    27 25 59
    39 65 73
    45 94 82
    94

最后以1步长进行排序（此时就是简单的插入排序了）。

## 步长序列

步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。

Donald
Shell最初建议步长选择为\(\frac{n}{2}\)并且对步长取半直到步长达到1。虽然这样取可以比\(\mathcal{O}(n^2)\)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能**希尔排序**最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在[迭代过程中会打乱以前的顺序](../Page/迭代.md "wikilink")，那就不会以如此短的时间完成排序了。

| 步长序列               | 最坏情况下复杂度                         |
| ------------------ | -------------------------------- |
| nowrap|\({n/2^i}\) | \(\mathcal{O}\)\((n^2)\)         |
| nowrap|\(2^k - 1\) | \(\mathcal{O}\)\((n^{3/2})\)     |
| nowrap|\(2^i 3^j\) | \(\mathcal{O}\)\(( n\log^2 n )\) |

已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41,
109,...)，该序列的项来自\(9 \times 4^i - 9 \times 2^i + 1\)和\(2^{i+2} \times (2^{i+2} - 3) + 1\)这两个算式[1](http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Weiss/L12-ShellSort.htm#increments)。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比[插入排序要快](../Page/插入排序.md "wikilink")，甚至在小数组中比[快速排序和](../Page/快速排序.md "wikilink")[堆排序还快](../Page/堆排序.md "wikilink")，但是在涉及大量数据时希尔排序还是比快速排序慢。

另一个在大数组中表现优异的步长序列是（[斐波那契数列除去](../Page/斐波那契数列.md "wikilink")0和1将剩余的数以[黄金分割比的两倍的](../Page/黄金分割比.md "wikilink")[幂进行运算得到的数列](../Page/幂.md "wikilink")）：(1,
9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244,
217378076, 1031612713,…)\[2\]

## 伪代码

    input: an array a of length n with array elements numbered 0 to n − 1
    inc ← round(n/2)
    while inc > 0 do:    
        for i = inc .. n − 1 do:        
            temp ← a[i]        
            j ← i        
            while j ≥ inc and a[j − inc] > temp do:            
                a[j] ← a[j − inc]            
                j ← j − inc        
            a[j] ← temp    
        inc ← round(inc / 2)

    输入：1个长度为n的矩阵a，矩阵的编号从0到n - 1
    整数inc从n / 2到1，每次循环inc变为inc / 2
        i从inc到n - 1，每次循环i变为i + 1
            将a[ i ]的值赋给temp
            j从i 到inc，每次循环j变为j - inc
                如果a[ j − inc ]大于temp，则将a[ j - inc ]的值赋给a[ j ]
                否则跳出j循环
            j循环结束
            将temp的值赋给a[ j ]
        i循环结束
    inc循环结束

## 程式代码

### C语言

``` c
void shell_sort(int arr[], int len) {
    int gap, i, j;
    int temp;
    for (gap = len >> 1; gap > 0; gap >>= 1)
        for (i = gap; i < len; i++) {
            temp = arr[i];
            for (j = i - gap; j >= 0 && arr[j] > temp; j -= gap)
                arr[j + gap] = arr[j];
            arr[j + gap] = temp;
        }
}
```

### C++

``` cpp

template<typename T>
void shell_sort(T array[], int length) {
    int h = 1;
    while (h < length / 3) {
        h = 3 * h + 1;
    }
    while (h >= 1) {
        for (int i = h; i < length; i++) {
            for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
                std::swap(array[j], array[j - h]);
            }
        }
        h = h / 3;
    }
}
```

### Java

``` java
public static void shellSort(int[] array) {
    int number = array.length / 2;
    int i;
    int j;
    int temp;
    while (number >= 1) {
        for (i = number; i < array.length; i++) {
            temp = array[i];
            j = i - number;
            while (j >= 0 && array[j] < temp) { //需要注意的是，这里array[j] < temp将会使数组从大到小排序。
                array[j + number] = array[j];
                j = j - number;
            }
            array[j + number] = temp;
        }
        number = number / 2;
    }
}
```

### JavaScript

``` javascript
Array.prototype.shell_sort = function() {
    var gap, i, j;
    var temp;
    for (gap = this.length >> 1; gap > 0; gap >>= 1)
        for (i = gap; i < this.length; i++) {
            temp = this[i];
            for (j = i - gap; j >= 0 && this[j] > temp; j -= gap)
                this[j + gap] = this[j];
            this[j + gap] = temp;
        }
return this
};
```

### Python

``` python
def shell_sort(list):
    n = len(list)
    # 初始步长
    gap = n // 2
    while gap > 0:
        for i in range(gap, n):
            # 每个步长进行插入排序
            temp = list[i]
            j = i
            # 插入排序
            while j >= gap and list[j - gap] > temp:
                list[j] = list[j - gap]
                j -= gap
            list[j] = temp
        # 得到新的步长
        gap = gap // 2
    return list
```

### PHP

``` php
function shell_sort(&$arr) {//php的阵列视为基本型別，所以必须用传参考才能修改原阵列
    for ($gap = count($arr)>>1; $gap > 0; $gap>>=1)
        for ($i = $gap; $i < count($arr); $i++) {
            $temp = $arr[$i];
            for ($j = $i - $gap; $j >= 0 && $arr[$j] > $temp; $j -= $gap)
                $arr[$j + $gap] = $arr[$j];
            $arr[$j + $gap] = $temp;
        }
}
```

### Go

``` go
package main

import (
    "fmt"
)

func ShellSort(array []int) {
    n := len(array)
    if n < 2 {
        return
    }
    key := n / 2
    for key > 0 {
        for i := key; i < n; i++ {
            j := i
            for j >= key && array[j] < array[j-key] {
                array[j], array[j-key] = array[j-key], array[j]
                j = j - key
            }
        }
        key = key / 2
    }
}

func main() {
    array := []int{
        55, 94, 87, 1, 4, 32, 11, 77, 39, 42, 64, 53, 70, 12, 9,
    }
    fmt.Println(array)
    ShellSort(array)
    fmt.Println(array)

}
```

## 引用

<references/>

[Category:排序算法](https://zh.wikipedia.org/wiki/Category:排序算法 "wikilink")

1.   (This was originally presented as the author's Ph.D. thesis,
    Stanford University, 1971)
2.   The fibonacci to the power of two times the golden ratio gap
    sequence
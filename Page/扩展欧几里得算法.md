**扩展欧几里得算法**（）是[欧几里得算法](https://zh.wikipedia.org/wiki/欧几里得算法 "wikilink")（又叫辗转相除法）的扩展。已知整数a、b，扩展欧几里得算法可以在求得a、b的[最大公约数的同时](https://zh.wikipedia.org/wiki/最大公约数 "wikilink")，能找到整数x、y（其中一个很可能是负数），使它们满足[貝祖等式](../Page/貝祖等式.md "wikilink")

  -
    \(ax + by = \gcd(a, b).\)

如果a是负数，可以把问题转化成

\[\left | a \right |(-x) + by = \gcd(|a|, b)\]（\(\left | a \right |\)为a的[绝对值](../Page/绝对值.md "wikilink")），然后令\(x'=(-x)\)。

通常談到[最大公因數](../Page/最大公因數.md "wikilink")時，我們都會提到一個非常基本的事實：**給予二个整數a、b，必存在整數x、y使得ax
+ by = gcd(a,b)**\[1\]。

有两个数a,b，对它们进行辗转相除法，可得它们的最大公约数——这是众所周知的。然后，收集辗转相除法中产生的式子，倒回去，可以得到ax+by=gcd(a,b)的整数解。

扩展欧几里得算法可以用来计算[模反元素](../Page/模反元素.md "wikilink")(也叫模逆元)，而模反元素在[RSA加密算法中有举足轻重的地位](https://zh.wikipedia.org/wiki/RSA加密算法 "wikilink")。

## 例子

用类似[辗转相除法](https://zh.wikipedia.org/wiki/辗转相除法 "wikilink")，求二元[一次不定方程](https://zh.wikipedia.org/wiki/一次不定方程 "wikilink")\(47x+30y=1\)的整数解。

  - \(47 = 30 \times 1 + 17\)
  - \(30 = 17 \times 1 + 13\)
  - \(17 = 13 \times 1 + 4\)
  - \(13 = 4 \times 3 + 1\)

然后把它们改写成“余数等于”的形式

  - \(17 = 47 \times 1 + 30 \times (-1)\) //式1
  - \(13 = 30 \times 1 + 17 \times (-1)\) //式2
  - \(4 = 17 \times 1 + 13 \times (-1)\) //式3
  - \(1 = 13 \times 1 + 4 \times (-3)\)

然后把它们“倒回去”

  - \(1 = 13 \times 1 + 4 \times (-3)\)
  - \(1 = 13 \times 1 + [17 \times 1 + 13 \times (-1)] * (-3)\) //应用式3
  - \(1 = 17 \times (-3) + 13 \times 4\)
  - \(1 = 17 \times (-3) + [30 \times 1 + 17 \times (-1)] \times 4\)//应用式2
  - \(1 = 30 \times 4 + 17 \times (-7)\)
  - \(1 = 30 \times 4 + [47 \times 1 + 30 \times (-1)] \times (-7)\)
    //应用式1
  - \(1 = 47 \times (-7) + 30 \times 11\)

得解 \(x=-7, y=11\)。

这个过程可以用[矩阵](../Page/矩阵.md "wikilink")表示（其中q表示商，r表示余数）

\(\begin{pmatrix} a \\ b \end{pmatrix} =
\prod_{i=0}^{N} \begin{pmatrix} q_{i} & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} r_{N-1} \\ 0 \end{pmatrix}\)

\(\begin{pmatrix} 47 \\ 30 \end{pmatrix} =
\begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}\begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}
\begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}\begin{pmatrix} 3 & 1 \\ 1 & 0 \end{pmatrix}
\begin{pmatrix} 4 & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} 1 \\ 0 \end{pmatrix} =
\begin{pmatrix} 47 & 11 \\ 30 & 7 \end{pmatrix} \begin{pmatrix} 1 \\ 0 \end{pmatrix}\)

\(\begin{pmatrix}1 \\ 0 \end{pmatrix}=\begin{pmatrix} -7 & 11 \\ 30 & -47 \end{pmatrix} \begin{pmatrix} 47 \\ 30 \end{pmatrix}\)

或者用[初等变换](https://zh.wikipedia.org/wiki/初等变换 "wikilink")

\(\begin{pmatrix}47 & 30\\1 & 0\\0 & 1\end{pmatrix}
\rightarrow
\begin{pmatrix}17 & 30\\1 & 0\\-1 & 1\end{pmatrix}
\rightarrow
\begin{pmatrix}17 & 13\\1 & -1\\-1 & 2\end{pmatrix}
\rightarrow
\begin{pmatrix}4 & 13\\2 & -1\\-3 & 2\end{pmatrix}
\rightarrow
\begin{pmatrix}4 & 1\\2 & -7\\-3 & 11\end{pmatrix}
\Rightarrow
1=47(-7)+30(11)\) \[2\]

## 实现

以下是扩展欧几里德算法的[Python](../Page/Python.md "wikilink")实现：

``` python
def ext_euclid(a, b):
     if b == 0:
         return 1, 0, a
     else:
         x, y, q = ext_euclid(b, a % b) # q = gcd(a, b) = gcd(b, a%b)
         x, y = y, (x - (a // b) * y)
         return x, y, q
```

扩展欧几里得算法[C语言实现](https://zh.wikipedia.org/wiki/C语言 "wikilink")：

``` c
 int gcdEx(int a, int b, int *x, int *y)
 {
     if(b==0)
     {
         *x = 1,*y = 0;
         return a;
     }
     else
     {
         int r = gcdEx(b, a%b, x, y); /* r = GCD(a, b) = GCD(b, a%b) */
         int t = *x;
         *x = *y;
         *y = t - a/b * *y;
         return r;
     }
 }
```

## 参考资料

## 參考文獻

  - [Thomas H.
    Cormen](https://zh.wikipedia.org/wiki/Thomas_H._Cormen "wikilink"),
    [Charles E.
    Leiserson](https://zh.wikipedia.org/wiki/Charles_E._Leiserson "wikilink"),
    [Ronald L.
    Rivest](https://zh.wikipedia.org/wiki/Ronald_L._Rivest "wikilink"),
    and [Clifford
    Stein](https://zh.wikipedia.org/wiki/Clifford_Stein "wikilink").
    *[算法导论](../Page/算法导论.md "wikilink")*, Second Edition. MIT Press
    and McGraw-Hill, 2001. ISBN 0-262-03293-7. Pages 859–861 of section
    31.2: Greatest common divisor.
  - [Christof
    Paar](https://zh.wikipedia.org/wiki/Christof_Paar "wikilink"),[Jan
    Pelzl著](https://zh.wikipedia.org/wiki/Jan_Pelzl "wikilink") 马小婷 译.
    *[深入浅出密码学](https://zh.wikipedia.org/wiki/深入浅出密码学 "wikilink")*,
    清华大学出版社, ISBN 9787302296096. Pages 151-155 6.3.2
    扩展的欧几里得算法

## 外部連結

  - [Source for the form of the algorithm used to determine the
    multiplicative inverse in
    GF(2^8)](http://mathforum.org/library/drmath/view/51675.html)

[Category:数论算法](https://zh.wikipedia.org/wiki/Category:数论算法 "wikilink")
[Category:带有伪代码示例的条目](https://zh.wikipedia.org/wiki/Category:带有伪代码示例的条目 "wikilink")
[Category:欧几里得](https://zh.wikipedia.org/wiki/Category:欧几里得 "wikilink")

1.
2.
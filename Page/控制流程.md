**控制流程**（也稱為**流程控制**）是[電腦運算領域的用語](https://zh.wikipedia.org/wiki/電腦運算 "wikilink")，意指在[程式執行時](https://zh.wikipedia.org/wiki/程式 "wikilink")，個別的指令（或是[陳述](https://zh.wikipedia.org/wiki/陳述_\(程式\) "wikilink")、[子程序](../Page/子程序.md "wikilink")）執行或[求值的順序](https://zh.wikipedia.org/wiki/求值 "wikilink")
。不論是在[宣告式程式語言或是](../Page/宣告式編程.md "wikilink")[函數程式語言中](https://zh.wikipedia.org/wiki/函數程式語言 "wikilink")，都有類似的概念。

在宣告式的[程式語言中](https://zh.wikipedia.org/wiki/程式語言 "wikilink")，**流程控制指令**是指會改變程式執行順序的指令，可能是執行不同位置的指令，或是在二段（或多段）程式中選擇一個執行。

不同的程式語言所提供的流程控制指令也會隨之不同，但一般可以分為以下四種：

  - 繼續執行位在不同位置的一段指令（無條件分支指令）。
  - 若特定條件成立時，執行一段指令，例如C語言的switch指令，是一種有條件分支指令。
  - 執行一段指令若干次，直到特定條件成立為止，例如C語言的for指令，仍然可視為一種有條件分支指令。
  - 執行位在不同位置的一段指令，但完成後會繼續執行原來要執行的指令，包括[子程序](../Page/子程序.md "wikilink")、[协程](../Page/协程.md "wikilink")（coroutine）及[计算续体](https://zh.wikipedia.org/wiki/计算续体 "wikilink")（continuation）。
  - 停止程式，不執行任何指令（無條件的終止）。

[中斷以及](../Page/中斷.md "wikilink")[Unix系統中的](https://zh.wikipedia.org/wiki/Unix "wikilink")[信号等較低階的機制也可以造成類似子程序的效果](https://zh.wikipedia.org/wiki/信号_\(计算机科学\) "wikilink")，不過通常這類機制會用來回應外部的事件或是輸入。[程序自修改因為其對程式碼的影響](https://zh.wikipedia.org/wiki/程序自修改 "wikilink")，也會影響控制流程，但多半不會有明顯的流程控制指令。

在[机器语言或](../Page/机器语言.md "wikilink")[汇编语言中](../Page/汇编语言.md "wikilink")，流程控制是藉由修改[程式計數器數值來達到](../Page/程式計數器.md "wikilink")。一些[中央處理器只支援條件](https://zh.wikipedia.org/wiki/中央處理器 "wikilink")[分支](https://zh.wikipedia.org/wiki/分支_\(計算機科學\) "wikilink")（branch）或是無條件分支（有時會稱為jump）。

## 基本概念

### 標記

[標記是一個標示在](../Page/標記_\(程式語言\).md "wikilink")[源代码固定位置中的名稱或數字](../Page/源代码.md "wikilink")，其他位置的流程控制指令可以參考標記的位置，執行標記位置所對應的程式。標記本身不影響程式的進行，除了標示位置外，對程式執行沒有其他的作用。

有一些程式語言（像[Fortran及](../Page/Fortran.md "wikilink")[BASIC等](../Page/BASIC.md "wikilink")）利用[行號作為標記](../Page/行號_\(程式語言\).md "wikilink")。行號是標示在每一行程式最前面的[自然數](https://zh.wikipedia.org/wiki/自然數 "wikilink")，不一定要是連續的數字，在不受流程控制指令影響的情形下，程式會從最小的行號依序執行，而流程控制指令需指定對應的行號。以下是一個BASIC的例子:

``` qbasic
10 LET X = 3
20 PRINT "*"
30 LET X = X - 1
40 IF X > 0 THEN GOTO 20
50 END
```

在像是[C及](https://zh.wikipedia.org/wiki/C语言 "wikilink")[Ada等程式語言中](../Page/Ada.md "wikilink")，標記是一個[標識符](../Page/標識符.md "wikilink")，一般出現在一行的最前面，後面會加一個[冒號作為識別](https://zh.wikipedia.org/wiki/冒號 "wikilink")，以下是C語言的例子：

``` c
Success: printf ("The operation was successful.\n");
```

[Algol
60語言同時支持整數](https://zh.wikipedia.org/wiki/Algol_60 "wikilink")（類似行號）及標識符的標記（二者後面都要加上冒號），不過其他Algol語言幾乎都不支援整數的標記。

### Goto

goto
指令（來自英文[go和](https://zh.wikipedia.org/wiki/wiktionary:go "wikilink")[to的組合](https://zh.wikipedia.org/wiki/wiktionary:to "wikilink")）是無條件流程控制指令中最基本的型式。一般在程式中會用以下的方式出現（指令大小寫可能會依程式語言而不同）

`   `**`goto`**` `*`label`*

goto 指令的效果是調整程式的控制流程，後續就執行標記位置的程式。

goto
指令是許多的计算机科学家[視為有害的指令](https://zh.wikipedia.org/wiki/視為有害 "wikilink")，像荷兰计算机科学家[艾茲格·迪科斯徹](https://zh.wikipedia.org/wiki/艾茲格·迪科斯徹 "wikilink")（Edsger
Wybe
Dijkstra）就提出了[goto有害論](https://zh.wikipedia.org/wiki/goto有害論 "wikilink")\[1\]。

### 子程序

[子程序](../Page/子程序.md "wikilink")（subroutine）可以用許多不同的術語來表示，例如程序、函數（尤其是有傳回值時）或是[方法](../Page/方法_\(電腦科學\).md "wikilink")（特別是子程序屬於一個[类的一部份](../Page/类_\(计算机科学\).md "wikilink")）等。

子程序是是完成一项特定工作的代码序列，其他程式可以將流程移轉到子程序中，執行特定工作後再回到原來的程式，若程式中有許多部份都需要執行一特定工作，利用子程序的方式可以利用一段程式達到上述的功能，可以減少程式碼的長度。

如今子程序也常用來使得程式更加的結構化，例如可以將一些特殊的演算法或特殊的資料存取方式放在子程序中，和其他代碼隔離。子程序也是程式[模組的一種](https://zh.wikipedia.org/wiki/模組_\(程式設計\) "wikilink")，若許多程式設計師共同開發一個程式，子程序也有助於其工作的分割及分工。

## 最簡結構化控制流程

1966年5月Corrado Böhm及Giuseppe Jacopini在《Communications of the
ACM》期刊發表論文\[2\]，說明任何一個有goto指令的程式，可以改為完全不使用goto指令的程式，goto指令可以用選擇指令（IF
THEN ELSE）及迴圈（WHILE 特定條件 DO
特定程序）取代，可能會再多一些重覆的程式碼及額外的布林變數。後來的研究者已證明選擇指令也可以用迴圈取代，不過需要更多的布林變數。Böhm及Jacopini的論文說明程式可以完全不使用goto，但是在實務上大家不一定會想要這麼進行。

其他的研究說明若控制結構只有一個進入點（entry）及一個結束點（exit），這樣的程式會比其他型式的程式容易理解。因此這樣的程式可以像一個指令一樣放在程式的任何部份，不必擔心會破壞其結構，換句話說，這種程式是「可组成的」（composable）。

## 常用的控制結構

若一程式語言支援控制結構，控制結構開始時多半都會有特定的關鍵字，以標明是使用哪一種控制結構。但只有部份程式語言在控制結構結束時會有特定的關鍵字表示結束，因此可以依控制結構結束時是否有特定關鍵字來將程式語言分為二類。

  - 沒有特定關鍵字的語言：[Algol
    60](https://zh.wikipedia.org/wiki/Algol_60 "wikilink")、[C](https://zh.wikipedia.org/wiki/C语言 "wikilink")、[C++](../Page/C++.md "wikilink")、[Haskell](../Page/Haskell.md "wikilink")、[Java](../Page/Java.md "wikilink")、[Pascal](../Page/Pascal_\(程式語言\).md "wikilink")、[Perl](../Page/Perl.md "wikilink")、[PHP](../Page/PHP.md "wikilink")、[PL/I](https://zh.wikipedia.org/wiki/PL/I "wikilink")、[Python](../Page/Python.md "wikilink")、[Windows
    PowerShell](../Page/Windows_PowerShell.md "wikilink")。這類語言需要有關鍵字可以將group程式指令together：
      - Algol 60及 Pascal：`begin` ... `end`
      - C, C++, Java, Perl, PHP, and PowerShell：利用大括號`{` ... `}`
      - PL/1：`DO` ... `END`
      - Python：利用的層次，詳細內容請參考[Off-side規則](https://zh.wikipedia.org/wiki/Off-side規則 "wikilink")
      - Haskell：可以利用縮排或大括號，兩者可以混用
  - 有特定關鍵字的語言：[Ada](../Page/Ada.md "wikilink")、[Algol
    68](https://zh.wikipedia.org/wiki/Algol_68 "wikilink")、
    [Modula-2](https://zh.wikipedia.org/wiki/Modula-2 "wikilink")、[Fortran
    77](../Page/Fortran.md "wikilink")、[Visual
    Basic](../Page/Visual_Basic.md "wikilink")，使用的特定關鍵字依程式語言而不同：
      - Ada: 其關鍵字為 `end` + *space* + 啟始控制結構的關鍵字，如`if` ... `end if`,
        `loop` ... `end loop`
      - Algol 68, Mythryl：將啟始關鍵字反寫，如`if` ... `fi`, `case` ... `esac`
      - Fortran 77: 其關鍵字為 `end` + initial keyword，如`IF` ... `ENDIF`,
        `DO` ... `ENDDO`
      - Modula-2: 不論何種控制結構，其關鍵字均為`END`
      - Visual Basic: 每種控制結構均有各自的結尾關鍵字，如`If` ... `End If`; `For` ...
        `Next`; `Do` ... `Loop`
  - 没有任何特征的语言:logo

## 條件判斷

[條件判斷是依指定變數或運算式的結果](https://zh.wikipedia.org/wiki/條件判斷 "wikilink")，決定後續執行的程序，最常用的是if-else指令，可以根據指定條件是否成立，決定後續的程序。也可以組合多個if-else指令，進行較複雜的條件判斷。
許多程式語言也提供多選一的條件判斷，例如C語言的switch-case指令。\[3\]

## 迴圈

迴圈是指一段在程式中只出現一次，但可能會連續執行多次的程式碼。常見的迴圈可以分為二種，指定執行次數的迴圈（如C語言的for迴圈）以及指定繼續執行條件（或停止條件）的迴圈（如C語言的while迴圈）。

在一些[函數程式語言](https://zh.wikipedia.org/wiki/函數程式語言 "wikilink")（例如[Haskell和](../Page/Haskell.md "wikilink")[Scheme](../Page/Scheme.md "wikilink")）中會使用[递归或](../Page/递归_\(计算机科学\).md "wikilink")[不动点组合子來達到迴圈的效果](../Page/不动点组合子.md "wikilink")，其中[尾部递归是一種特別的递归](https://zh.wikipedia.org/wiki/尾部递归 "wikilink")，很容易轉換為迭代。

## 結構化的非區部控制流程

有些程式語言 會提供非區部的控制流程（non-local control
flow），會允許流程跳出目前的程式碼，進入一段事先指定的程式碼。常用的結構化非區部控制流程可分為[條件處理](../Page/异常处理.md "wikilink")、[异常处理及](../Page/异常处理.md "wikilink")[延續性](https://zh.wikipedia.org/wiki/延續性 "wikilink")（Continuation）三種。

### 條件處理

[PL/I程式語言中有](https://zh.wikipedia.org/wiki/PL/I "wikilink")22種標準的條件（如
ZERODIVIDE SUBSCRIPTRANGE
ENDFILE），可以在程式中設定，當特定條件成立時需進行的指令，程式設計者也可以定義自己的條件，並在程式中使用。

條件成立時，只能設定一個需進行的指令（類似未結構化的if指令），大部份的應用中，都會指定執行goto指令，跳到其他程式碼執行對應的流程。

不過因為有些條件處理的實現會增加許多程式碼及執行時間（特別SUBSCRIPTRANGE），所以許多程式設計者會儘量不使用條件處理。

條件處理的語法如下:

` `**`ON`**` `*`條件`*` `**`GOTO`**` `*`label`*

### 異常處理

有些程式語言可提供不需要使用`GOTO`的結構化異常處理程式：

``` cpp
try {
    xxx1                                  // Somewhere in here
    xxx2                                  //     use: '''throw''' someValue;
    xxx3
} catch (someClass& someId) {             // catch value of someClass
    actionForSomeClass
} catch (someType& anotherId) {           // catch value of someType
    actionForSomeType
} catch (...) {                           // catch anything not already caught
    actionForAnythingElse
}
```

在`try{...}`的區塊中，若有異常情形時，程式就會離開try的區塊，由後續的一個或多個`catch`子句判斷需執行何種異常處理。在D、Java、C\#及Python程式語言中，`try{...}`區塊中還可以加入一個`finally`子句，不管程式流程是否離開`try{...}`區塊，`finally`子句中的程式都一定會執行，常用在當程式結束處理時，需要放棄一些外部資源（檔案或資料庫連結）的情形下：

``` csharp
FileStream stm = null;                    // C# example
try {
    stm = new FileStream ("logfile.txt", FileMode.Create);
    return ProcessStuff(stm);             // may throw an exception
} finally {
    if (stm != null)
        stm. Close();
}
```

由於上述情形相當普遍，C\#提供一種特殊的語法進行相同的處理：

``` csharp
using (FileStream stm = new FileStream ("logfile.txt", FileMode.Create)) {
    return ProcessStuff(stm);             // may throw an exception
}
```

只要離開 `using`區塊，編譯器會自動釋放`stm`物件，Python的 `with`指令及也有類似的功能 。

這些語言都有定義標準的異常情形及其出現的條件，程式設計者也可以丟出自己產生的異常（其實C++及Python的throw和catch支援絕大多數形態的物件）。

若某一個`throw`指令找不到對應的`catch`，控制流程會離開目前的副程式或控制結構，設法找到對應的`catch`，若到主程式的結尾還是找不到對應的`catch`，程式會強制結束，並顯示適當的錯誤訊息。

[AppleScript](../Page/AppleScript.md "wikilink")[脚本语言可以將](../Page/脚本语言.md "wikilink")"`try`"區塊分為幾個部份，提供不同的訊息及異常：

``` applescript
try
    set myNumber to myNumber / 0

on error e  number n  from f  to t  partial result pr

    if ( e = "Can't divide by zero" ) then display dialog "You idiot!"

end try
```

### 延續性

延續性（Continuation）可以將目前子程序的執行狀態（包括目前的堆疊，區部變數及執行到的位置）儲存成一個物件，後續在其他子程序中可以利用此物件回到此子程序現在的執行狀態。

延續性一詞也可以指第一類延續性（first-class
continuation），是指程式語言可以在任意時間點儲存目前的執行狀態，並在之後回到之前儲存的執行狀態。

程式需要分配空間給子程序用到的區域變數，而且在子程序結束時需釋出這些變數用到的空間。許多程式語言利用[調用堆疊來存放這些變數](https://zh.wikipedia.org/wiki/調用堆疊 "wikilink")，可以簡單快速的分配及釋出空間。也有一些程式語言使用[動態記憶體分配來儲存變數](https://zh.wikipedia.org/wiki/動態記憶體分配 "wikilink")，可以較靈活的分配變數，但分配及釋出空間較不方便。這二個架構下延續性的處理方式也會不同，各有其優點及缺點。

[Scheme語言利用](../Page/Scheme.md "wikilink")`call-with-current-continuation`函數（縮寫為call/cc）
可提供延續性功能。

## 參考資料

## 相關條目

  - [分支 (計算機科學)](https://zh.wikipedia.org/wiki/分支_\(計算機科學\) "wikilink")

  -
  -
  - [控制表](../Page/控制表.md "wikilink")

  - [协程](../Page/协程.md "wikilink")

  - [循環複雜度](../Page/循環複雜度.md "wikilink")

  - [流程图](../Page/流程图.md "wikilink")

  - [Goto](../Page/Goto.md "wikilink")

  - [事件迴圈](https://zh.wikipedia.org/wiki/事件迴圈 "wikilink")

  - [递归 (计算机科学)](../Page/递归_\(计算机科学\).md "wikilink")

  - [面条式代码](../Page/面条式代码.md "wikilink")

  - [結構化程式設計](https://zh.wikipedia.org/wiki/結構化程式設計 "wikilink")

  - [子程序](../Page/子程序.md "wikilink")

  -
[Category:控制流程](https://zh.wikipedia.org/wiki/Category:控制流程 "wikilink")

1.
2.  Böhm, Jacopini. "Flow diagrams, turing machines and languages with
    only two formation rules" Comm. ACM, 9(5):366-371, May 1966.
3.
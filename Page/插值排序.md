**插值排序**（interpolation sort）或稱為直方圖排序（histogram sort）。 \[1\] 是一種使用[插值](../Page/插值.md "wikilink")公式分散資料[分而治之的](https://zh.wikipedia.org/wiki/分而治之 "wikilink")[排序演算法](https://zh.wikipedia.org/wiki/排序演算法 "wikilink")。插值排序也是[桶排序](../Page/桶排序.md "wikilink")演算法的一種變型。 \[2\]

插值排序遞迴方式運用一個記錄桶子長度的陣列對應原數列，透過操作維護長度陣列可以避免[遞歸演算法因](https://zh.wikipedia.org/wiki/遞歸 "wikilink")[記憶體](https://zh.wikipedia.org/wiki/記憶體 "wikilink")[堆疊而使](https://zh.wikipedia.org/wiki/堆疊 "wikilink")[空間複雜度變成](https://zh.wikipedia.org/wiki/空間複雜度 "wikilink") \(O(n ^ 2)\)，藉由長度陣列的分段記錄可以使用次[函式動態的宣告與刪除陣列的記憶體空間](https://zh.wikipedia.org/wiki/函式 "wikilink")，使得遞歸程序得以控制所需空間複雜度在 \(O(3n)\)，包含一個動態分配記憶體的二維陣列與一個記錄長度的陣列。但是平均[時間複雜度仍可維持為](https://zh.wikipedia.org/wiki/時間複雜度 "wikilink") \(O(n + k)\)的高效[排序方法](https://zh.wikipedia.org/wiki/排序 "wikilink")。 \[3\]

動態分配記憶體的[陣列也可以由](https://zh.wikipedia.org/wiki/陣列 "wikilink")[鏈表](https://zh.wikipedia.org/wiki/鏈表 "wikilink")、[堆棧](https://zh.wikipedia.org/wiki/堆棧 "wikilink")、[佇列](https://zh.wikipedia.org/wiki/佇列 "wikilink")、[关联数组](../Page/关联数组.md "wikilink")、[樹狀結構等實作](https://zh.wikipedia.org/wiki/樹狀結構 "wikilink")，例如 [Javascript](https://zh.wikipedia.org/wiki/Javascript "wikilink") 的陣列物件即適用。[資料結構的不同關係著資料存取的速度進而影響到排序所需的時間](https://zh.wikipedia.org/wiki/資料結構 "wikilink")。當被排序陣列內的數值是均勻分散近似[等差級數時](https://zh.wikipedia.org/wiki/等差級數 "wikilink")，插值排序的[線性時間為](https://zh.wikipedia.org/wiki/線性時間 "wikilink") \(O(n)\)。 \[4\]

## 插值排序演算法

1.  設置一個桶子長度陣列記錄未完成排序桶子的長度。初始化放入(push)原始陣列的長度。
2.  \[主排序\]：如果桶子長度陣列清空排序完成。如果未清空執行\[分桶函數\]。
3.  \[分桶函數\]：從桶子長度陣列末端取出(pop)一個桶子長度執行分桶。如果最大值等於最小值該序列排序完成停止分桶。
4.  設置一個二維陣列當作空桶子。依照插值分桶。
5.  分桶後從不是空的桶子裡把項目逐一放回原始陣列。 並在桶子長度陣列加入(push)桶子的長度。
6.  返回\[主排序\]。

## 實作

JavaScript code:

``` javascript
Array.prototype.interpolationSort = function()
{ //edit date:2019/07/31
  var bucketSize = new Array();
  var end = this.length;
  bucketSize[0] = end;
  while(bucketSize.length > 0){DivideToBucket(this);}

  function DivideToBucket(needSortArray){
    var size = bucketSize.pop();
    var start = end - size;
    var minimum = needSortArray[start];
    var maximum = needSortArray[start];
    for(i = start + 1; i < end; i++){
      if(needSortArray[i] < minimum){minimum = needSortArray[i];}
      else{if(needSortArray[i] > maximum){maximum = needSortArray[i];}}
    }
    if(minimum == maximum){end = end - size;}
    else{
      var interpolation = 0;
      var bucket = new Array(size);
      for( i = 0; i < size; i++){bucket[i] = new Array();}
      for(i = start; i < end; i++){
        interpolation = Math.floor(((needSortArray[i] - minimum) / (maximum - minimum)) * (size - 1));
        bucket[interpolation].push(needSortArray[i]);
      }
      for(i = 0; i < size; i++){
        if(bucket[i].length > 0){
          for(j = 0; j < bucket[i].length; j++){needSortArray[start++] = bucket[i][j];}
          bucketSize.push(bucket[i].length);
        }
      }
    }
  }
};
```

## 變種

### 插值標簽排序

**插值標簽排序**(Interpolation Tag Sort)是插值排序(Interpolation Sort)的變型，應用桶排序分而治之的方法,以數學插值公式將數組資料以陣列方式分散到有限數量的桶子裡,桶子再[遞歸原處理程序直到完成排序](https://zh.wikipedia.org/wiki/遞歸 "wikilink")。

公式：插值 = (設算數 -­ 最小數) / (最大數 -­ 最小數)

插值標簽排序是插值排序的遞歸排序方法,為避免遞歸造成堆疊溢出使得記憶體崩潰, 而利用一個[布林](https://zh.wikipedia.org/wiki/布林 "wikilink")[資料型別的標簽陣列操做遞迴次](https://zh.wikipedia.org/wiki/資料型別 "wikilink")[函式以釋放記憶體](https://zh.wikipedia.org/wiki/函式 "wikilink")。所需額外記憶體的[空間複雜度約等於](https://zh.wikipedia.org/wiki/空間複雜度 "wikilink") \(2n+(n)bits\)，包含一個動態分配記憶體的二維[陣列與一個布林資料型別的標簽陣列](https://zh.wikipedia.org/wiki/陣列 "wikilink")。除此之外[關聯數組](https://zh.wikipedia.org/wiki/關聯數組 "wikilink")、[鏈表](https://zh.wikipedia.org/wiki/鏈表 "wikilink")、[堆棧](https://zh.wikipedia.org/wiki/堆棧 "wikilink")、[佇列](https://zh.wikipedia.org/wiki/佇列 "wikilink")、[樹狀結構等皆可實作成桶排序的桶子](https://zh.wikipedia.org/wiki/樹狀結構 "wikilink")。誠如 [Javascript](https://zh.wikipedia.org/wiki/Javascript "wikilink") 的陣列物件即適用於此排序方法, 資料結構的不同關係著資料存取的速度進而影響到排序所需的時間。當要被排序的陣列內的數值是均勻分布的時候使用線性時間 \(\Theta(n)\)。桶[排序演算法並不是比較排序不受](https://zh.wikipedia.org/wiki/排序演算法 "wikilink") \(O(n log n)\) 下限的限制。插值標簽排序是[桶排序](../Page/桶排序.md "wikilink")的變型平均執行複雜度同為 \(O(n + k)\)。 \[5\]

#### 演算法

**插值標簽排序程序：**

1.  設置一個等量的標簽陣列初始化為假值。
2.  主排序程序判斷原序列所有區段(桶子)是否都已排序完成,未完成繼續執行桶排序。
3.  執行桶排序如果區段已排序完成停止桶排序。
4.  設置一個二維的陣列當作空桶子，尋訪序列把項目一個一個放到插值對應的桶子。
5.  從不空的桶子逐一將項目放回原序列中,並在標簽陣列將區段(桶子)的起始位置(標頭)標記為真值。
6.  遞歸傳迴下一個區段(桶子)標頭位置給主排序程序處理。

#### 實作

JavaScript code:\[6\]

``` javascript
Array.prototype.InterpolaionTagSort = function()
{     //--Whale Chen 2013/03/24 Taiwan--//
 //Whale Chen 同意：「維基百科:CC BY-SA 3.0協議文本」授權日：2019/04/01//
var end = this.length;
if ( end > 1 ){
  var start = 0 ;
  var Tag = new Array( end ); //演算法步驟1 (設置一個等量的標簽陣列初始化為假值)
  for ( i = 0; i < end; i++ ){ Tag[ i ] = false; }
  Divide( this ); }
while ( end > 1 ){            //演算法步驟2  ([主排序程序]判斷原序列所有區段(桶子)是否都已排序完成,未完成繼續執行桶排序)
  while ( Tag[ --start ] == false ){ } //當Tag[start] = true, start 為桶排序起始位置(區段標頭)
  Divide( this ); }           //演算法步驟6 (傳回下一個區段(桶子)標頭位置給主排序程序[演算法步驟2]處理)

  function Divide( A )
  {  //桶排序函數
    var min = A[ start ];
    var max = A[ start ];
    for( i = start + 1; i < end; i++ ){ if ( A[ i ] < min ){ min = A[ i ]; } else{ if ( A [ i ] > max ){ max = A[ i ]; } } }
    if ( min == max ){ end = start; } //演算法步驟3 (如果區段已排序完成(最大值＝最小值):停止桶排序)
    else{                             //演算法步驟3 (執行桶排序)
      var p = 0;
      var size = end - start;
      var Bucket = new Array( size );
      for ( i = 0; i < size; i++ ){ Bucket[ i ] = new Array( ); } //演算法步驟4 (設置一個二維的陣列當作空桶子)
      for ( i = start; i < end; i++ ){                            //演算法步驟4 (尋訪序列把項目一個一個放到插值對應的桶子)
        p = Math.floor ( ( ( A[ i ] - min ) / ( max - min ) ) * ( size - 1 ) );
        Bucket[ p ].push( A[ i ] );
      }
      for ( i = 0; i < size; i++ ){
        if ( Bucket[ i ].length > 0){ //演算法步驟5 (從不空的桶子逐一將項目放回原序列中)
          Tag[ start ] = true;        //演算法步驟5 (在標簽陣列將區段的起始位置(標頭)標記為真值)
          for ( j = 0; j < Bucket[ i ].length; j++ ){ A[ start++ ] = Bucket[ i ][ j ]; }
        }
      }
    }
  }
};
```

### 原地插值標簽排序

原地插值標簽排序是插值排序的[原地算法](../Page/原地算法.md "wikilink")（in-place algorithm）。原地插值標簽排序通過操做維護N個位元標簽可以達到只需N次的交換即可完成排序；但要排序的數組必需是連續的整數數列而且不重複，或者數列是完全平均分散近似於等差級數。原地插值標簽排序對不重複的連續整數數列排序，只需一個長度與原陣列相等的布林資料型別標簽陣列，序列從頭開始計算資料的插值，插值指向陣列的一個新位置兩者相互調換位置，將調換過的位置在標簽陣列相對應位置標記為真，遞增而行至序列結尾排序完成。因數列資料必定不重複，例如將0\~100排序，以此方法排序可一步到位，調換次數為：\(O(n)\)，計算時間複雜度為：\(O(n)\)，最壞空間複雜度：\(O(n)bits\)。如果數列的特性符合此排序方法的條件要求：「數列是不重複的連續整數或等差級數」，原地插值標簽排序將會是極為快速又節省記憶體空間的優良排序方法。

美國著名電腦科學家[高德納教授在演算法數學分析中指出](https://zh.wikipedia.org/wiki/高德納 "wikilink")：「原地置換的時間效率本質上牽涉到尋找循環領頭的問題，假如我們允許操做額外的N個位元標簽，隨時指出已經進行了多少置換，可以輕易的達成執行\(O(n)\)次的原地排列。」 \[7\] 原地插值標簽排序也是[高德納教授所說](https://zh.wikipedia.org/wiki/高德納 "wikilink")：「操做額外的N個位元標簽，達成執行\(O(n)\)次置換的原地排列」的排序演算法之一。

JavaScript code:

``` javascript
Array.prototype.InPlaceTagSort = function()
{ //從插值標簽排序想出原地插值標簽排序的靈感源自兩個偈頌的差別：
  //神秀偈頌：身是菩提樹，心如明鏡臺；時時勤拂拭，勿使惹塵埃！
  //惠能偈頌：菩提本無樹，明鏡亦非臺；本來無一物，何處惹塵埃？
  var n = this.length;
  var Tag = new Array( n );
  for ( i = 0; i < n; i++ ){ Tag[ i ] = false; }
  var min = this[ 0 ];
  var max = this[ 0 ];
  for ( i = 1; i < n; i++ ){ if ( this[ i ] < min ){ min = this[ i ]; }
  else{ if (this[ i ] > max){ max = this[ i ]; } } }
  var p = 0;
  var temp = 0;
  for ( i = 0; i < n; i++ ){
    while ( Tag[ i ] == false ){
      p = Math.floor((( this[ i ] - min ) / ( max - min )) * ( n - 1 ));
      temp = this[ i ];
      this[ i ] = this[ p ];
      this[ p ] = temp;
      Tag[ p ] = true;
    }
  }
};
needSortArray.InPlaceTagSort();
```

## 類似排序方法

### 閃電排序 FlashSort

閃電排序是一種分佈排序算法，顯示了均勻分佈數據集的線性計算複雜度\(O(n)\)和相對較少的額外內存要求。 原作於1998年由Karl-Dietrich Neubert出版。\[8\]

### 相鄰圖排序 ProxmapSort

相鄰圖排序或Proxmap排序是一種排序算法，它通過將數據項或鍵的數組劃分為多個“子陣列”（稱為桶，類似的排序）來工作。 該名稱是計算“鄰近地圖”的縮寫，其為每個鍵K指示子陣列的開始，其中K將駐留在最終的排序順序中。 使用插入排序將鍵放入每個子陣列中。 如果密鑰在子陣列中“分佈良好”，則排序發生在線性時間內。 計算複雜度估計涉及子陣列的數量和使用的鄰近映射函數，即“映射密鑰”。 它是桶和基數排序的一種形式。

相鄰圖排序完成後，如果在排序過程中密鑰分佈良好，相鄰圖搜尋可用於在\(O(1)\)時間內查找排序數組中的鍵。這兩種算法都是在20世紀80年代後期由加州大學歐文分校的 Thomas A. Standish教授發明的。\[9\]

### 美國旗幟排序 American flag sort

美國旗幟排序是基數排序的高效，就地變體，可將項目分配到存儲桶中。 非比較排序算法（如基數排序和美國國旗排序）通常用於對大型對象（如字符串）進行排序，而對像不是單位時間操作。美國國旗排序迭代對象的位，每次考慮每個對象的幾個位。對於每組位，美國國旗排序通過對像數組進行兩次遍歷：首先計算將落入每個箱中的對像數，然後將每個對象放入其桶中。 當使用256個桶一次排序一個字節時，這尤其有用。 通過一些優化，它對於大型字符串集的快速排序速度是其兩倍。在最後一步中，美國國旗的名稱類似於荷蘭國旗問題：有效地將陣列分成許多“條紋”。\[10\]

### 桶排序混合其他排序方法與遞歸算法

桶排序可以混合其他排序方法完成排序，若是由桶排序與插入排序混合，亦是相當高效的排序方法。但是當數列出現一個乖離很大的數值，例如數列最大值大於次大值的N倍時，數列分桶處理後分佈情形是除了最大值以外其餘元素都落入同一個桶子，緊接著第二個排序方法使用插入排序，可能會使得執行複雜度陷入\(O(n^2)\)，如此便失去了使用桶排序分而治之的意義與高速效能。

插值排序是使用桶排序遞歸的方式，執行遞歸以後仍然使用桶排序分散數列，這樣可以避免上述情形。如欲使得遞歸的插值排序執行複雜度陷入\(O(n^2)\)，則必需在整個數列呈現階乘放大的情況，相對上數列要出現這種特殊分佈情形的機率很少。

值得注意的是：桶排序混合插入排序方法，演算法的平均時間複雜度為 \(O(n+n^2/k+k)\)， \[11\] 當\(k=n\)時，與插值排序一樣使用\(n\)個桶子，其平均時間複雜度為\(O(3n)\) ；然而插值排序是桶排序的遞歸方法，演算法的平均時間複雜度與純粹桶排序相同僅為 \(O(n+k)\)。 \[12\] 這在排序執行效率上還是有些差別。

## 參考

## 額外參考

\[1\] [interpolationSort.html](http://xlinux.nist.gov/dads/HTML/interpolationSort.html)

\[2\] [histogramSort.html](http://xlinux.nist.gov/dads/HTML/histogramSort.html)

\[3\] [The FlashSort Algorithm](http://www.neubert.net/FSOIntro.html)

\[4\] [Mathematical Analysis of Algorithms](https://web.archive.org/web/20160304084930/http://oai.dtic.mil/oai/oai?verb=getRecord&metadataPrefix=html&identifier=AD0726158)

\[5\] <http://www.drdobbs.com/database/the-flashsort1-algorithm/184410496>

## 額外連結

  - [interpolation sort Algorithm--Whale Chen 2012/09/16](https://plus.google.com/u/0/116595705228888301771/posts/icXYXWiVKU8)
  - [桶排序(遞迴方式)演算法 Bucket Sort Recursive method](https://www.facebook.com/WhaleChen.1969/posts/2252485301532790)
  - [插值標簽排序演算法 Interpolation Tag Sort Algorithm](https://www.facebook.com/WhaleChen.1969/posts/2131925703588751)
  - [interpolation sort (Pascal version available)](http://users.dcc.uchile.cl/~rbaeza/handbook/algs/4/416.sort.c.html)
  - [w3school JavaScript 數组排序測試平台](http://www.w3school.com.cn/tiy/t.asp?f=js_array_sort_numeric_1)

[Category:排序算法](https://zh.wikipedia.org/wiki/Category:排序算法 "wikilink")

1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
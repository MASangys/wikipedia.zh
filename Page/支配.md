<table>
<thead>
<tr class="header">
<th><p>1</p></th>
<th><p>dom    </p></th>
<th></th>
<th></th>
<th><p>3</p></th>
<th><p>4</p></th>
<th><p>5</p></th>
<th><p>6</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>2</p></td>
<td><p>dom</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>5</p></td>
<td></td>
</tr>
<tr class="even">
<td><p>3</p></td>
<td><p>dom</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p>4</p></td>
<td><p>dom</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p>5</p></td>
<td><p>dom</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p>6</p></td>
<td><p>dom</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p>控制关系图</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p>表示非严格控制</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p>表示最近必经</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

|                                                                              |
| ---------------------------------------------------------------------------- |
| [Domrel.png](https://zh.wikipedia.org/wiki/File:Domrel.png "fig:Domrel.png") |

在[计算机科学](../Page/计算机科学.md "wikilink")中，[控制流图的一个](https://zh.wikipedia.org/wiki/控制流图 "wikilink")[节点](https://zh.wikipedia.org/wiki/节点 "wikilink") **d** **支配**节点 **n**，当且仅当从开始节点（可以理解为源）到节点 **n**的每一条路径均要经过节点**d**，写作**d** dom **n** (一写作**d** \(\gg\) **n**)。根据上述定义，容易得到每个节点均控制其自身。

一些相關概念：

  - 我们说一个节点 **d** 严格控制节点**n**，当且仅当 **d**控制 **n** 而不等于 **n**。
  - 节点 **n** 的最近必经点（immediate dominator），简称 **idom** 是一个独特的节点，它严格支配节点 **n**，却不支配任何严格支配节点**n**的其他节点。不是所有的节点均有最近必经点，如开始节点就没有。
  - 一个节点 **d** 的可支配边界是一个点集，其中任意节点n均满足， **d** 能严格支配所有节点u（(u,v)是图中的一条[有向边](https://zh.wikipedia.org/wiki/有向边 "wikilink")），却不能严格支配 **n**。就是 **d** 支配能力的极限。
  - 一个[支配树是一棵](https://zh.wikipedia.org/wiki/支配树 "wikilink")[树](../Page/树_\(图论\).md "wikilink")，它的所有节点儿子是被其最近支配的所有节点。由于最近必经点是唯一的，故其为一棵树，开始节点即为树根。
  - 求解支配树一般使用 Tarjan 算法

## 求解支配树的一般方法

一般而言，我们会使用 Tarjan 算法在 \(O(|V|+|E|)\)的时间内将其求出

### 大概步骤

首先来介绍一些这个算法的大概步骤

1.  对图进行DFS（深度优先遍历）并求出搜索树和DFS序。这里我们用 \(dfn[x]\)表示点 \(x\)在dfs序中的位置。
2.  根据半必经点定理计算出所有的半必经点作为计算必经点的根据
3.  根据必经点定理修正我们的半必经点，求出支配点。

### 半必经点

我们用 idom\[x\] 表示点 \(x\)的最近支配点，用 semi\[x\] 表示点 \(x\)的半必经点。

那什么是半必经点呢？

`对于一个节点 `\(Y\)`，存在某个点 `\(X\)`能够通过一系列点 `\(p_i\)`（不包含 `\(X\)`和 `\(Y\)`）到达点 `\(Y\)`且 `\(\forall i \ dfn[i]>dfn[Y]\)`，我们就称 `\(X\)`是 `\(Y\)`的半必经点，记做 semi[Y]=X`

当然一个点的“半必经点” \(X\)会有多个，而且这些半必经点一定是搜索树中点 \(X\)的祖先。

对于每个点，我们只需要保存其半必经点中最小的一个，下文中用表示点的半必经点中值最小的点的编号。

我们可以更书面一点的描述这个定理：

  - 对于一个节点 \(Y\)考虑所有能够到达它的节点，设其中一个为 \(X\)
  - 若 \(dfn[X]<dfn[Y]\)，则 \(X\)是 \(Y\)的一个半必经点

<!-- end list -->

  - 若 \(dfn[X]>dfn[Y]\)，那么对于 \(X\)在搜索树中的祖先 \(Z\)(包括 \(X\))，如果满足 \(dfn[Z]>dfn[Y]\)那么 semi\[Z\] 也是 \(Y\)的半必经点

## 历史

[计算机科学](../Page/计算机科学.md "wikilink")中支配的概念第一次被提出是在Reese T. Prosser在1959年一篇关于流网络的论文中提出的\[1\] 而在此论文中，Prosser并未提出一种有效算法以计算支配关系,解决这一问题的有效算法直到十年后才被 Edward S. Lowry and C. W. Medlock\[2\] 提出。Ron Cytron等人在1989年将其应用于高效计算应用于[静态单赋值形式](../Page/静态单赋值形式.md "wikilink")的φ 函数时对其重新燃起了兴趣。\[3\]

## 参考

<references />

4.https://blog.csdn.net/a710128/article/details/49913553

[Category:图论](https://zh.wikipedia.org/wiki/Category:图论 "wikilink")

1.
2.
3.
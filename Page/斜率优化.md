**斜率优化**（）是一种数形结合优化[动态规划的思想](../Page/动态规划.md "wikilink")，能够在不改变原有状态转移方程的情况下，大大提升效率。前提是状态转移方程中关于最优决策点项指数为1，及不含高次项且满足系数的单调递增，再借助[笛卡尔平面直角坐标系将一个决策点抽象为一个](https://zh.wikipedia.org/wiki/平面直角坐标系 "wikilink")[坐标](https://zh.wikipedia.org/wiki/坐标 "wikilink")，使用[几何方法进行求解](https://zh.wikipedia.org/wiki/几何 "wikilink")。

## 问题提出

\(N\) 个任务排成一个序列在一台机器上等待完成（顺序不得改变），这 \(N\)
个任务被分成若干批，每批包含相邻的若干任务。从时刻0开始，这些任务被分批加工，第\(i\)个任务单独完成所需的时间是\(Time_i\)。在每批任务开始前，机器需要启动时间\(S\)，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。每个任务的费用是它的完成时刻乘以一个费用系数
\(Cost_i\)。请确定一个分组方案，使得总费用最小。\[1\]
例如：\(S=1\)；\(Time=\){1,3,4,2,1}；\(Cost=\){3,2,3,3,4}。如果分组方案是
{1,2}、{3}、{4,5}，则完成时间分别为{5,5,10,14,14}，费用
\(Cost=\){15,10,30,42,56}，总费用就是153。

记 \(F(i)\) 代表完成前 \(i\) 个任务所用费用加上后面所有任务等待机器暖机时产生的费用。依题意，设计如下状态转移方程：

\[F(i)=\min\{F(j)+\sum_{k=1}^iT_i\sum_{k=j+1}^iC_k\,+S\sum_{k=j+1}^NC_k\}\]
如果使用[前缀和的思想进行优化](https://zh.wikipedia.org/wiki/前缀 "wikilink")，那么在不改变状态转移方程的情况下，整个算法的总时间复杂度为
\(O(N^2)\). 如何提升效率？

## 思想

假定对于 \(F(i)\) 而言，\(j\) 是最佳决策点，去掉 \(\min\) 函数。记
\(T_i=\sum_{j=1}^iTime_j,\;C_i=\sum_{j=1}^iCost_j\). 将状态转移方程化简得到

\(F(i)=F(j)+T_i(C_i-C_j)+S(C_n-C_j)\)

\(F(j)=(T_i+S)C_j+F(i)-SC_n-C_iT_i\)

在[笛卡尔](https://zh.wikipedia.org/wiki/笛卡尔 "wikilink")[平面直角坐标系中](https://zh.wikipedia.org/wiki/平面直角坐标系 "wikilink")，一条不水平于
\(y\) 轴的直线可以表示为 \(y=kx+b\).
将最后化简的结果看作这样的一条直线，放在坐标系中，发现这条直线斜率是固定的，而我们一旦确定了截距
\(b\), 那么意味着 \(F(i)-SC_n-C_iT_i=b\) ，由于所有的项都是常量，可以很快计算得到 \(F(i)\).
而一旦我们选定某一个平面内已经存在的点 \((C_j,\,F(j))\),
就可以确定截距。这本质上来说是一个[线性规划问题](../Page/线性规划.md "wikilink")。\[2\]也就是说，应该将这条直线从下至上平移，碰到的第一个点就是最优决策点，完成这一次状态转移之后，等同于在平面内新增了一个可供选择的决策点
\((C_i,\,F(i))\).

本质上来说，斜率优化将状态转移方程整理成为 \(F(j)=kx+F(i)+b\) 的形式，其中 \(k,x,b\)
是常量。将决策点抽象成为平面内的点，通过平移一条已知斜率的直线，确定最小（最大）的截距，从而得到
\(F(i)\) 的最小（最大）值。

## 实现

斜率优化本质上将状态方程的转移变换为了一个几何问题，如何维护目前已有点的集合，支持快速地找到最优决策点直接影响到了转移的效率。可以发现由于
\(Cost_i\in \mathbb{N}_+\),
虽然平面内的点会不断地增多，但是每次新增的点[横坐标总是](https://zh.wikipedia.org/wiki/笛卡尔坐标系#二维坐标系统 "wikilink")[单调递增的](https://zh.wikipedia.org/wiki/单调递增 "wikilink")。而如果一个点满足一定条件，那么它不可能再成为最优决策点。

[缩略图](https://zh.wikipedia.org/wiki/File:由平面内三点组成的上凸壳.png "fig:缩略图")

*与相邻两点形成一个上[凸壳的点不可能成为最优决策点](https://zh.wikipedia.org/wiki/凸壳 "wikilink")*。即存在一点
\((C_i,\,F(i))\) 满足
\(\frac{F(i)-F(i-1)}{C_i-C_{i-1}}>\frac{F(i+1)-F(i)}{C_{i+1}-C_i}\),
那么这一点不可能成为最优决策点。证明：假定存在直线 \(y=k_1x+b_1\)
可以使得这一点成为最优决策点，考虑由两个决策点组成的平面，如果过这两点的直线斜率为
\(k_0\), 那么当 \(k_1<k_0\) 时横坐标较小的点将成为最优决策点，当 \(k_1=k_0\)
时横坐标较大的点将成为最优决策点，\(k_1=k_0\)
两点同时课作为最优决策点。考虑三点组成的上凸壳，如果中间一点为最佳决策点，那么
\(k_1\ge\frac{F(i)-F(i-1)}{C_i-C_{i-1}}\), 同时
\(k_1\leq \frac{F(i+1)-F(i)}{C_{i+1}-C_i}\). 又
\(\because\frac{F(i)-F(i-1)}{C_i-C_{i-1}}>\frac{F(i+1)-F(i)}{C_{i+1}-C_i}\),
所以在所有[实数中能够成为](../Page/实数.md "wikilink") \(k_1\)
的[集合为](https://zh.wikipedia.org/wiki/集合 "wikilink")[空集](../Page/空集.md "wikilink")，这样的直线不存在。

*如果 \((C_i,\,F(i))\) 成为了某次转移时的最优决策点, 那么
\(\forall(C_j,\,F(j)),\;C_j<C_i\) 不可能是决策点*。证明：由于
\(\forall Time_i\in\mathbb{N}_+\) 所以斜率单调递增，而 \((C_i,\,F(i))\)
在一次转移时成为了最优决策点，之后的直线斜率会不断增大，横坐标小于 \(C_i\)
的点不可能再次成为最优决策点。

状态转移过程中本质上维护的是一个点的[集合](https://zh.wikipedia.org/wiki/集合 "wikilink")，将这些点按照横坐标排序后，相邻点的斜率应该是[单调递增的](https://zh.wikipedia.org/wiki/单调递增 "wikilink")，使用[单调队列进行维护](https://zh.wikipedia.org/wiki/单调队列 "wikilink")，每次操作均摊复杂度是
\(O(1)\).

## 应用与扩展

### 适用条件

### 推广

## 参考程序

### [C++](../Page/C++.md "wikilink")

``` cpp
#include<bits/stdc++.h>

signed main(void)
{
    constexpr auto MAXN = 5000 + 50;

    int totMission, warmTime, time[MAXN] = {}, cost[MAXN] = {};
    int que[MAXN] = {0}, *head = que, *tail = que;
    int D[MAXN] = {};

    scanf("%d%d", &totMission, &warmTime);
    for (int i = 1; i <= totMission; i++)scanf("%d%d", time + i, cost + i);
    for (int i = 1; i <= totMission; i++)time[i] += time[i - 1], cost[i] += cost[i - 1];

#define and &&
    for (int i = 1; i <= totMission; i++) {
        while (head < tail/*队列中至少有两个元素*/
            and D[*(head + 1)] - D[*head] < (time[i] + warmTime)*(cost[*(head + 1)] - cost[*head]) /*斜率小于直线斜率*/
            )++head;
        D[i] = D[*head] - cost[*head] * (time[i] + warmTime) + cost[i] * time[i] + warmTime * cost[totMission];
        //直接使用队头最为最优决策点执行状态转移
        //删除队尾多余元素
        while (head < tail
            and (D[i] - D[*tail])*(cost[*tail] - cost[*(tail - 1)]) < (D[*tail] - D[*(tail - 1)])*(cost[i] - cost[*tail])
            )--tail;
        *++tail = i;
    }

    printf("%d\n", D[totMission]);

    //system("pause");
    return 0;
}
```

## 相关条目

  - [动态规划](../Page/动态规划.md "wikilink")
  - [欧氏几何](https://zh.wikipedia.org/wiki/欧氏几何 "wikilink")
  - [平面直角坐标系](https://zh.wikipedia.org/wiki/平面直角坐标系 "wikilink")
  - [单调函数](../Page/单调函数.md "wikilink")
  - [单调队列](https://zh.wikipedia.org/wiki/单调队列 "wikilink")
  - [四边形不等式](https://zh.wikipedia.org/wiki/四边形不等式 "wikilink")

## 参考文献

1.  SDOI2012
2.
**智能指针**（）是一種抽象的[資料類型](../Page/資料類型.md "wikilink")。在程式設計中，它通常是經由[类模板來實作](https://zh.wikipedia.org/wiki/模板_\(C++\)#类模板 "wikilink")，藉由[模板來達成泛型](../Page/模板_\(C++\).md "wikilink")，藉由[類別的解構函數來達成自動釋放指標所指向的記憶體或物件](../Page/类_\(计算机科学\).md "wikilink")。

## C++中的智能指针

### auto_ptr

`auto_ptr`這個類別模板被定義在[ISO/IEC
14882的第](https://zh.wikipedia.org/wiki/C++#.E6.A0.87.E5.87.86.E5.8C.96 "wikilink")20.4.5章節裡：

``` cpp
namespace std {

    template <class Y> struct auto_ptr_ref {};

    template <class X>
    class auto_ptr {
    public:
        typedef X element_type;

        // 20.4.5.1 construct/copy/destroy:
        explicit           auto_ptr(X* p =0)throw();
                           auto_ptr(auto_ptr&)throw();
        template <class Y> auto_ptr(auto_ptr<Y>&)throw();

        auto_ptr&                      operator=(auto_ptr&)throw();
        template <class Y> auto_ptr&   operator=(auto_ptr<Y>&)throw();
        auto_ptr&                      operator=(auto_ptr_ref<X>)throw();

        ~auto_ptr() throw();

        // 20.4.5.2 members:
        X&     operator*() const throw();
        X*     operator->() const throw();
        X*     get() const throw();
        X*     release() throw();
        void   reset(X* p =0)throw();

        // 20.4.5.3 conversions:
        auto_ptr(auto_ptr_ref<X>)throw();
        template <class Y> operator auto_ptr_ref<Y>() throw();
        template <class Y> operator auto_ptr<Y>() throw();
    };

}
```

### unique_ptr

[C++11中提供了](../Page/C++11.md "wikilink")，定义在头文件中。

C++11新增了move语义，相比copy语义，它能更好的实现值传递.使用的是copy语义，为了[向后兼容](https://zh.wikipedia.org/wiki/向后兼容 "wikilink"),C++11没有修改std::auto_ptr，而是引入了新的使用move语义的.

uniqu_ptr的拷贝构造函数和赋值运算符都声明为deleted，也就是说它不能被拷贝，只能通过来转递它所指向的内存的所有权。

``` cpp
std::unique_ptr<int> p1(new int(5));
std::unique_ptr<int> p2 = p1; // 编译会出错
std::unique_ptr<int> p3 = std::move (p1); // 转移所有权，现在那块内存归p3所有, p1成为无效的指针。

p3.reset(); //释放内存。
p1.reset(); //实际上什么都没做。
```

依然存在，但在C++11中被标为"弃用".

### shared_ptr和weak_ptr

基于[Boost库](https://zh.wikipedia.org/wiki/Boost "wikilink"),
C++11加入了和.它们最早在[TR1中就被引入](https://zh.wikipedia.org/wiki/C++_Technical_Report_1#Smart_pointers "wikilink")，但在C++11中，在Boost的基础上又加入了新的功能。

使用[引用计数](../Page/引用计数.md "wikilink")。每一个的拷贝都指向相同的内存。在最后一个析构的时候，内存才会被释放。

``` cpp
std::shared_ptr<int> p1(new int(5));
std::shared_ptr<int> p2 = p1; // 都指向同一内存。

p1.reset(); // 因为p2还在，所以内存没有释放。
p2.reset(); // 释放内存，因为没有shared_ptr指向那块内存了。
```

使用引用计数，所以有[循环计数的问题](https://zh.wikipedia.org/wiki/循环计数 "wikilink")。为了打破循环，可以使用.顾名思义,
weak_ptr是一个弱引用，只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以不保证它指向的内存一定是有效的，在使用之前需要检查。

``` cpp
std::shared_ptr<int> p1(new int(5));
std::weak_ptr<int> wp1 = p1; // 还是只有p1有所有权。

{
  std::shared_ptr<int> p2 = wp1.lock(); // p1和p2都有所有权
  if (p2) // 使用前需要检查
  {
    // 使用p2
  }
} // p2析构了，现在只有p1有所有权。

p1.reset(); // 内存被释放。

std::shared_ptr<int> p3 = wp1.lock(); // 因为内存已经被释放了，所以得到的是空指针。
if（p3）
{
  // 不会执行到这。
}
```

## 外部連結

  - Sample chapter "[Smart
    Pointers](http://www.informit.com/articles/article.aspx?p=25264)"
    from the book *[Modern C++ Design: Generic Programming and Design
    Patterns Applied](http://www.moderncppdesign.com/)* by [Andrei
    Alexandrescu](https://zh.wikipedia.org/wiki/Andrei_Alexandrescu "wikilink"),
    Addison-Wesley, 2001.
  - Code example
    "[countptr.hpp](http://www.josuttis.com/libbook/cont/countptr.hpp.html)"
    from the book *[The C++ Standard Library - A Tutorial and
    Reference](http://www.josuttis.com/libbook/)* by [Nicolai M.
    Josuttis](https://zh.wikipedia.org/wiki/Nicolai_M._Josuttis "wikilink")
  - "[Boost Smart
    Pointers](http://boost.org/libs/smart_ptr/smart_ptr.htm)"
  - Article "[The New C++: Smart (er)
    Pointers](http://www.drdobbs.com/184403837/)" by [Herb
    Sutter](https://zh.wikipedia.org/wiki/Herb_Sutter "wikilink") August
    01, 2002
  - "[Smart Pointers - What, Why,
    Which?](http://ootips.org/yonat/4dev/smart-pointers.html)" by [Yonat
    Sharon](https://zh.wikipedia.org/wiki/Yonat_Sharon "wikilink")
  - "[Smart Pointers
    Overview](http://dlugosz.com/Repertoire/refman/Classics/Smart%20Pointers%20Overview.html)"
    by [John M.
    Dlugosz](https://zh.wikipedia.org/wiki/John_M._Dlugosz "wikilink")
  - The [YASPER library](http://yasper.sourceforge.net/) Yet Another
    Smart Pointer implementation in C++
  - [Smart Pointers in
    Delphi](http://barrkel.blogspot.com/2008/09/smart-pointers-in-delphi.html)

[Category:数据类型](https://zh.wikipedia.org/wiki/Category:数据类型 "wikilink")
在计算机科学中，最长回文子串或最长对称因子问题是在一个[字符串中查找一个最长的连续的](../Page/字符串.md "wikilink")[回文的子串](../Page/回文.md "wikilink")，例如“banana”最长回文子串是“anana”。最长回文子串并不一定是唯一的，比如“abracadabra”，没有超过3的回文子串，但是有两个回文字串长度都是3：“ada”和“aca”。在一些应用中，我们求出全部的极大回文子串（不被其他回文串包含的回文子串）。

Manacher于\[1\]发现了一种线性时间算法，可以在列出给定字符串中从任意位置开始的所有回文子串。并且，Apostolico,
Breslauer & Galil
\[2\]发现，同样的算法也可以在任意位置查找全部极大回文子串，并且时间复杂度是线性的。因此，他们提供了一种时间复杂度为线性的最长回文子串解法。另外，Jeuring
(1994)\[3\], Gusfield (1997)\[4\]发现了基于后缀树的算法。也存在已知的高效并行算法。

最长回文子串算法不应当与最长回文子序列算法混淆。

## 定义

### 回文字符串

如果一个长度为 \(n\) 的[字符串](../Page/字符串.md "wikilink") \(s\) 当中所有字符依次为
\(s_0,\,s_1,\,s_2\,\cdots\,s_{n-1}\). 且 \(s\) 满足
\(\forall i\in \left[0,\left\lfloor\frac{n}{2}\right\rfloor\right],\;s_i=s_{n-i-1}\),
那么则称 \(s\) 为一个回文字符串。

### 最长回文子串

如果字符串 \(s\)
的一个[回文](https://zh.wikipedia.org/wiki/#回文字符串 "wikilink")[子串](../Page/子串.md "wikilink")
\(s_1\) 是 \(s\) 所有回文子串中长度最长的，那么则称 \(s_1\) 为 \(s\) 的最长回文子串。

## Manacher算法

要在线性时间内找出字符串的最长回文子串，这个算法必须利用回文和子回文的这些特点和观察

1.  回文的左边是右边的镜像

## 实现

### [Python](../Page/Python.md "wikilink")

``` python
def manacher(s0 : str) -> list:
    T = '$#' + '#'.join(s0) + '#@'
    l = len(T)
    P = [0] * l
    R, C = 0, 0
    for i in range(1,l-1):
        if i < R:
            P[i] = min(P[2 * C - i], R - i)

        while T[i+(P[i]+1)] == T[i-(P[i]+1)]:
            P[i] += 1

        if P[i] + i > R:
            R = P[i] + i
            C = i
    return P
```

### [C++](../Page/C++.md "wikilink")

``` cpp
constexpr auto MAXN = (int)7000000;

char s[MAXN << 1], str[MAXN];
int RL[MAXN];

int Manacher(void) {
    size_t len = strlen(str); *s = '#';
    for (int i = 0; i < len; i++) {
        s[(i << 1) + 1] = str[i]; s[(i << 1) + 2] = '#';
    }len = (len << 1) + 1;

    int max = 1, pos, maxRight = -1; memset(RL, 0, sizeof(RL));
    for (int i = 0; i < len; i++) {
        if (i < maxRight) RL[i] = std::min(RL[(pos << 1) - i], maxRight - i);
        else RL[i] = 1;
        while (i - RL[i] >= 0 && i + RL[i] < len && s[i - RL[i]] == s[i + RL[i]])++RL[i];
        if (i + RL[i] > maxRight) { pos = i; maxRight = i + RL[i]; }
        max = std::max(max, RL[i] - 1);
    } return max;
}
```

### [Matlab](https://zh.wikipedia.org/wiki/Matlab "wikilink")

``` matlab
function m = Manacher(a)
    T = ['$#' reshape([a;ones(size(a))*'#'], 1, '') '@'];
    l = length(T);
    P = zeros(1, l);

    mx = 0; %range
    id = 0; %center
    for i = 2:l-1
        if i < mx
            P(i) = min(P(2 * id - i), mx - i);
        else
            P(i) = 1;
        end

        while T(i+P(i)) == T(i-P(i))
            P(i) = P(i) + 1;
        end

        if P(i) + i > mx
            mx = P(i) + i;
            id = i;
        end
    end
    m = max(P)-1;
```

## 参考资料

[Category:字符串算法](https://zh.wikipedia.org/wiki/Category:字符串算法 "wikilink")

1.
2.
3.
4.
**模擬退火**是一種通用[概率演算法](https://zh.wikipedia.org/wiki/概率演算法 "wikilink")，常用來在一定時間內尋找在一個很大[搜尋空間中的近似](https://zh.wikipedia.org/wiki/搜尋空間 "wikilink")[最優解](https://zh.wikipedia.org/wiki/最優解 "wikilink")。模擬退火是S.
Kirkpatrick, C. D. Gelatt和M. P. Vecchi在1983年所發明。而V.
Černý在1985年也獨立發明此[演算法](https://zh.wikipedia.org/wiki/演算法 "wikilink")。

## 簡介

模拟退火來自[冶金學的專有名詞](https://zh.wikipedia.org/wiki/冶金學 "wikilink")[退火](../Page/退火.md "wikilink")。退火是將材料加熱後再經特定速率冷卻，目的是增大[晶粒的體積](https://zh.wikipedia.org/wiki/晶體 "wikilink")，並且減少晶格中的缺陷。材料中的原子原來會停留在使[內能有局部最小值的位置](https://zh.wikipedia.org/wiki/內能 "wikilink")，加熱使能量變大，原子會離開原來位置，而隨機在其他位置中移動。退火冷卻時速度較慢，使得原子有較多可能可以找到內能比原先更低的位置。

模擬退火的原理也和金屬退火的原理近似：我們將熱力學的理論套用到統計學上，將搜尋空間內每一點想像成空氣內的分子；分子的能量，就是它本身的動能；而搜尋空間內的每一點，也像空氣分子一樣帶有“能量”，以表示該點對命題的合適程度。演算法先以搜尋空間內一個任意點作起始：每一步先選擇一個“鄰居”，然後再計算從現有位置到達“鄰居”的概率。

可以证明，模拟退火算法所得解[依概率收敛到全局最优解](../Page/依概率收敛.md "wikilink")。

## 演算步驟

### 初始化

生成一个可行的解作为当前解输入迭代过程，并定义一个足够大的数值作为初始温度。

### 迭代过程

迭代过程是模拟退火算法的核心步骤，分为新解的产生和接受新解两部分：

1.  由一个产生函数从当前解产生一个位于解空间的新解；为便于后续的计算和接受，减少算法耗时，通常选择由当前新解经过简单地变换即可产生新解的方法，如对构成新解的全部或部分元素进行置换、互换等，注意到产生新解的变换方法决定了当前新解的邻域结构，因而对冷却进度表的选取有一定的影响。
2.  计算与新解所对应的目标函数差。因为目标函数差仅由变换部分产生，所以目标函数差的计算最好按增量计算。事实表明，对大多数应用而言，这是计算目标函数差的最快方法。
3.  判断新解是否被接受，判断的依据是一个接受准则，最常用的接受准则是Metropolis准则：若Δt′\<0则接受S′作为新的当前解S，否则以概率exp（-Δt′/T）接受S′作为新的当前解S。
4.  当新解被确定接受时，用新解代替当前解，这只需将当前解中对应于产生新解时的变换部分予以实现，同时修正目标函数值即可。此时，当前解实现了一次迭代。可在此基础上开始下一轮试验。而当新解被判定为舍弃时，则在原当前解的基础上继续下一轮试验。

模拟退火算法与初始值无关，算法求得的解与初始解状态S（是算法迭代的起点）无关；模拟退火算法具有渐近收敛性，已在理论上被证明是一种以概率1收敛于全局最优解的全局优化算法；模拟退火算法具有并行性。

### 停止准则

迭代过程的停止准则：温度T降至某最低值时，完成给定数量迭代中无法接受新解，停止迭代，接受当前寻找的最优解为最终解。

### 退火方案

在某个温度状态T下，当一定数量的迭代操作完成后，降低温度T，在新的温度状态下执行下一个批次的迭代操作。

## 偽代碼

尋找能量E（s）最低的狀態s <code>

`s := s0; e := E (s)                           // `*`設定目前狀態為s0，其能量E``
 ``(s0)`*
`k := 0                                       // `*`評估次數k`*
**`while`**` k < kmax `**`and`**` e > emin                  // `*`若還有時間（評估次數k還不到kmax）且結果還不夠好（能量e不夠低）則：`*
`  sn := neighbour (s)                         //   `*`隨機選取一鄰近狀態sn`*
`  en := E (sn)                                //   `*`sn的能量為E``
 ``(sn)`*
`  `**`if`**` random() < P(e, en, temp(k/kmax)) `**`then`**`  //   `*`決定是否移至鄰近狀態sn`*
`    s := sn; e := en                         //     `*`移至鄰近狀態sn`*
`  k := k + 1                                 //   `*`評估完成，次數k加一`*
**`return`**` s                                     // `*`回傳狀態s`*

</code>

## 参见

  - [演算法](https://zh.wikipedia.org/wiki/演算法 "wikilink")
  - [旅行推銷員問題](https://zh.wikipedia.org/wiki/旅行推銷員問題 "wikilink")
  - [蚁群算法](../Page/蚁群算法.md "wikilink")
  - [遗传算法](../Page/遗传算法.md "wikilink")

## 外部链接

  - [基于MATLAB实现的全局优化算法](https://web.archive.org/web/20090319230318/http://biomath.ugent.be/~brecht/downloads.html)：SIMPSA（SA和单纯的组合），洗牌复杂的演化（SCA）和粒子群优化（PSO）。

[Category:最優化演算法](https://zh.wikipedia.org/wiki/Category:最優化演算法 "wikilink")
[Category:蒙地卡羅方法](https://zh.wikipedia.org/wiki/Category:蒙地卡羅方法 "wikilink")

[Category:算法](https://zh.wikipedia.org/wiki/Category:算法 "wikilink")
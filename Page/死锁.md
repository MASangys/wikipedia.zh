> 本文内容由[死锁](https://zh.wikipedia.org/wiki/死锁)转换而来。


[Process_deadlock.svg](https://zh.wikipedia.org/wiki/File:Process_deadlock.svg "fig:Process_deadlock.svg") **死锁**（），又譯為**-{zh-cn:死结; zh-tw:死鎖;}-**，計算機科學名詞。當兩個以上的運算單元，雙方都在等待對方停止執行，以取得系統資源，但是沒有一方提前退出時，就稱為死結。在多工作業系統中，作業系統為了協調不同行程，能否取得系統資源時，為了讓系統運作，必須要解決這個問題。

这里指的是[进程死锁](https://zh.wikipedia.org/wiki/进程 "wikilink")，是个计算机技术名词。它是[操作系统](../Page/操作系统.md "wikilink")或软件运行的一种状态：在多工系統下，当一个或多个进程等待系统资源，而资源又被进程本身或其他进程占用时，就形成了死锁。有个变种叫[活锁](https://zh.wikipedia.org/wiki/活锁 "wikilink")。

## 简介

例如，一个[进程](https://zh.wikipedia.org/wiki/进程 "wikilink") p1占用了显示器，同时又必须使用打印机，而打印机被进程p2占用，p2又必须使用显示器，这样就形成了死锁。 因為p1必須等待p2釋出打印機才能夠完成工作並釋出螢幕，同時p2也必須等待p1釋出顯示器才能完成工作並釋出打印機，形成循環等待的死結。

## 死锁的预防

如果系统中只有一个进程，当然不会产生死锁。如果每个进程仅需求一种系统资源，也不会产生死锁。不过这只是理想状态，在现实中是可遇不可求的。

死锁的四个条件是：

  - **禁止抢占**（no preemption）：系統資源不能被强制从一个进程中退出

<!-- end list -->

  - **持有和等待**（hold and wait）：一个进程可以在等待时持有系统资源

<!-- end list -->

  - **互斥**（mutual exclusion）：資源只能同時分配給一個行程，無法多個行程共用。

<!-- end list -->

  - **循环等待**（circular waiting）：一系列进程互相持有其他进程所需要的资源

死锁只有在这四个条件同时满足时出现。预防死锁就是至少破坏这四个条件其中一項，即破坏“禁止抢占”、破坏“持有等待”、破坏“资源互斥”或破坏“循环等待”。

## 死锁的避免

我们也可以尝试回避死锁。因为在理论上，死锁总是可能产生的，所以操作系统尝试监视所有进程，使其没有死锁。

## 死锁的消除

最简单的消除死锁的办法是重启系统。更好的办法是终止一个进程的运行。

同样也可以把一个或多个进程回滚到先前的某个状态。如果一个进程被多次回滚，迟迟不能占用必需的系统资源，可能会导致。

## 活結

活結（），與死結相似，死結是行程都在等待對方釋放先資源；活結則是行程彼此釋放資源又同時占用對方釋放的資源，當此情況持續發生時，儘管資源的狀態不斷改變，但每個行程都無法取得所需資源，使得事情沒有任何進展。

## 死結與活結的例子

假設兩人正好面對面碰上對方：

  - 死結：兩人互不相讓，都在等對方先讓開。
  - 活結：兩人互相禮讓，卻恰巧站到同一側，再次讓開，又站到同一側，同樣的情況不斷重複下去導致雙方都無法通過。

## 参见

  - [競爭危害](../Page/競爭危害.md "wikilink")

[Category:操作系統技術](https://zh.wikipedia.org/wiki/Category:操作系統技術 "wikilink") [Category:協同控制](https://zh.wikipedia.org/wiki/Category:協同控制 "wikilink") [Category:程式錯誤](https://zh.wikipedia.org/wiki/Category:程式錯誤 "wikilink")
**生成器**是[计算机科学中特殊的](../Page/计算机科学.md "wikilink")[子程序](../Page/子程序.md "wikilink")。实际上，所有生成器都是[迭代器](../Page/迭代器.md "wikilink")。\[1\]生成器非常类似于返回数组的函数，都是具有参数、可被调用、产生一系列的值。但是生成器不是构造出数组包含所有的值并一次性返回，而是每次产生一个值，因此生成器看起来像函数，但行为像迭代器。

生成器可以用更有表达力的[控制流结构实现](https://zh.wikipedia.org/wiki/控制流 "wikilink")，如[协程或头等](../Page/协程.md "wikilink")[計算續體](https://zh.wikipedia.org/wiki/延續性 "wikilink")。\[2\]
生成器，也被称作半协程（semicoroutine），\[3\]是特殊的、能力更弱的协程，总是在传回一个值时把控制交还给调用者，而不是像协程那样指出另一个协程继续执行。

## 使用

生成器通常在一个循环内部被调用。\[4\]
生成器第一次被调用是在进入这个循环结构时，创建一个对象以封装生成器的状态、绑定的实参。生成器的实体接着被执行直至遇到一个特别的*yield*动作，在这里提供给*yield*动作的值被返回给调用者。在下一次调用同一个生成器的时候，生成器从*yield*动作之后恢复执行，直到遇上另一个*yield*动作。生成器的执行也可以遇到*finish*动作而终止。

由于生成器计算它的要被yield的值是按需的，因此可以用来代表一个[流](../Page/字串流.md "wikilink")，一次性全部计算出来是昂贵的甚至是不可能的，或是无穷序列或直播数据序列。

如果需要迅速求值，可以使用[列表或使用并行结构来创建一个列表](../Page/串列_\(抽象資料型別\).md "wikilink")。例如，Python的一个生成器`g`可被求值到列表`l`通过`l
= list(g)`。

生成器可用于在表达式中完成传统的循环结构的功能。

## 历史

生成器最早出现于[CLU语言](../Page/CLU.md "wikilink") (1975)。\[5\]

现在，[Python](../Page/Python.md "wikilink"),\[6\]
[C\#](https://zh.wikipedia.org/wiki/C# "wikilink"),\[7\]
[Ruby](../Page/Ruby.md "wikilink"), 最新版本的ECMAScript
(ES6/ES2015)与其他语言。在CLU与C\#，生成器称作*iterators*,
在Ruby称作*enumerators*.

### C++

使用宏预处理的例子见\[8\]:

``` cpp
$generator(descent)
{
   // place for all variables used in the generator
   int i; // our counter

   // place the constructor of our generator, e.g.
   // descent(int minv, int maxv) {...}

   // from $emit to $stop is a body of our generator:

   $emit(int) // will emit int values. Start of body of the generator.
      for (i = 10; i > 0; --i)
         $yield(i); // a.k.a. yield in Python,
                    // returns next number in [1..10], reversed.
   $stop; // stop, end of sequence. End of body of the generator.
};
```

可迭代：

``` cpp
int main(int argc, char* argv[])
{
  descent gen;
  for(int n; gen(n);) // "get next" generator invocation
    printf("next number is %d\n", n);
  return 0;
}
```

[C++11提供的](../Page/C++11.md "wikilink")[foreach
loop可用于任何具有](https://zh.wikipedia.org/wiki/foreach_loop "wikilink")`begin`与`end`成员函数的类。还需要有`operator!=`,
`operator++` 与`operator*`。例如：

``` cpp
#include <iostream>
int main()
{
    for (int i: range(10))
    {
        std::cout << i << std::endl;
    }
    return 0;
}
```

一个基本实现：

``` cpp
class range
{
private:
    int last;
    int iter;

public:
    range(int end):
        last(end),
        iter(0)
    {}

    // Iterable functions
    const range& begin() const { return *this; }
    const range& end() const { return *this; }

    // Iterator functions
    bool operator!=(const range&) const { return iter < last; }
    void operator++() { ++iter; }
    int operator*() const { return iter; }
};
```

### C\#

C\# 2.0开始可以利用`yield`构造生成器。

``` csharp
// Method that takes an iterable input (possibly an array)
// and returns all even numbers.
public static IEnumerable<int> GetEven(IEnumerable<int> numbers) {
    foreach (int i in numbers) {
        if ((i % 2) == 0) {
            yield return i;
        }
    }
}
```

可以使用多个`yield return`语句：

``` csharp
public class CityCollection : IEnumerable<string> {
    public IEnumerator<string> GetEnumerator() {
        yield return "New York";
        yield return "Paris";
        yield return "London";
    }
}
```

### Python

2.2版开始支持生成器。\[9\]

``` python
def countfrom(n):
    while True:
        yield n
        n += 1

# Example use: printing out the integers from 10 to 20.
# Note that this iteration terminates normally, despite
# countfrom() being written as an infinite loop.

for i in countfrom(10):
    if i <= 20:
        print(i)
    else:
        break

# Another generator, which produces prime numbers indefinitely as needed.

def primes():
    yield 2
    n = 3
    p = []
    while True:
        # This works in Python 2.5+
        if not any(n % f == 0 for f in
                     itertools.takewhile(lambda f: f*f <= n, p)):
            yield n
            p.append(n)
        n += 2
```

Python的生成器可以认为是一个迭代器包含了冻结的[栈帧](https://zh.wikipedia.org/wiki/栈帧 "wikilink")。当用`next()`方法调用迭代器，Python恢复冻结的栈帧，继续执行至下一次的`yield`语句。生成器的栈帧再一次冻结，被yield的值返回给调用者。

PEP 380 (Python 3.3开始)增加了`yield from`表达式，允许生成器委托它的行为给另一个生成器。\[10\]

#### 生成器表达式

Python的一种语法模拟了。

``` python
squares = ( n*n  for n in countfrom(2) )

for j in squares:
    if j <= 20:
        print(j)
    else:
        break
```

## 参见

  -
  - [迭代器](../Page/迭代器.md "wikilink")

  -
  - [惰性求值](../Page/惰性求值.md "wikilink")

  -
  - [协程](../Page/协程.md "wikilink")

  - [計算續體](https://zh.wikipedia.org/wiki/延續性 "wikilink")

## 参考文献

<references/>

  - Stephan Murer, [Stephen
    Omohundro](https://zh.wikipedia.org/wiki/Steve_Omohundro "wikilink"),
    David Stoutamire and Clemens Szyperski: Iteration abstraction in
    [Sather](https://zh.wikipedia.org/wiki/Sather "wikilink"). *ACM
    Transactions on Programming Languages and Systems*, 18(1):1-15
    (1996) [1](http://portal.acm.org/citation.cfm?doid=225540.225541)

[Category:编译原理](https://zh.wikipedia.org/wiki/Category:编译原理 "wikilink")
[Category:抽象数据类型](https://zh.wikipedia.org/wiki/Category:抽象数据类型 "wikilink")

1.  <https://stackoverflow.com/questions/1022564/what-is-the-difference-between-an-iterator-and-a-generator>

2.

3.

4.  The [Icon Programming
    Language](https://zh.wikipedia.org/wiki/Icon_\(programming_language\) "wikilink")
    utilizes generators to implement its goal directed evaluation. In
    Icon, generators can be invoked in contexts outside of the normal
    looping control structures.

5.

6.  Python Enhancement Proposals: [PEP 255: Simple
    Generators](https://www.python.org/dev/peps/pep-0255/), [PEP 289:
    Generator Expressions](https://www.python.org/dev/peps/pep-0289/),
    [PEP 342: Coroutines via Enhanced
    Generators](https://www.python.org/dev/peps/pep-0342/)

7.  [yield (C\#
    Reference)](http://msdn.microsoft.com/en-us/library/9k7k7cf0.aspx)

8.  <http://www.codeproject.com/KB/cpp/cpp_generators.aspx>

9.
10. [PEP 380 -- Syntax for Delegating to a
    Subgenerator](https://www.python.org/dev/peps/pep-0380/)
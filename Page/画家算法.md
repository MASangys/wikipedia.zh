> 本文内容由[画家算法](https://zh.wikipedia.org/wiki/画家算法)转换而来。


**画家算法**也叫作**优先填充**，它是[三维计算机图形](../Page/三维计算机图形.md "wikilink")学中处理[可见性问题的一种解决方法](https://zh.wikipedia.org/wiki/可见性问题 "wikilink")。当将三维场景投影到二维平面的时候，需要确定哪些[多边形](../Page/多边形.md "wikilink")是可见的，哪些是不可见的。

“画家算法”表示头脑简单的画家首先绘制距离较远的场景，然后用绘制距离较近的场景覆盖较远的部分。画家算法首先将场景中的多边形根据深度进行排序，然后按照顺序进行描绘。这种方法通常会将不可见的部分覆盖，这样就可以解决可见性问题。

<center>

[Painter's_algorithm.png](https://zh.wikipedia.org/wiki/File:Painter's_algorithm.png "fig:Painter's_algorithm.png")

</center>

[Painters_problem.png](https://zh.wikipedia.org/wiki/File:Painters_problem.png "fig:Painters_problem.png")

在有些场合下，画家算法可能无法解决可见性问题。在这个例子中，多边形 A、B、C 互相重叠，我们无法确定哪一个多边形在上面，哪一个在下面，我们也无法确定两个多边形什么时候在三维空间中交叉。在这种情况下必须用一些方法对这些多边形进行切分、排序。1972年提出的[Newell算法就是切分类似多边形的一种方法](https://zh.wikipedia.org/wiki/Newell算法 "wikilink")，在[计算几何](../Page/计算几何.md "wikilink")领域人们已经提出了许许多多的解决方法。

一些基本的画家算法实现方法也可能效率很低，因为这将使得系统将可见多边形集合中的每个点都进行[渲染](../Page/渲染.md "wikilink")，而没有考虑这些多变性在最终场景中可能被其它部分遮挡。这也就是说，对于细致的场景来说，画家算法可能会过度地消耗计算机资源。

人们有时候也使用**逆向画家算法**进行处理，这种算法首先绘制距离观察者较近的物体，已经进行绘制的部分不再进行其它的绘制过程。在计算机图形系统中，这种方法由于无需根据光照、纹理等参数计算被较近物体遮挡的远处物体的颜色，所以效率非常高。但是，这种方法也有许多与普通画家算法同样的问题。

画家算法的这些缺陷导致了[深度缓冲](../Page/深度缓冲.md "wikilink")技术的发展，深度缓冲技术可以看作是画家算法的一个发展，它根据逐个像素的信息解决深度冲突的问题，并且抛弃了对于深度渲染顺序的依赖。即使在这样的系统中，有时也使用画家算法的变体。由于深度缓冲实现通常是基于硬件中的固定精度深度缓冲寄存器，因此舍入误差就会带来一些显示问题，即在多边形连接的地方会出现重叠或者间隙。为了避免这种问题，一些图形处理引擎使用了“过度渲染”的方法，即根据画家算法的顺序绘制两个多边形中受影响的边界。这也就是说有些像素如同在画家算法中那样实际上绘制了两次，但是由于图像中只有很少的一部分才做这样的处理，因此对于性能的影响很小。

[Category:三维计算机图形学](https://zh.wikipedia.org/wiki/Category:三维计算机图形学 "wikilink") [Category:算法](https://zh.wikipedia.org/wiki/Category:算法 "wikilink")
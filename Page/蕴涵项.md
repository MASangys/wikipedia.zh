在[布尔逻辑](../Page/布尔逻辑.md "wikilink")的積項和式中(和項積式亦可)，[乘积项](../Page/规范形式_\(布尔代数\).md "wikilink")*P* 是[布尔函数](../Page/布尔函数.md "wikilink") *F* 的**蕴涵项**（），如果 *P* 蕴涵 *F*。更加准确的说：

  - *F* 是 *n* 个变量的[布尔函数](../Page/布尔函数.md "wikilink")。
  - *P* 是乘积项。
  - 若对于使 *P* 得到值 1 的所有组合，*F* 也等于 1，則 *P* 蕴涵 *F* (*P* 是 *F* 的蘊涵項)。

这意味着在布尔空间的自然次序上 P⇒F。比如，函数

\[f(x,y,z,w)=xy+yz+w \,\]

蕴涵自 \(xy\)，\(xyz\)，\(xyzw\)，\(w\) 和很多其他的项: 它们是 \(f\) 的蕴涵项。

[威拉德·冯·奥曼·蒯因](../Page/威拉德·冯·奥曼·蒯因.md "wikilink")定义：

1.  *F* 的**素蕴涵项**（prime implicant）为最少化文字數量的蕴涵项——就是说，如果从 *P* 去除任何“文字”（literal）都导致 *P* 成為 *F* 的非蕴涵项。例如*100*和*101*是某逻辑函数的两个蕴涵项，那么*10x*就是函数的一个素蕴涵项，其中的1和0两个数字不可再去掉；
2.  **本质素蕴涵项**（essential prime implicant）为蘊涵於不满足任何其他素蕴涵项的極小項(minterm)的那些素蕴涵项——若存在只被一個素蘊涵項覆蓋的極小項，則覆蓋該極小項的素蘊涵項為本質素蘊涵項。如果以[卡诺图](../Page/卡诺图.md "wikilink")的形式来描述逻辑函数，可以发现只有一种方式可以圈选这个输入组合。

使用上面的例子，你可以轻易的看到尽管 \(xy\)（和其他的项）是素蕴涵项，\(xyz\) 和 \(xyzw\) 不是。从后者，可以去除多个文字来使它成为素的：

  - \(x\)、\(y\) 和 \(z\) 可以去除，生成 \(w\)。
  - 可作为选择的，\(z\) 和 \(w\) 可以去除，生成 \(xy\)。
  - 最后，\(x\) 和 \(w\) 可以被去除，生成 \(yz\)。

将布尔项中文字去除的过程叫做'对这个项的*扩展*'。扩展一个文字將倍增使这个项为“真”的输入组合的数目(在二元布尔代数中)。 如上例中，将xyz扩展为xy或yz不影响f的结果。

布尔函数的所有素蕴涵项的总和叫做这个函数的**完全和**。

## 参见

  - [Quine-McCluskey算法](https://zh.wikipedia.org/wiki/Quine-McCluskey算法 "wikilink")
  - [规范形式 (布尔代数)](../Page/规范形式_\(布尔代数\).md "wikilink")

[Category:布尔代数](https://zh.wikipedia.org/wiki/Category:布尔代数 "wikilink")
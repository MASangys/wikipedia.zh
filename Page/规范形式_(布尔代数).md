> 本文内容由[规范形式 \(布尔代数\)](https://zh.wikipedia.org/wiki/规范形式_\(布尔代数\))转换而来。


[布尔代数](../Page/布尔代数.md "wikilink")中，由标准[逻辑运算符](../Page/逻辑运算符.md "wikilink")组成的[布尔函数](../Page/布尔函数.md "wikilink")可以按利用了对偶性“极小项”和“极大项”的概念的**规范形式**来表达。

## 极小项

我们首先开始于定义**极小项(minterm)**为只由[逻辑与和补运算符组成的](https://zh.wikipedia.org/wiki/逻辑合取 "wikilink") *n* 个变量的逻辑表达式。

例如，下列是极小项的例子:

  -
    *a* *b*'*c*
    *a*' *b* *c*

*n* 个变量有 2<sup>*n*</sup> 个极小项 - 这是因为在极小项表达式中一个变量要么是自身要么是它的补的形式 - *n* 个变量每个都有两种选择。

### 索引极小项

一般的，你可以指派给每个极小项(确保以同样的次序写变量，通常按字母序)，基于极小项的二进制值的一个索引。一个补项*a*' 被当作二进制的 0，而一个非补项如 *a* 被当作二进制 1。例如，你可以对 *a* *b* *c*'(110<sub>2</sub>) 关联上数字 6，并把极小项表达式写为 *m*<sub>6</sub>。所以三个变量的 *m*<sub>0</sub> 是 *a*'*b*'*c*'(000<sub>2</sub>)，而 *m*<sub>7</sub> 是 *a* *b* *c*(111<sub>2</sub>)。

### 函数等价

明显的，极小项 *n* 对这个逻辑函数的第 *n*+1 个唯一的函数输入给出真值。例如，极小项 5，*a* *b*' *c*，只在 *a* 和 *c* 都为真而 *b* 为假的时候是真的 - 输入为 a = 1, b = 0, c = 1 得到 1。

如果你给出一个逻辑函数的[真值表](../Page/真值表.md "wikilink")，就可以把这个函数写为"积之和"(由极小项[OR起来的序列](https://zh.wikipedia.org/wiki/逻辑析取 "wikilink"))。这是[析取范式的特殊形式](https://zh.wikipedia.org/wiki/析取范式 "wikilink")。例如，如果给出真值表

*`a`*` `*`b`*`  `*`f`*`(`*`a`*`, `*`b`*`)`
`0 0  1`
`0 1  0`
`1 0  1`
`1 1  0`

观察到输出为 1 的行是第一行和第三行，所以我们可以把 *f* 写为极小项 *m*<sub>0</sub> 和 *m*<sub>2</sub> 的和。

如果我们要验证它:

  -
    *f*(*a*,*b*) = *m*<sub>0</sub> + *m*<sub>2</sub> = (*a*'*b*')+(*ab*')

通过直接计算，结果和这个函数的真值表是一样的。

## 极大项

**极大项**是极小项想法的对偶。不再使用 AND 和补运算，我们转而使用 OR 和补运算，处理是类似的。

例如，下面是极大项的例子:

  -
    *a*+*b*'+*c*
    *a*'+*b*+*c*

*n* 个变量也有 2<sup>*n*</sup> 个极大项 - 这是因为在极大项表达式中一个变量要么是自身要么是它的补的形式 - *n* 个变量每个都有两种选择。

### 索引极大项

索引极大项是同极小项相反的方式完成的。你可以指派给每个最大项(确保以同样的次序写变量，通常按字母序)，基于项的补的次序的一个索引，例如，对 *a*'+*b*'+*c* 关联上数字 6，而写为 *M*<sub>6</sub>。所以三个变量的 *M*<sub>0</sub> 现在是 *a*+*b*+*c* 而 *M*<sub>7</sub> 是 *a*'+*b*'+*c*'.

### 对偶化

可以轻易的使用[德·摩根定律验证](https://zh.wikipedia.org/wiki/德·摩根定律 "wikilink")，极小项的补是各自补的极大项。例如

  -
    *m*<sub>2</sub>' = M<sub>2</sub>
    (*a*+*b*')'= *a*'*b*

### 函数等价

明显的，极大项 *n* 现在对这个逻辑函数的第 *n*+1 个唯一的函数输入给出*假*值。例如，极大项 5，*a*'+*b*+*c*'，只在 *a* 和 *c* 都为真而 b 为假的时候是假的 - 输入为 a = 1, b = 0, c = 1 得到 0。

如果你给出一个逻辑函数的[真值表](../Page/真值表.md "wikilink")，就可以把这个函数写为"和之积" (由极大项[AND起来的序列](https://zh.wikipedia.org/wiki/逻辑合取 "wikilink"))。它是[合取范式](../Page/合取范式.md "wikilink")的特殊形式。例如，如果给出真值表

*`a`*` `*`b`*`  `*`f`*`(`*`a`*`, `*`b`*`)`
`0 0  1`
`0 1  0`
`1 0  1`
`1 1  0`

观察到输出为 0 的行是第二行和第四行，所以我们可以把 *f* 写为极大项 *M*<sub>1</sub> 和 *M*<sub>3</sub> 的积。

如果我们要验证它:

  -
    *f*(*a*,*b*) = *M*<sub>1</sub> *M*<sub>3</sub> = (*a*+*b*')(*a*'+*b*')

通过直接计算，结果和这个函数的真值表是一样的。

## 结果总结

所以逻辑函数都可以用规范形式表达，要么是"极小项之和"要么是"极大项之积"的形式。除了可以用直接和简单的代数形式表达复杂的逻辑函数之外，它还允许把这些函数强力分析成最简化的形式，这对于数字电路的最小化是非常重要的。

## 参见

  - [布尔代数主题列表](https://zh.wikipedia.org/wiki/布尔代数主题列表 "wikilink")
  - [Quine-McCluskey算法](https://zh.wikipedia.org/wiki/Quine-McCluskey算法 "wikilink")
  - [合取范式](../Page/合取范式.md "wikilink")
  - [析取范式](https://zh.wikipedia.org/wiki/析取范式 "wikilink")

[Category:布尔代数](https://zh.wikipedia.org/wiki/Category:布尔代数 "wikilink")
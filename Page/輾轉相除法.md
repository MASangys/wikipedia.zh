[Euclidean_algorithm_252_105_animation_flipped.gif](https://zh.wikipedia.org/wiki/File:Euclidean_algorithm_252_105_animation_flipped.gif "fig:Euclidean_algorithm_252_105_animation_flipped.gif")長分别可表示252和105，則其中每一小分段長代表最大公因數21。如动画所示，只要輾轉地从大数中减去小数，直到其中一段的长度为0，此时剩下的一条线段的长度就是252和105的最大公因数。\]\]

在[数学中](../Page/数学.md "wikilink")，**辗转相除法**，又称**欧几里得算法**（），是求[最大公约数的](https://zh.wikipedia.org/wiki/最大公约数 "wikilink")[算法](../Page/算法.md "wikilink")。辗转相除法首次出现于[欧几里得的](../Page/欧几里得.md "wikilink")《[几何原本](../Page/几何原本.md "wikilink")》（第VII卷，命题i和ii）中，而在[中国则可以追溯至](https://zh.wikipedia.org/wiki/中国 "wikilink")[东汉出现的](../Page/东汉.md "wikilink")《[九章算术](../Page/九章算术.md "wikilink")》。

两个[整数的最大](../Page/整数.md "wikilink")[公约数是能够同时](https://zh.wikipedia.org/wiki/公约数 "wikilink")[整除它们的最大的正整数](https://zh.wikipedia.org/wiki/整除 "wikilink")。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数的差的最大公约数。例如，252和105的最大公约数是21（\(252=21\times12;105=21\times5\)）；因为，所以147和105的最大公约数也是21。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。由辗转相除法也可以推出，两数的最大公约数可以用两数的整数倍相加来表示，如。这个重要的結論叫做[貝祖定理](../Page/貝祖等式.md "wikilink")。

辗转相除法最早出现在欧几里得的《几何原本》中（大约[公元前](https://zh.wikipedia.org/wiki/公元前 "wikilink")300年），所以它是现行的算法中歷史最悠久的。这个算法原先只用来处理[自然数和几何长度](../Page/自然数.md "wikilink")（相當於正[實數](https://zh.wikipedia.org/wiki/實數 "wikilink")），但在19世纪，辗转相除法被推广至其他类型的數學對象，如[高斯整数和一元](https://zh.wikipedia.org/wiki/高斯整数 "wikilink")[多项式](https://zh.wikipedia.org/wiki/多项式 "wikilink")。由此，引申出[欧几里得整环等等的一些现代](https://zh.wikipedia.org/wiki/欧几里得整环 "wikilink")[抽象代数概念](../Page/抽象代数.md "wikilink")。后来，辗转相除法又扩展至其他数学领域，如[纽结理论和](https://zh.wikipedia.org/wiki/纽结理论 "wikilink")[多元多项式](https://zh.wikipedia.org/wiki/多項式#定義 "wikilink")。

辗转相除法有很多应用，它甚至可以用来生成全世界不同文化中的传统音乐节奏。\[1\]在现代[密码学方面](../Page/密码学.md "wikilink")，它是[RSA算法](https://zh.wikipedia.org/wiki/RSA算法 "wikilink")（一种在[电子商务中广泛使用的](../Page/电子商务.md "wikilink")[公钥加密算法](https://zh.wikipedia.org/wiki/公钥加密 "wikilink")）的重要部分。它还被用来解[丢番图方程](https://zh.wikipedia.org/wiki/丢番图方程 "wikilink")，比如寻找满足[中国剩余定理的数](../Page/中国剩余定理.md "wikilink")，或者求[有限域中](../Page/有限域.md "wikilink")[元素的](../Page/元素_\(數學\).md "wikilink")[逆](../Page/逆元素.md "wikilink")。辗转相除法还可以用来构造[连分数](../Page/连分数.md "wikilink")，在[施图姆定理和一些](../Page/施图姆定理.md "wikilink")[整数分解算法中也有应用](../Page/整数分解.md "wikilink")。辗转相除法是现代[数论中的基本工具](../Page/数论.md "wikilink")。

辗转相除法处理大数时非常高效，如果用除法而不是减法实现，它需要的步骤不会超过较小数的位数（[十进制下](../Page/十进制.md "wikilink")）的五倍。[拉梅于](https://zh.wikipedia.org/wiki/拉梅 "wikilink")1844年证明了这点，同時這也標誌著[计算复杂性理论的開端](https://zh.wikipedia.org/wiki/计算复杂性理论 "wikilink")。

## 背景

### 最大公约数

欧几里得的辗转相除法计算的是两个[自然数](../Page/自然数.md "wikilink")*a*和*b*的最大公约数*g*，意思是能够同时整除*a*和*b*的自然数中最大的一个。两个数的最大公约数通常写成GCD(*a*,
*b*)，或者简写成(*a*,
*b*)\[2\]，但是第二种写法也被使用在其他数学概念，如[二维](https://zh.wikipedia.org/wiki/二维 "wikilink")[向量的坐标](../Page/向量.md "wikilink")。

如果GCD(*a*, *b*) = 1，則稱*a*和*b*[互素](https://zh.wikipedia.org/wiki/互素 "wikilink")。\[3\]*a*和*b*是否互素和它们是否[素数无关](../Page/素数.md "wikilink")。\[4\]如，6和35都不是素数，因为它们都可以分解为多于一个素因数的乘积：6
= 2 × 3，35 = 5 × 7。但是，6和35互素，因为除了1以外没有自然数同时整除6和35。

[Square_tiling_24x60.svg](https://zh.wikipedia.org/wiki/File:Square_tiling_24x60.svg "fig:Square_tiling_24x60.svg")

令*g* = GCD(*a*, *b*)。由于*a*和*b*都是*g*的整数倍，所以可以写成*a* = *mg*、*b* =
*ng*，并且不存在更大的整数*G* \>
*g*使等式成立。为了使*g*尽可能大，就要使*a*和*b*中所有公约数都提取出来归入*g*中，所以自然数*m*和*n*一定互素，并且*a*和*b*的最大公约数*g*可以被*a*和*b*的所有其他公因数*c*整除。\[5\]

我们可以用右图来解释最大公约数的概念：\[6\]設一个长方形的边长为*a*和*b*。因为*a*和*b*的任何公约数*c*都可以整除*a*和*b*，所以长方形的边都可以等分为长度为*c*的线段，也就是长方形可以被边长为*c*的正方形正好填满。而最大公约数*g*是所有可能的*c*中最大的一个。例如，一个24
× 60的长方形区域可以分成1 × 1、2 × 2、3 × 3、6 × 6或12 × 12的正方形网格。也就是说，12是24和60的最大公约数。

*a*和*b*的最大公约数是两数共有的素因数的乘积。\[7\]例如，462可以分解成2 × 3 × 7 × 11；1071可以分解成3 × 3 × 7 × 17。462和1071的最大公约数等于它们共有的素因数的乘积3 × 7 = 21。如果两数没有公共的素因数，那么它们的最大公约数是1，也即这两个数互素。辗转相除法的优点就在於它能以有系統的方式求出兩數的最大公约数，而無需分別對它們作因式分解。\[8\]\[9\]大数的[素因数分解被認為是一個困難的問題](https://zh.wikipedia.org/wiki/素因数分解 "wikilink")，即使是现代的计算机也非常难於處理，所以许多加密系统的原理都是建基於此。\[10\]

在数学中，尤其是[抽象代数的](../Page/抽象代数.md "wikilink")[环论中](../Page/环论.md "wikilink")，最大公约数有一个更加巧妙的定义：\[11\]*a*和*b*的最大公约数*g*是*a*和*b*的线性和中的最小正整數，即所有形如*ua* + *vb*（其中*u*和*v*是整数）的数中的最小正整数。可以證明，所有*ua* + *vb*都是*g*的整数倍（*ua* + *vb*
=
*mg*，其中*m*是整数）。用现代数学语言來說，*a*和*b*生成的[理想即是由](../Page/理想_\(环论\).md "wikilink")*g*生成的[主理想](https://zh.wikipedia.org/wiki/主理想 "wikilink")。最大公约数的这个定义和其他定义的等价性将在下面描述。

三个数的最大公约数的定义和两个数的相同，即是它们共有的素因数的积\[12\]，它们或者也可以按下式计算\[13\]：

  -

所以，欧几里得的辗转相除法实际可以计算任意多整数的最大公约数。

### 归纳、递归和无穷递降

下文的論證會用到三種相關的数学方法，分別是[数学归纳法](../Page/数学归纳法.md "wikilink")、[递归和](../Page/递归.md "wikilink")[无穷递降](https://zh.wikipedia.org/wiki/无穷递降 "wikilink")。数学归纳法\[14\]经常用来证明某個定理對所有[自然数成立](../Page/自然数.md "wikilink")：\[15\]首先证明定理对一个特定的数*n*<sub>0</sub>成立（通常是1）；然后證明如果定理对自然数*n*成立的話，那麼它对自然数*n* + 1成立。這樣，便可證明定理对所有大于*n*<sub>0</sub>的自然数也成立。递归\[16\]是将相关的数组成一个[数列](../Page/数列.md "wikilink")(*a*<sub>1</sub>, *a*<sub>2</sub>, *a*<sub>3</sub>...)，\[17\]當中除初始項外，其中每一项都用前一项或前几项表示。如[斐波那契数列就是递归的](../Page/斐波那契数列.md "wikilink")，每一项*F*<sub>*n*</sub>都等于*F*<sub>*n*−1</sub> + *F*<sub>*n*−2</sub>（n≧2）。辗转相除法中的一些等式也是递归的。最后，无穷递降\[18\]是用方程的一个自然数解导出比它小的自然数解。\[19\]但是，这种转化不能永远进行下去，因为只有有限個小於原來的自然数解的自然数。所以，要麼方程無解，不然在有限步内必然能得出最小的自然數解。在下文會用到此法來证明辗转相除法一定会在有限步内结束。

## 算法描述

### 计算过程

辗转相除法是一种[递归算法](../Page/递归.md "wikilink")，每一步计算的输出值就是下一步计算时的输入值。\[20\]设*k*表示步骤数（从0开始计数），算法的计算过程如下。

每一步的输入是都是前两次计算的非負余数*r*<sub>*k*−1</sub>和*r*<sub>*k*−2</sub>。因为每一步计算出的余数都在不断减小，所以，*r*<sub>*k*−1</sub>小于*r*<sub>*k*−2</sub>。在第*k*步中，算法计算出满足以下等式的[商](https://zh.wikipedia.org/wiki/商 "wikilink")*q*<sub>*k*</sub>和[余数](../Page/余数.md "wikilink")
*r*<sub>*k*</sub>：

  -

其中0 ≤
*r*<sub>*k*</sub> \< *r*<sub>*k*−1</sub>。也就是*r*<sub>*k*−2</sub>要不断减去*r*<sub>*k*−1</sub>直到比*r*<sub>*k*−1</sub>小。

為求簡明，以下只說明如何求兩個非負整數*a*和*b*的最大公約數（負數的情況是簡單的）。在第一步计算时（*k* = 0），设*r*<sub>−2</sub>和*r*<sub>−1</sub>分别等于*a*和*b*，第2步（此时*k* = 1）时计算*r*<sub>−1</sub>（即*b*）和*r*<sub>0</sub>（第一步计算产生的余数）相除产生的商和余数，以此类推。整个算法可以用如下等式表示：

如果有*a* \< *b*，算法的第一步實際上會把兩個數字交換，因為這時*a*除以*b*所得的商*q*<sub>0</sub>會等于0，余数*r*<sub>0</sub>則等于*a*。然後，算法的第二步便是把*b*除以*a*，再計算所得之商和餘數。所以，對於*k*
≥ 0總有*r*<sub>*k*</sub>\<*r*<sub>*k*−1</sub>，即运算的每一步中得出的余数一定小于上一步计算的余数。

由于每一步的余数都在减小并且不为负数，必然存在第*N*步时*r*<sub>*N*</sub>等于0，使算法终止\[21\]，*r*<sub>*N*−1</sub>就是*a*和*b*的最大公约数。其中*N*不可能无穷大，因为在*r*<sub>0</sub>和0之间只有有限个自然数。

### 正确性的证明

辗转相除法的正确性可以分成两步来证明。\[22\]在第一步，我們會證明算法的最终结果*r*<sub>*N*−1</sub>同时整除*a*和*b*。因为它是一个公约数，所以必然小于或者等于最大公约数*g*。在第二步，我們證明*g*能整除*r*<sub>*N*−1</sub>。所以*g*一定小于或等于*r*<sub>*N*−1</sub>。两个不等式只在*r*<sub>*N*−1</sub> = *g*是同时成立。具体证明如下：

因为第一步的证明告诉我们*r*<sub>*N*−1</sub> ≤ *g*，所以*g* = *r*<sub>*N*−1</sub>。即：\[23\]\[24\]

  -

### 举例

[Euclidean_algorithm_1071_462.gif](https://zh.wikipedia.org/wiki/File:Euclidean_algorithm_1071_462.gif "fig:Euclidean_algorithm_1071_462.gif")

例如，计算*a* = 1071和*b* = 462的最大公约数的过程如下：从1071中不断减去462直到小于462（可以减2次，即商*q*<sub>0</sub> = 2），余数是147：

  -

然后从462中不断减去147直到小于147（可以减3次，即*q*<sub>1</sub> = 3），余数是21：

  -

再从147中不断减去21直到小于21（可以减7次，即*q*<sub>2</sub> = 7），没有余数：

  -

此时，余数是0，所以1071和462的最大公约数是21，这和用素因数分解得出的结果相同（见[上文](https://zh.wikipedia.org/wiki/#最大公约数 "wikilink")）用表格表示如下：

| 步骤数 | 算式                                           | 商和余数                                          |
| --- | -------------------------------------------- | --------------------------------------------- |
| 0   | 1071 = 462 *q*<sub>0</sub> + *r*<sub>0</sub> | *q*<sub>0</sub> = 2、*r*<sub>0</sub> = 147     |
| 1   | 462 = 147 *q*<sub>1</sub> + *r*<sub>1</sub>  | *q*<sub>1</sub> = 3、*r*<sub>1</sub> = 21      |
| 2   | 147 = 21 *q*<sub>2</sub> + *r*<sub>2</sub>   | *q*<sub>2</sub> = 7、*r*<sub>2</sub> = 0（算法终止） |

### 图形演示

辗转相除法的计算过程可以用图形演示。\[25\]假设我们要在*a*×*b*的[矩形地面上铺](../Page/矩形.md "wikilink")[正方形瓷砖](../Page/正方形.md "wikilink")，并且正好铺满，其中*a*大于*b*。我们先尝试用*b*×*b*的瓷砖，但是留下了*r*<sub>0</sub>×*b*的部分，其中*r*<sub>0</sub>\<*b*。我们接着尝试用*r*<sub>0</sub>×*r*<sub>0</sub>的正方形瓷砖铺，又留下了*r*<sub>1</sub>×*r*<sub>0</sub>的部分，然后再使用*r*<sub>1</sub>×*r*<sub>1</sub>的正方形铺……直到全部铺满为止，即到某步时正方形刚好覆盖剩余的面积为止。此时用到的最小的正方形的边长就是原来矩形的两条边长的最大公约数。在图中，最小的正方形面积是21×21（），而原先的矩形（）边长是1071×462，所以21是1071和462的最大公约数。

### 计算商和余数

在每个步骤*k*中，辗转相除法都需要计算两个数*r*<sub>*k*−1</sub>和*r*<sub>*k*−2</sub>的商*q*<sub>*k*</sub>和余数*r*<sub>*k*</sub>：

  -

其中0 ≤
*r*<sub>*k*</sub> \< *r*<sub>*k*−1</sub>。除法的算法保证这样的商和余数总是存在。自然数的除法算法还指出这样的商和余数是惟一的，但这对辗转相除法而言并非必要。\[26\]

在欧几里得最初的描述中，商和余数是通过连续的减法来计算的，即从*r*<sub>*k*−2</sub>中不断减去*r*<sub>*k*−1</sub>直到小于*r*<sub>*k*−1</sub>。一個更高效的做法是使用整數除法和模除来计算商和余数：

  -

### 计算机实现

辗转相除法可用[伪代码表示](../Page/伪代码.md "wikilink")，比如除法版本可以寫成\[27\]

**`function`**` gcd(a, b)`
`    `**`while`**` b ≠ 0`
`        t ← b`
`        b ← a `**`mod`**` b`
`        a ← t`
`    `**`return`**` a`

c++版本：

``` c++ numberLines
int gcd(int m,int n)
{
        int t = 1;
        while(t != 0)
        {
                t=m%n;
                m=n;
                n=t;
        }
        return m;
}
```

Python3版本：

``` python3 numberLines
def gcd(a, b):
    while b != 0:
        t = a % b
        a = b
        b = t
    return a
```

在第*k*次循环开始时，变量*b*的值是前一次运算的余数*r*<sub>*k*−1</sub>，变量*a*的值是再前一次运算的余数*r*<sub>*k*−2</sub>。步骤*b*
:= *a* mod *b*的作用等同于递归式*r*<sub>*k*</sub> ≡ *r*<sub>*k*−2</sub> mod
*r*<sub>*k*−1</sub>。变量*t*的功能是在下一个余数*r*<sub>*k*</sub>计算过程中临时性地保存*r*<sub>*k*−1</sub>的值。在一次循环结束时，变量*b*的值是前一次运算的余数*r*<sub>*k*</sub>，变量*a*的值是再前一次运算的余数*r*<sub>*k*−1</sub>。

在欧几里得定义的减法版本，取餘运算被减法替换。\[28\]

**`function`**` gcd(a, b)`
`    `**`if`**` a = 0`
`       `**`return`**` b`
`    `**`while`**` b ≠ 0`
`        `**`if`**` a > b`
`           a ← a − b`
`        `**`else`**
`           b ← b − a`
`    `**`return`**` a`

变量*a*和*b*的值分别是前两次的余数*r*<sub>*k*−1</sub>和*r*<sub>*k*−2</sub>。假定第*k*次循环开始时*a*大于*b*，那么*a*等于*r*<sub>*k*−2</sub>，因为*r*<sub>*k*−2</sub>
\>
*r*<sub>*k*−1</sub>。在循环过程中，*a*重复减去*b*直到比*b*小，此时*a*就是下一个余数*r*<sub>*k*</sub>；然后*b*重复减去*a*直到比*a*小，此时*b*就是下一个余数*r*<sub>*k*+1</sub>；重复执行直到*b*
= 0。

以下是[递归版本](../Page/递归.md "wikilink")\[29\]：

**`function`**` gcd(a, b)`
`    `**`if`**` b = 0`
`       `**`return`**` a`
`    `**`else`**
`       `**`return`**` gcd(b, a `**`mod`**` b)`

c++[递归版本如下](../Page/递归.md "wikilink")：

``` c++ numberLines
int gcd(int n,int m)
{
        if(m==0)
                return n;
        else
                return gcd(m,n%m);
}
```

Python3版本：

``` python3 numberLines
def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)
```

例如GCD(1071, 462)的计算过程是：函数的第一次调用计算GCD(462, 1071 mod 462) = GCD(462, 147)；下一次调用计算GCD(147, 462 mod 147) = GCD(147, 21)，在接下来是GCD(21, 147 mod 21) = GCD(21, 0) = 21。

### 使用绝对值最小的余数

在另一个版本的算法中，每一步还要把取余运算时计算出的商增加一后再重新计算余数（此时计算出的余数应该是负的），然后取两个余数的绝对值较小的数作为下一步运算时使用的余数。\[30\]\[31\]取余运算后，设*r*<sub>*k*</sub>是计算出的余数（此時為正），*q*是计算出的商：

  -

即假設。然後使用以下式子计算出一个负的余数*e*<sub>*k*</sub>：

  -

如果|*e*<sub>*k*</sub>| \< |*r*<sub>*k*</sub>|，那么用*e*<sub>*k*</sub>替换*r*<sub>*k*</sub>进行下一次运算。如[利奥波德·克罗内克所指出的](../Page/利奥波德·克罗内克.md "wikilink")，这个版本需要的运算步骤是欧几里得算法的所有版本中最少的。\[32\]\[33\]

## 历史发展

[Euklid.jpg](https://zh.wikipedia.org/wiki/File:Euklid.jpg "fig:Euklid.jpg")之前几个世纪就已经有了。图为使用两脚规进行测量。\]\]

辗转相除法是目前仍然在使用的历史最悠久的算法之一。\[34\]它首次出现于《[几何原本](../Page/几何原本.md "wikilink")》（卷7命题1–2、卷10命题2–3）（大约公元前300年）。在卷7中用于整数，在卷10中用于线段的长度（以現代的觀點看，线段的长度可視為正实数，也就是說辗转相除法實際可用於實數上，但是当时未有实数的概念）。卷10中出现的算法是几何的，两段线段*a*和*b*的最大公约数是*a*和*b*的[公度中的最大值](../Page/通約性.md "wikilink")。

这个算法可能并非[欧几里得发明](../Page/欧几里得.md "wikilink")，因為他也有将先前其他數學家的一些成果编进他的《几何原本》。\[35\]\[36\]数学家、历史学家认为卷7的内容可能来自[毕达哥拉斯学院出身的数学家写的关于](../Page/毕达哥拉斯.md "wikilink")[数论的教科书](../Page/数论.md "wikilink")。\[37\]辗转相除法在當時很可能已為[尤得塞斯](https://zh.wikipedia.org/wiki/尤得塞斯 "wikilink")（大約公元前375年）所知
\[38\]\[39\]，甚至可能更早之前就已经存在\[40\]\[41\]，因为欧几里得和[亚里士多德的著作中都出现了](../Page/亚里士多德.md "wikilink")一词（意为“辗转相减”）。\[42\]

几个世纪之后，辗转相除法又分别被[中国人和](https://zh.wikipedia.org/wiki/中国 "wikilink")[印度人独立发现](../Page/印度.md "wikilink")，\[43\]主要用来解天文学中用到的[丢番图方程以及制定准确的历法](https://zh.wikipedia.org/wiki/丢番图方程 "wikilink")。5世纪末，印度[数学家](../Page/数学家.md "wikilink")、[天文学家](../Page/天文学家.md "wikilink")[阿里亚哈塔曾稱辗转相除法为](https://zh.wikipedia.org/wiki/阿里亚哈塔 "wikilink")“粉碎机”，這可能是因为它在解[丢番图方程时很有效](https://zh.wikipedia.org/wiki/丢番图方程 "wikilink")\[44\]。\[45\]在中国，《[九章算术](../Page/九章算术.md "wikilink")》中提到了一种类似辗转相减法的“更相减损术”\[46\]。《[孙子算经](../Page/孙子算经.md "wikilink")》中則出现了[中国剩余定理的一个特例](../Page/中国剩余定理.md "wikilink")\[47\]，但是直到1247年[秦九韶才於其](../Page/秦九韶.md "wikilink")《[数学九章](https://zh.wikipedia.org/wiki/数学九章 "wikilink")》中解答了該定理的一般情況，當中用到了他發明的[大衍求一术](../Page/大衍求一术.md "wikilink")。此法的其中一部分實際上便是輾轉相除的原理，秦九韶在書中對此有明確表述。\[48\]在欧洲，辗转相除法首次出现于的著作《愉悦讨喜的问题》（**）的第二版\[49\]在欧洲，辗转相除法被用于丢番图方程和構建[连分数](../Page/连分数.md "wikilink")。后来，英国数学家在其著作中收編了[扩展欧几里得算法](../Page/扩展欧几里得算法.md "wikilink")，作为一個有效计算连分数的方法。他將此法的來源歸名於。\[50\]

19世纪，辗转相除法促成了新[数系的建立](https://zh.wikipedia.org/wiki/数系 "wikilink")，如[高斯整数和](https://zh.wikipedia.org/wiki/高斯整数 "wikilink")[艾森斯坦整数](../Page/艾森斯坦整数.md "wikilink")。1815年，[高斯用辗转相除法证明高斯整数的分解是惟一的](https://zh.wikipedia.org/wiki/高斯 "wikilink")，儘管他的研究到了1832年才首度发表。\[51\]高斯在他的《[算数研究](https://zh.wikipedia.org/wiki/算数研究 "wikilink")》（出版于1801年）中實際上也有援引这个算法，但僅是以[连分数方法的形式敘述](../Page/连分数.md "wikilink")。\[52\][约翰·狄利克雷是第一个将辗转相除法作为数论的基础的数学家](https://zh.wikipedia.org/wiki/约翰·彼得·古斯塔夫·勒热纳·狄利克雷 "wikilink")。狄利克雷提出，数论中的很多结论，如分解的惟一性，在任何使辗转相除法適用的数系中均有效。\[53\]狄利克雷的數論講義後來經[理查德·戴德金編輯和推广](https://zh.wikipedia.org/wiki/理查德·戴德金 "wikilink")，戴德金也有以辗转相除法來研究[代数整数](https://zh.wikipedia.org/wiki/代数整数 "wikilink")。比如，他是第一个用高斯整数的分解惟一性证明[费马平方和定理的数学家](../Page/费马平方和定理.md "wikilink")。\[54\]戴德金还率先定义了[欧几里得整环的概念](https://zh.wikipedia.org/wiki/欧几里得整环 "wikilink")。19世纪末，戴德金所定義的[理想概念使得數論的重心不必建基於輾轉相除法](../Page/理想_\(环论\).md "wikilink")，從而促進了理論的發展。\[55\]

|                                                                                                                 |
| --------------------------------------------------------------------------------------------------------------- |
| “欧几里得算法是所有算法的鼻祖，因为它是现存最古老的非凡算法。”                                                                                |
| ——[高德纳](../Page/高德纳.md "wikilink")，《[计算机程序设计艺术](../Page/计算机程序设计艺术.md "wikilink")，第二卷：半数值算法》，第二版 (1981), p. 318. |

辗转相除法的其他应用发展于19世纪。1829年，[施图姆将辗转相除法用于](../Page/雅克·夏尔·弗朗索瓦·施图姆.md "wikilink")[施图姆序列](../Page/施图姆定理.md "wikilink")（用于确定多项式的不同实根的个数的方法）。\[56\]

辗转相除法是历史上第一个，即寻找两個[可通約實數的整数关系的算法](../Page/通約性.md "wikilink")。近年来，出现了一些新颖的整数关系算法，如和福尔卡德于1979年发表的[弗格森-福尔卡德算法](https://zh.wikipedia.org/wiki/弗格森-福尔卡德算法 "wikilink")（Ferguson–Forcade
algorithm）
\[57\]、以及与它相关的、[HJLS算法以及](https://zh.wikipedia.org/wiki/HJLS算法 "wikilink")[PSLQ算法](https://zh.wikipedia.org/wiki/PSLQ算法 "wikilink")。\[58\]\[59\]

1969年，科尔（Cole）和戴维（Davie）基于辗转相除法创造了一种二人游戏，叫做「欧几里得游戏」。\[60\]这个游戏有最优策略。\[61\]游戏开始于两列分别为*a*和*b*个棋子组成的序列，玩家轮流从较长一列中取走较短一列棋子数量的*m*倍的棋子。如果两列棋子*p*和*q*分别由*x*和*y*个棋子组成，其中*x*大于*y*，那么玩家可以將序列*p*的棋子数量减少为自然数*x*
− *my*。最后率先将一列棋子清空的玩家胜出。\[62\]\[63\]

## 数学上的应用

### 贝祖等式

[贝祖等式说明](https://zh.wikipedia.org/wiki/贝祖等式 "wikilink")，两个数*a*和*b*的最大公约数*g*可以表示为*a*和*b*的线性和。\[64\]也就是说，存在整数*s*和*t*使*g* = *sa* + *tb*。\[65\]\[66\]

整数*s*和*t*可以从辗转相除法算出的商*q*<sub>0</sub>、*q*<sub>1</sub>……计算出。\[67\]
从辗转相除法的最后一步开始，*g*可以表示成前一步的商*q*<sub>*N*−1</sub>和前两步的余数*r*<sub>*N*−2</sub>和*r*<sub>*N*−3</sub>：

  -

而前两步的余数又分别可以表示成它们前两步的余数和商：
将这两行式子先後代入第一个式子，可以将*g*表示成*r*<sub>*N*−4</sub>和*r*<sub>*N*−5</sub>的线性和。重复进行迭代直到出现*a*和*b*：

最终，*g*可以表示成*a*和*b*的线性和：*g* = *sa* + *tb*。[贝祖等式以及以上证明都可以扩展至](https://zh.wikipedia.org/wiki/贝祖等式 "wikilink")[欧几里得整环](https://zh.wikipedia.org/wiki/欧几里得整环 "wikilink")。

### 主理想和相关问题

贝祖等式提供了另一种定义*a*和*b*的最大公约数*g*的方法。\[68\]考虑形如*ua* + *vb*（其中*u*和*v*是整数）的数的[集合](../Page/集合_\(数学\).md "wikilink")。因为*a*和*b*都可以被*g*整除，所以这个集合中的所有元素都可以被*g*整除。也就是说这个集合中的数都可以表示成*g*的倍数，或者*a*和*b*的其他公约数的倍数。但是，只有最大公约数才是这个集合的元素。根据贝祖等式，有*g* = *sa* + *tb*。換言之，当*u* = *s*、*v* = *t*时得出*g*。任何其他的公约数都不是这个集合的元素，因为它们都不能被比它们大的*g*整除。相反地，*g*的任何倍数都属于这个集合，只要令*u* = *ms*、*v* = *mt*，便有：

  -

所以，形如*ua* + *vb*的数的集合等于*g*的整数倍的集合。也就是说，任意两个数的线性和的集合等同于它们最大公约数的整数倍的集合。*a*和*b*的最大公约数叫做*a*和*b*的[理想的生成元素](../Page/理想_\(环论\).md "wikilink")。这个最大公约数的定义导出了兩個现代[抽象代数的概念](../Page/抽象代数.md "wikilink")：[主理想](https://zh.wikipedia.org/wiki/主理想 "wikilink")（由单个元素生成的理想）以及[主理想整环](https://zh.wikipedia.org/wiki/主理想整环 "wikilink")（其每一理想都是主理想的[整环](../Page/整环.md "wikilink")）。

这个结果可以解决某些實際问题。\[69\]例如，考虑两个容积分别为*a*和*b*的量杯，其中*a*和*b*為正整數。通过加入或倒去*u*倍第一个量杯的体积以及*v*倍第二个量杯的体积的液体，任何体积为*ua* + *vb*的液体都可以被量出（只要*ua* + *vb*為正數）。根據贝祖等式，凡是可以被量出的液体，其体积一定是*a*和*b*的最大公约数*g*的倍數。

### 扩展欧几里得算法

[贝祖等式的整数](https://zh.wikipedia.org/wiki/贝祖等式 "wikilink")*s*和*t*可以通过[扩展欧几里得算法算出](../Page/扩展欧几里得算法.md "wikilink")。这个扩展算法在原有辗转相除法的基础上增加了两个递归等式：\[70\]
 算法开始时：
加上这兩个递归式后，当算法终止于*r*<sub>*N*</sub> = 0，贝祖等式的整数*s*和*t*分别由*s*<sub>*N*</sub>和*t*<sub>*N*</sub>给出。

这个算法的正确性可以用数学归纳法来证明。假设递归至第*k*−1步是正确的，也就是假设：

  -

在*j*小于*k*時皆成立。则第*k*步运算得出以下等式：

  -

因为*r*<sub>*k*−2</sub>和*r*<sub>*k*−1</sub>被假定是正确的，所以可以用*s*和*t*表示：

  -

整理后得到第*k*步的结果，和我们期望得到的结果一致：

  -

### 矩阵法

整数*s*和*t*也可以用[矩阵运算得出](../Page/矩阵.md "wikilink")。\[71\]辗转相除法的计算过程：
可以写作2×2的商矩阵乘以一个2维余数向量：

\[\begin{pmatrix} a \\ b \end{pmatrix} =
\begin{pmatrix} q_{0} & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} b \\ r_{0} \end{pmatrix} =
\begin{pmatrix} q_{0} & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} q_{1} & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} r_{0} \\ r_{1} \end{pmatrix} =
\cdots =
\prod_{i=0}^{N} \begin{pmatrix} q_{i} & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} r_{N-1} \\ 0 \end{pmatrix}\]

令**M**表示所有商矩阵的乘积：

\[\mathbf{M} = \begin{pmatrix} m_{11} & m_{12} \\ m_{21} & m_{22} \end{pmatrix} =
\prod_{i=0}^{N} \begin{pmatrix} q_{i} & 1 \\ 1 & 0 \end{pmatrix} =
\begin{pmatrix} q_{0} & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} q_{1} & 1 \\ 1 & 0 \end{pmatrix} \cdots \begin{pmatrix} q_{N} & 1 \\ 1 & 0 \end{pmatrix}\]

这使辗转相除法化简为：

\[\begin{pmatrix} a \\ b \end{pmatrix} =
\mathbf{M} \begin{pmatrix} r_{N-1} \\ 0 \end{pmatrix} =
\mathbf{M} \begin{pmatrix} g \\ 0 \end{pmatrix}\]

如要用*a*和*b*的线性和表示*g*，可將等式两边同时乘以矩阵**M**的[逆矩阵](../Page/逆矩阵.md "wikilink")。\[72\]\[73\]**M**的[行列式等于](../Page/行列式.md "wikilink")(−1)<sup>*N*+1</sup>，因为它等于商矩阵的行列式的乘积，而每一个的行列式都是−1。因为**M**的行列式不为零，最终的余数向量可以利用**M**的逆矩阵解出：

\[\begin{pmatrix} g \\ 0 \end{pmatrix} =
\mathbf{M}^{-1} \begin{pmatrix} a \\ b \end{pmatrix} =
(-1)^{N+1} \begin{pmatrix} m_{22} & -m_{12} \\ -m_{21} & m_{11} \end{pmatrix} \begin{pmatrix} a \\ b \end{pmatrix}\]

由上式可以得出*g* = (−1)<sup>*N*+1</sup> ( *m*<sub>22</sub> *a* −
*m*<sub>12</sub> *b*)。

贝祖等式中的两个整数分别是*s* = (−1)<sup>*N*+1</sup>*m*<sub>22</sub>、*t* = (−1)<sup>*N*</sup>*m*<sub>12</sub>。矩阵法的效率可前文描述的辗转相除法的递归算法是相同的，每一步都有两次乘法和两次加法。

### 欧几里得引理和唯一分解

贝祖等式对辗转相除法的很多应用都很重要，如证明自然数的[唯一分解性质](https://zh.wikipedia.org/wiki/唯一分解 "wikilink")\[74\]假设数字*L*可以写成两个因数*u*和*v*的乘积，即*L* = *uv*。如果另一个数*w*与*u*互素的数也能整除*L*，那么*w*必须整除*v*，证明如下：如果*u*和*w*的最大公约数是1，则根据贝祖等式存在*s*和*t*使

  -

    。

两边都乘以*v*：

  -

因为*w*整除等式右边，所以也应整除等式左边的*v*。这个结果叫做[欧几里得引理](https://zh.wikipedia.org/wiki/欧几里得引理 "wikilink")。\[75\]如果一个素数整除*L*那么它至少整除*L*的一个因数。如果一个数*w*互素于数列*a*<sub>1</sub>、*a*<sub>2</sub>、…、*a*<sub>*n*</sub>
中的每一个数，则*w*也一定互素于它们的乘积*a*<sub>1</sub> × *a*<sub>2</sub> × … × *a*<sub>*n*</sub>。\[76\]

欧几里得引理足以证明每一个自然数的素数分解是惟一的。\[77\]我们用反证法来证明，假设*L*可以分别分解成*m*个素数和*n*个素数，即：

  -

根据假设，每个素数*p*都能整除*L*，因此它必须能够整除某個*q*；因为*q*也是一个素数，所以*p* = *q*。同理，对于每一个*p*都存在一个*q*与它相等。所以两种分解除了顺序不同以外是完全相同的。整数分解的惟一性在数学证明中有很多应用，下文将会提到。

### 线性丢番图方程

[Diophante_Bezout.svg](https://zh.wikipedia.org/wiki/File:Diophante_Bezout.svg "fig:Diophante_Bezout.svg")：9*x* + 12*y* = 483的图像，它的解用蓝点表示。\]\]

[丢番图方程是以](https://zh.wikipedia.org/wiki/丢番图方程 "wikilink")[亚历山大数学家](https://zh.wikipedia.org/wiki/亚历山大 "wikilink")[丢番图的名字命名的一类方程](../Page/丢番图.md "wikilink")，它的解被限制在整数范围。\[78\]关于整数*x*和*y*的线性丢番图方程形如：\[79\]

  -
    \(ax + by = c\)

其中*a*、*b*、*c*是已知整数。这个方程可以写成关于*x*的[同余式](https://zh.wikipedia.org/wiki/同余 "wikilink")：

  -
    \(ax \equiv c \pmod{b}\)

令*g*为*a*和*b*的最大公约数，a、b都能被g整除，故*ax* + *by*能够被*g*整除。所以，*c*一定能够被*g*整除，不然方程就无解。方程两边若同时除以
\(\tfrac {c}{g}\)，方程就变成了贝祖等式：

  -
    \(sa + tb = g\)

其中*s*和*t*可以用扩展欧几里得算法求解。\[80\]所以这个丢番图方程的一个解即是：

  -
    <math>

\\begin{align} x_1 = s ( \\tfrac {c}{g} ) \\\\ y_1 = t ( \\tfrac
{c}{g} ) \\end{align} </math>

总体而言，丢番图方程如果有解，就一定有无数个解。\[81\]只需要考虑两个解 (x<sub>1</sub>, y<sub>1</sub>) 和
(x<sub>2</sub>, y<sub>2</sub>)：

  -
    \(ax_1 + by_1 = c = ax_2 + by_2\)

或者可以写成：

  -
    \(a(x_1 - x_2) = b(y_2 - y_1)\)

所以相邻两个解的*x*之间的差是\(\tfrac {b}{g}\)，*y*之间的差是\(\tfrac {a}{g}\)。这样，所有的解都可以表示成：

  -
    <math>

\\begin{align} x = x_1 - \\tfrac{bt}{g} \\\\ y = y_1 + \\tfrac{at}{g}
\\end{align} </math>

当*t*取遍所有整数时，方程所有的解都可以从 (*x*<sub>1</sub>, *y*<sub>1</sub>) 计算出来。如果限制為正整数解
(*x* \> 0, *y* \> 0)
的话，那么解的数量就可能是有限的。有時候，这种对解的限制使丢番图方程在未知数個數比方程數更多的情况下仍然能有唯一解\[82\]，而在允許實數解的[线性方程组中](../Page/线性方程组.md "wikilink")，这種情況是不可能的。

### 乘法逆和RSA算法

[有限域是一个支持四种运算的数集](../Page/有限域.md "wikilink")。这四种运算也通稱為加法、减法、乘法、除法，跟一般的四則運算有相同的性质，如[交换律](https://zh.wikipedia.org/wiki/交换律 "wikilink")、[结合律和](../Page/结合律.md "wikilink")[分配律](../Page/分配律.md "wikilink")。举例来说，使用[同余可以让](https://zh.wikipedia.org/wiki/同余 "wikilink")13个数字的集合
{0, 1, 2, …, 12}
构成一个有限域。在这个域中，任何数学运算（加减乘除）都归约成13的[模](../Page/模.md "wikilink")，例如
5 × 7 = 35 mod 13 = 9。对于任意素数*p*，都可以定义这种有限域；使用更复杂的方法，也可以对素数*p*的*m*次方定义这样的有限域。有限域也叫做[伽罗瓦域](../Page/埃瓦里斯特·伽罗瓦.md "wikilink")，其缩写為
GF(*p*) 或 GF(*p*<sup> *m*</sup>)。

在这样一个有*m*个数的域中，任何非零元素*a*都存在惟一[乘法逆](https://zh.wikipedia.org/wiki/乘法逆 "wikilink")
*a*<sup>−1</sup>
使*aa*<sup>−1</sup> = *a*<sup>−1</sup>*a* ≡ 1 mod *m*。这可以通过解同余式*ax* ≡ 1 mod *m*
得出，\[83\]或者也可以解与之等价的丢番图方程\[84\]

  -

这个方程可用扩展欧几里得算法解出（参见[上文](https://zh.wikipedia.org/wiki/#线性丢番图方程 "wikilink")）。在[RSA算法中](https://zh.wikipedia.org/wiki/RSA算法 "wikilink")，寻找乘法逆是非常重要的一步，它决定了使用哪个数来解密信息。\[85\]虽然RSA算法不使用域而是使用环，扩展欧几里得算法仍然可以用来求乘法逆。欧几里得算法也被应用于[纠错码](https://zh.wikipedia.org/wiki/纠错码 "wikilink")，例如，它可以代替[Berlekamp–Massey算法解基于有限域的](https://zh.wikipedia.org/wiki/Berlekamp–Massey算法 "wikilink")[BCH码和](../Page/BCH码.md "wikilink")[里德-所罗门码](../Page/里德-所罗门码.md "wikilink")。\[86\]

### 中国剩余定理

辗转相除法也可以用來解线性丢番图方程组。\[87\]如在[中国剩余定理中](../Page/中国剩余定理.md "wikilink")，整数可以表示成被*N*个互素的数*m*<sub>*i*</sub>除留下的余数：\[88\]

  -
    <math>

\\begin{align} x_1 &\\equiv x \\pmod{m_1}\\\\ x_2 &\\equiv x
\\pmod{m_2}\\\\ \\vdots & \\\\ x_N &\\equiv x \\pmod{m_N}
\\end{align} </math>

为了从*x*的*N*个余数*x*<sub>*i*</sub>中确定*x*的值，我们将这些式子组合成单个线性丢番图方程，其中模数*M*是所有模数*m*<sub>*i*</sub>的乘积，然后定义*M*<sub>*i*</sub>如下：

  -
    \(M_i = M / m_i\)

也就是，*M*<sub>*i*</sub>是除了*m*<sub>*i*</sub>以外所有模数的乘积。接着是关键的一步，寻找*N*个数*h*<sub>*i*</sub>使：

  -
    \(M_i h_i \equiv 1 \pmod{m_i}\)

有了这些数*h*<sub>*i*</sub>之后，整数*x*可以用下式从余数*x*<sub>*i*</sub>中解出：

  -
    \(x \equiv (x_1 M_1 h_1 + x_2 M_2 h_2 + \cdots + x_N M_N h_N ) \mod M\)

因为*h*<sub>*i*</sub>是*M*<sub>*i*</sub>的乘法逆，所以可以使用扩展欧几里得算法求出（见[上一节](https://zh.wikipedia.org/wiki/#乘法逆和RSA算法 "wikilink")）。

### 连分数

辗转相除法和[连分数有着紧密的关系](../Page/连分数.md "wikilink")。\[89\]计算连分数的过程如下：

\[\begin{align}
\frac{a}{b} &= q_0 + \frac{r_0}{b} \\
\frac{b}{r_0} &= q_1 + \frac{r_1}{r_0} \\
\frac{r_0}{r_1} &= q_2 + \frac{r_2}{r_1} \\
\vdots& \\
\frac{r_{k-2}}{r_{k-1}} &= q_k + \frac{r_k}{r_{k-1}} \\
\vdots& \\
\frac{r_{N-2}}{r_{N-1}} &= q_N \\
\end{align}\]

其中每个式子的右边最后一项都等于下一个式子的左边项的[倒数](../Page/倒数.md "wikilink")。所以前两个式子可以组合成：

\[\frac{a}{b} = q_0 + \frac{1}{q_1 + \frac{r_1}{r_0}}\]

第三个式子可以代入分母中的*r*<sub>1</sub>/*r*<sub>0</sub>：

\[\frac{a}{b} = q_0 + \frac{1}{q_1 + \frac{1}{q_2 + \frac{r_2}{r_1}}}\]

每一步中，最后一项*r*<sub>*k*</sub>/*r*<sub>*k*−1</sub>都可以用下一个式子代换，直至最后一个式子，结果是：

\[\frac{a}{b} = q_0 + \dfrac{1}{q_1 + \dfrac{1}{q_2 + \dfrac{1}{\ddots + \dfrac{1}{q_N}}}} = [ q_0; q_1, q_2, \cdots , q_N ]\]

在[上文的例子中计算了GCD](https://zh.wikipedia.org/wiki/#举例 "wikilink")(1071,
462)，其中商*q*<sub>*k*</sub>分别是2、3、7，所以分数 1071/462 可以写成如下连分数形式：

\[\frac{1071}{462} = 2 + \frac{1}{3 + \frac{1}{7}} = [2; 3, 7]\]

### 整数分解算法

计算最大公约数是很多[整数分解算法的重要步骤](../Page/整数分解.md "wikilink")\[90\]，如\[91\]、[Shor算法](https://zh.wikipedia.org/wiki/Shor算法 "wikilink")\[92\]、\[93\]以及\[94\]。用辗转相除法算最大公约数效率非常高。而[连分数分解法由于用到了连分数](https://zh.wikipedia.org/wiki/连分数分解法 "wikilink")，所以也需要使用辗转相除法\[95\]。

## 算法效率

[Euclidean_algorithm_running_time_X_Y.png](https://zh.wikipedia.org/wiki/File:Euclidean_algorithm_running_time_X_Y.png "fig:Euclidean_algorithm_running_time_X_Y.png")

辗转相除法的计算效率已经被彻底研究过了。\[96\]一个算法的效率可以用计算所需步数乘以每步计算的开销表示。[加百利·拉梅于](https://zh.wikipedia.org/wiki/加百利·拉梅 "wikilink")1884年指出\[97\]，用辗转相除法计算两个数的最大公约数所需的步数不会超过其中较小数十進制下的位数*h*的5倍。\[98\]\[99\]因为每一步的计算开销通常也是*h*数量级的，所以辗转相除法的[复杂度是](https://zh.wikipedia.org/wiki/算法复杂度 "wikilink")*h*<sup>2</sup>。

### 计算步数

计算两个自然数*a*和*b*的最大公约数所需的步数可以表示为*T*(*a*, *b*)。\[100\]如果*a*和*b*的最大公约数是*g*，*a* = *mg*，*b* = *ng*，而*m*和*n*是两个互素整数，那么：

  -

这可以通过在辗转相除法的计算过程中的每一步都除以*g*来证明。\[101\]同样，当*a*和*b*同时乘以*w*时，计算步数不变：*T*(*a*, *b*) = *T*(*wa*, *wb*)。所以，对于数值上相近的数，如T(*a*, *b*)和T(*a*, *b* + 1)，计算步数可能相差很大。

根据辗转相除法的递归性质可以得出另一个公式：

  -

其中，根據定义有*T*(*x*, 0) = 0。\[102\]

#### 最差情况

假设用辗转相除法求自然数*a*和*b*（*a* \> *b* \> 0）的最大公约数需要*N*步，那么满足这一条件的*a*和*b*的最小值分别是斐波那契数*F*<sub>*N*+2</sub>和*F*<sub>*N*+1</sub>。\[103\]这可以用[数学归纳法证明](../Page/数学归纳法.md "wikilink")。\[104\]假设*N* = 1，*b*整除*a*，满足这一条件的*a*和*b*最小是*b* = 1、*a* = 2，正是*F*<sub>2</sub>和*F*<sub>3</sub>。现在假设这一规律对*M* − 1有效。一个需要*M*步的算法的第一步是*a* = *q*<sub>0</sub>*b* + *r*<sub>0</sub>，第二步是*b* = *q*<sub>1</sub>*r*<sub>0</sub> + *r*<sub>1</sub>。因为算法是递归的，它需要*M* − 1
步才能算出 GCD(*b*, *r*<sub>0</sub>)，其中*b*和*r*<sub>0</sub>的最小值是
*F*<sub>*M*+1</sub> 和 *F*<sub>*M*</sub>。所以*a*的最小值是当 *q*<sub>0</sub> = 1
的时候，此时
*a* = *b* + *r*<sub>0</sub> = *F*<sub>*M*+1</sub> + *F*<sub>*M*</sub> = *F*<sub>*M*+2</sub>。1844年，加百利·拉梅发现这个证明标志着[计算复杂性理论的诞生](https://zh.wikipedia.org/wiki/计算复杂性理论 "wikilink")。\[105\]这也是[斐波那契数列的第一个实际应用](../Page/斐波那契数列.md "wikilink")。\[106\]

这个结果也证明了辗转相除法的运算步骤不会超过较小数十进制下的位数的五倍。\[107\]因为如果算法需要*N*步，那么*b*一定大于或等于*F*<sub>*N*+1</sub>，也就是一定大于或等于*φ*<sup>*N*−1</sup>，其中*φ*是[黄金分割比](https://zh.wikipedia.org/wiki/黄金分割比 "wikilink")。因为*b* ≥ *φ*<sup>*N*−1</sup>，所以*N* − 1 ≤ log<sub>*φ*</sub>*b*。因为log<sub>10</sub>*φ* \> 1/5，(*N* − 1)/5 \< log<sub>10</sub>*φ* log<sub>*φ*</sub>*b* = log<sub>10</sub>*b*，所以*N* ≤ 5 log<sub>10</sub>*b*。所以，辗转相除法不会进行超过[*O*(*h*)次除法](../Page/大O符号.md "wikilink")，其中*h*是较小数*b*在十进制下的位数。

#### 平均情况

辗转相除法的平均步骤数有三种不同的定义。第一种定义是计算已知自然数*a*和从0到*a* − 1范围内随机选取的自然数*b*的最大公约数所需的时间*T*(*a*)：\[108\]

\[T(a) = \frac{1}{a} \sum_{0 \leq b<a} T(a, b)\]

但是因为*T*(*a*, *b*)在连续整数间变化非常剧烈，所以*T*(*a*)的值也会显得很杂乱。\[109\]

为了解决这个问题，第二种定义规定τ(*a*)只要取遍其中所有和*a*互素的数即可：

\[\tau(a) = \frac{1}{\varphi(a)} \sum_{0 \leq b<a, \mathrm{GCD}(a, b) = 1} T(a, b)\]

在小于*a*的数中，有*φ*(*a*)个数与*a*互素，其中*φ*是[欧拉函数](../Page/欧拉函数.md "wikilink")。在这个定义中，τ(*a*)的函数值增长得平稳很多。\[110\]\[111\]

\[\tau(a) = \frac{12}{\pi^2} \ln 2 \ln a + C + O(a^{-\frac{1}{6} + \varepsilon})\]

誤差項的增長率為O(*a*<sup>−(1/6) +
ε</sup>)，其中ε是[无穷小量](https://zh.wikipedia.org/wiki/无穷小量 "wikilink")。公式中的常数*C*等于：

\[C = \frac{1}{2} + 6 (\frac{\ln 2}{\pi^2})( 4\gamma - 24\pi^2\zeta'(2) + 3 \ln 2 - 2) \approx 1.467\]

其中γ是[欧拉-马歇罗尼常数](https://zh.wikipedia.org/wiki/欧拉-马歇罗尼常数 "wikilink")，ζ′是[黎曼ζ函数的导数](https://zh.wikipedia.org/wiki/黎曼ζ函数 "wikilink")。\[112\]\[113\]公式最左边的\(\frac{12}{\pi^2}\ln 2\)由两个独立的方法确定。\[114\]\[115\]

因为第一种定义可以通过用第二种定义的求和来完成：\[116\]

\[T(a) = \frac{1}{a} \sum_{d | a} \varphi(d) \tau(d)\]

所以也可以由以下公式近似：\[117\]

\[T(a) \approx C + \frac{12}{\pi^2} \ln 2 ( \ln a - \sum_{d|a} \frac{\Lambda(d)}{d} )\]

其中Λ(*d*)是[冯·曼戈尔特函数](https://zh.wikipedia.org/wiki/冯·曼戈尔特函数 "wikilink")。\[118\]

第三种定义*Y*(*n*)定义为从1到*n*间随机选取*a*和*b*（[均勻分佈](../Page/離散型均勻分佈.md "wikilink")）时计算它们的最大公约数所需的平均步骤数：\[119\]

\[Y(n) = \frac{1}{n^2} \sum_{a=1}^{n} \sum_{b=1}^{n} T(a, b) = \frac{1}{n} \sum_{a=1}^{n} T(a)\]

将*T*(*a*)的近似公式代入，得到*Y*(*n*)的近似：\[120\]

\[Y(n) \approx \frac{12}{\pi^2} \ln 2 \ln n + 0.06\]

### 每一步的计算开销

在辗转相除法的每一步中，商*q*<sub>*k*</sub>和余数*r*<sub>*k*</sub>都通过*r*<sub>*k*−2</sub>和*r*<sub>*k*−1</sub>求出：

  -

所以每一步的计算开销主要与计算商*q*<sub>*k*</sub>的算法有关，因为余数*r*<sub>*k*</sub>可以很迅速地从*r*<sub>*k*−2</sub>、*r*<sub>*k*−1</sub>和*q*<sub>*k*</sub>计算出来：

  -

而计算一个*h*位整数的除法的算法复杂度是[*O*(*h*(*ℓ*+1))](../Page/大O符号.md "wikilink")，其中*ℓ*是商的位数。\[121\]

作为对比，辗转相除法原先的版本使用的是减法，因此效率要慢很多。进行一次除法等同于进行*q*次减法（其中*q*是商）。如果*a*和*b*的比很大，计算出的商也很大，也就需要进行很多次减法。但在另一方面，计算出来的商在大多数情况下都是非常小的，除法中得出一个确定的商*q*的概率大约是\(\log_2 \left(\tfrac{u}{u-1}\right)\)。其中*u* = (*q* + 1)<sup>2</sup>。\[122\]比如，商是1、2、3、4的可能性分别是大约41.5%、17.0%、9.3%、5.9%。因为计算机计算减法要快于除法，特別是对于很大的数字\[123\]，所以减法版本的辗转相除法的性能可以比得上除法版本。\[124\]这也被运用于[二进制最大公约数算法](https://zh.wikipedia.org/wiki/二进制 "wikilink")。\[125\]

综合考虑算法需要的步数和每一步的计算开销，辗转相除法随两个数字*a*和*b*的平均位数成平方级的速度增长(*h*<sup>2</sup>)。设*h*<sub>0</sub>、*h*<sub>1</sub>、…、*h*<sub>*N*−1</sub>表示计算过程中的余数*r*<sub>0</sub>、*r*<sub>1</sub>、…、*r*<sub>*N*−1</sub>的位数，因为算法的步数*N*随*h*线性增长，所以算法的运算时间为：

\[O\Big(\sum_{i<N}h_i(h_i-h_{i+1}+2)\Big)\subseteq O\Big(h\sum_{i<N}(h_i-h_{i+1}+2)\Big)\subseteq O(h(h_0+2N))\subseteq O(h^2)\]

### 其他算法的效率

因为辗转相除法的高效率，它在实践中被广泛使用。作为对比，本段中介绍以下辗转相除法以外的其他最大公约数算法的效率。

计算两数*a*和*b*的最大公约数有一个效率很慢的算法：将*a*除以从2到*b*之间的每一个整数以计算出它们所有的公约数，其中最大的一个即是最大公约数。在这个算法中，步骤数随*b*线性增长，也就是随输入数字的位数呈指数级增长。另一个很低效的算法是计算出两个数的所有素因数（见[上文](https://zh.wikipedia.org/wiki/#最大公约数 "wikilink")），最大公约数等于所有公共素因数的乘积。\[126\]但是[整数分解算法效率极低](../Page/整数分解.md "wikilink")，很多现代的加密系统甚至依靠这种低效率来防止资料被破解。\[127\]

除了辗转相除法之外，也有一些高效的算法存在，如[二进制最大公约数算法将除法操作替换成了](https://zh.wikipedia.org/wiki/二进制最大公约数算法 "wikilink")[二进制的移位](https://zh.wikipedia.org/wiki/二进制 "wikilink")，以进一步提高用计算机运算时的效率。\[128\]\[129\]但是，这种改变并没有降低算法的复杂度（仍然是[*O*(*h*²)](../Page/大O符号.md "wikilink")），虽然它在计算机上确实比辗转相除法快些。\[130\]也可以通过只检視*a*和*b*的前几位数来进一步提高效率，不过效果并不明显。\[131\]\[132\]二进制版的算法还可以扩展到其它进制\[133\]，效率最多可以提升五倍。\[134\]

对于超过25,000位数的大数，有一种改进使算法复杂度降低至平方级以下\[135\]，如Schönhage\[136\]\[137\]、Stehlé、Zimmermann等人提出的算法。\[138\]这些算法利用2×2的矩阵（见[上文](https://zh.wikipedia.org/wiki/#矩阵法 "wikilink")）。这些亚平方级的算法复杂度通常是。\[139\]\[140\]

## 其他数系

如上文所述，辗转相除法最早用来寻找两自然数的最大公约数，但其实它也可以被推广至实数，甚至是[多项式](https://zh.wikipedia.org/wiki/多项式 "wikilink")、[二次整数和](https://zh.wikipedia.org/wiki/二次整数 "wikilink")[赫尔维茨四元数](https://zh.wikipedia.org/wiki/赫尔维茨四元数 "wikilink")。在这些数系中，辗转相除法甚至被用来證明一个重要特性：惟一分解，即这些数系中的数能够被惟一地分解成[不可約元素](../Page/不可約元素.md "wikilink")（素数在这些数系的对应物）。惟一分解是数论中很多证明的基础。

### 有理数和实数

辗转相除法可以被应用至[实数](../Page/实数.md "wikilink")，如欧几里得在[几何原本第](../Page/几何原本.md "wikilink")10卷中所说的那样。算法的目的是计算出实数*g*，使已知实数*a*和*b*是它的整数倍：*a* = *mg*、*b* = *ng*，其中*m*和*n*是[整数](../Page/整数.md "wikilink")。\[141\]这也就找到了*a*和*b*的整数关系，即找到整数*s*和*t*使*sa*
+ *tb* =
0。欧几里得使用辗转相除法来处理[不可通约的长度](https://zh.wikipedia.org/wiki/通约性 "wikilink")。\[142\]\[143\]

实数的辗转相除法和整数的算法有两个区别。第一，余数*r*<sub>*k*</sub>是实数，虽然商*q*<sub>*k*</sub>仍然是整数。第二，算法不能保证在有限步内结束。如果能在有限步内结束，那么[分数](https://zh.wikipedia.org/wiki/分数 "wikilink")是一个[有理数](../Page/有理数.md "wikilink")，即：

  -

于是我们可以写出它的有限[连分数形式](../Page/连分数.md "wikilink")：。如果算法无法结束，那么是[无理数](https://zh.wikipedia.org/wiki/无理数 "wikilink")，可以写成无限的连分数形式：。无限连分数的一个例子是：[黄金分割比](https://zh.wikipedia.org/wiki/黄金分割比 "wikilink")和[2的算術平方根](../Page/2的算術平方根.md "wikilink")：{{\#tag:math|
= \[1; 2, 2, \\ldots\]}}。通常，算法能够结束的可能性是很低的，因为对于实数，几乎所有都是无理数。

如果算法不结束，也可以在第*k*步时终止计算，得到近似连分数。终止时的*k*越大，则近似越准确。连分数*m*/*n*的分子和分母互素并满足下式：

其中递归的初始值是。是在分母是*n*<sub>*k*</sub>的数中最精确的[有理数近似值](../Page/有理数.md "wikilink")：

\[\left|\frac{a}{b} - \frac{m_k}{n_k}\right| < \frac{1}{n_k^2}\]

### 多项式

只含有一个变量*x*的多项式可以和整数一样进行加法、乘法和分解為[不可約多项式](https://zh.wikipedia.org/wiki/不可約多项式 "wikilink")（也就是多项式中的“素数”）。两个多项式*a*(*x*)和*b*(*x*)的最大公约数*g*(*x*)定义为它们[分解之后共有的不可約因式的乘积](../Page/因式分解.md "wikilink")，这可以用辗转相除法进行计算。\[144\]对于多项式的算法和整数的算法很相似，在每个步骤*k*，计算出满足以下递归式的商多项式*q*<sub>*k*</sub>(*x*)和余数多项式*r*<sub>*k*</sub>(*x*)：

  -

其中*r*<sub>−2</sub>(*x*) = *a*(*x*)，*r*<sub>−1</sub>(*x*) = *b*(*x*)。所选择的商式必须能使*q*<sub>*k*</sub>(*x*)
*r*<sub>*k*−1</sub>(*x*)的首项系數和*r*<sub>*k*−2</sub>(*x*)的相等，这样才能保证每个余数的次数小于前一个余数（deg\[*r*<sub>*k*</sub>(*x*)\]
\<
deg\[*r*<sub>*k*−1</sub>(*x*)\]）。因为非零多项式的次数是非负整数，并且在每一步都减小，所以辗转相除法的计算一定能在有限步内结束。最后一个非零余数即是两个多项式*a*(*x*)和*b*(*x*)的最大公约数。\[145\]

例如，有如下两个四次多项式，都可以分解成两个二次多项式的乘积：

  -

和

  -

    .

得到余数：

\[r_0(x) = x^3 + \frac{2}{3} x^2 + \frac{5}{3} x - \frac{2}{3}\]

在下一步中，*b*(*x*)除以*r*<sub>0</sub>(*x*)得到*r*<sub>1</sub>(*x*) =
*x*<sup>2</sup> + *x* +
2。最终，*r*<sub>0</sub>(*x*)除以*r*<sub>1</sub>(*x*)得到的余数为0，所以*r*<sub>1</sub>(*x*)是*a*(*x*)和*b*(*x*)的最大公约数，这和它们因式分解的结果相符合。

上文所述的很多应用也适用于多项式。\[146\]辗转相除法可以解多项式的线性丢番图方程和中国剩余定理，也可以用来定义多项式的连分数展开式。

多项式的辗转相除法也有其他应用，如[施图姆定理](../Page/施图姆定理.md "wikilink")，一个用于计算多项式在给定区间内的实根个数的方法。这被应用于其他领域，如[控制论的](https://zh.wikipedia.org/wiki/控制论 "wikilink")[劳斯-赫尔维茨稳定性判据](https://zh.wikipedia.org/wiki/劳斯-赫尔维茨稳定性判据 "wikilink")。

最后，多项式的系数不必局限于整数、实数、甚至复数。这些系数可以是其他[域中的元素](https://zh.wikipedia.org/wiki/域_\(数学\) "wikilink")，如[上文所述的有限域GF](https://zh.wikipedia.org/wiki/#乘法逆和RSA算法 "wikilink")(*p*)。从辗转相除法得出的结论也可以直接推广至这类多项式。\[147\]

### 高斯整数

[Gaussian_primes.png](https://zh.wikipedia.org/wiki/File:Gaussian_primes.png "fig:Gaussian_primes.png")的分布，其中*u*<sup>2</sup> + *v*<sup>2</sup>小于500。\]\]

高斯整数是满足α = *u* + *vi*的复数，其中*u*和*v*是普通[整数](../Page/整数.md "wikilink")，*i*是[虚数单位](https://zh.wikipedia.org/wiki/虚数单位 "wikilink")（-1的平方根）。\[148\]通过在高斯整数中定义辗转相除法，根据上文[贝祖等式可以证明高斯整数的惟一分解](https://zh.wikipedia.org/wiki/#贝祖等式 "wikilink")。\[149\]高斯整数的惟一分解性质在很多应用中都很重要，如计算[勾股数或者证明](../Page/勾股数.md "wikilink")[费马平方和定理](../Page/费马平方和定理.md "wikilink")。\[150\]辗转相除法用于这些应用很方便，但并非必不可少，一些定理也可以由其他方式证明。

对于两个高斯整数α和β的辗转相除法和普通整数只有两个区别。像整数一样，算法的第*k*步计算出商*q*<sub>*k*</sub>和余数*r*<sub>*k*</sub>：

  -

其中*r*<sub>*k*−2</sub> = α，*r*<sub>*k*−1</sub> = β，每个余数都严格地小于前一个余数，|*r*<sub>*k*</sub>| \< |*r*<sub>*k*−1</sub>|。第一个区别即是：商和余数都是高斯整数，也就是[复数](https://zh.wikipedia.org/wiki/复数 "wikilink")，所以商*q*<sub>*k*</sub>是透過對實際比例（如複數α/β）的实部和虚部取最近似整數來找出的。第二个区别就是需要定义复数比较大小的方法。所以我们定义一个[范数函数](../Page/范数.md "wikilink")*f*(*u*
+ *v*i) = *u*<sup>2</sup> +
*v*<sup>2</sup>，以将高斯整数*u* + *vi*转换成普通整数来比较大小。在每个步骤*k*中，余数的范数*f*(*r*<sub>*k*</sub>)必须小于前一个余数的范数*f*(*r*<sub>*k*−1</sub>)。因为范数是非负整数并且在每一步都减小，所以辗转相除法在有限步内一定能结束。最后一个非零余数即是α和β的最大公约数，即能同时整除α和β的整数中范数最大的一个。若把乘以±1或±i的所得結果考慮在內，那麼可以說α和β的最大公约数是唯一的。

很多其他应用如线性丢番图方程、中国剩余定理都適用于高斯整数，高斯整数的连分数也可以用辗转相除法定义。

### 欧几里得整环

如果一个支持两种[二元运算](../Page/二元运算.md "wikilink")（+ 和
·）的元素的集合形成一个[交换环](../Page/交换环.md "wikilink")*R*并且可以使用辗转相除法求最大公约数，那么这个集合叫做[欧几里得整环](https://zh.wikipedia.org/wiki/欧几里得整环 "wikilink")。\[151\]\[152\]这两个二元运算不必是平常算数中的加法和乘法，它们可以是更广泛的概念，如[群或](../Page/群.md "wikilink")[幺半群中的运算](../Page/幺半群.md "wikilink")。但是这些运算仍然需要遵守[交换律](https://zh.wikipedia.org/wiki/交换律 "wikilink")、[结合律](../Page/结合律.md "wikilink")、[分配律](../Page/分配律.md "wikilink")。

推广之后的辗转相除法需要一个欧几里得函数，即一個将*R*映射到非负整数集合的函數*f*，使得对于*R*中非零元素*a*和*b*，*R*中存在*q*和*r*满足*a*
= *qb* + *r*，*f*(*r*) \<
*f*(*b*)。例如[上文中用于高斯整数的范数函数](https://zh.wikipedia.org/wiki/#高斯整数 "wikilink")。这个函数*f*可以是数的绝对值或模，也可以是多项式的次数，只要辗转相除法计算过程中它的值不断减小就行，这样算法便能在有限步内结束。这非常依赖于非负整数的[良序性](https://zh.wikipedia.org/wiki/良序 "wikilink")，即每个非空的非负整数集合都有一个最小数。

任何欧几里得整环都满足[算数基本定理](https://zh.wikipedia.org/wiki/算数基本定理 "wikilink")：欧几里得整环中的数可以[惟一分解](https://zh.wikipedia.org/wiki/惟一分解 "wikilink")。所以任何欧几里得整环都是[惟一分解整环](https://zh.wikipedia.org/wiki/惟一分解整环 "wikilink")，但反之不然。欧几里得整环是[GCD整环](https://zh.wikipedia.org/wiki/GCD整环 "wikilink")（任意两元素都存在最大公约数的整环）的子类。也就是说，在某些整环中，两元素存在最大公约数但却不能用辗转相除法计算。欧几里得整环都是[主理想环](https://zh.wikipedia.org/wiki/主理想环 "wikilink")，即其中每一个[理想都是](../Page/理想_\(环论\).md "wikilink")[主理想](https://zh.wikipedia.org/wiki/主理想 "wikilink")，但并不是每个主理想环都是欧几里得整环。

欧几里得整环的惟一分解性质在很多场合都非常有用。例如，高斯整数的惟一分解性质可以方便地导出[勾股数的公式](../Page/勾股数.md "wikilink")，或者证明[费马平方和定理](../Page/费马平方和定理.md "wikilink")。\[153\]惟一分解性质也是加百利·拉梅于1847年基于[约瑟夫·刘维尔的建议发表的证明](../Page/约瑟夫·刘维尔.md "wikilink")[费马最后定理的尝试中的关键部分](https://zh.wikipedia.org/wiki/费马最后定理 "wikilink")。\[154\]拉梅的尝试需要形如*x* + ω*y*的数的惟一分解性质，其中*x*和*y*是整数，ω = *e*<sup>2*i*π/*n*</sup>是1的*n*次方根，即ω<sup>*n*</sup> = 1。虽然这对于某些*n*成立（如*n*=3时的[艾森斯坦整数](../Page/艾森斯坦整数.md "wikilink")），但在其他情况下并非总是正确的。惟一分解性质在[分圆域的失效使](../Page/分圆域.md "wikilink")[恩斯特·库默尔发明了](../Page/恩斯特·库默尔.md "wikilink")[理想数的概念](../Page/理想数.md "wikilink")，随后[理查德·戴德金创造了](https://zh.wikipedia.org/wiki/理查德·戴德金 "wikilink")[理想的概念](../Page/理想_\(环论\).md "wikilink")。

#### 二次整数的惟一分解

[Eisenstein_primes.svg](https://zh.wikipedia.org/wiki/File:Eisenstein_primes.svg "fig:Eisenstein_primes.svg")）。\]\]

[二次整数环对于解释欧几里得整环很有帮助](https://zh.wikipedia.org/wiki/二次整数环 "wikilink")。二次整数是高斯整数的推广，高斯整数中的虚数单位*i*被替换成一个复数ω。二次整数的形式是*u* + *v*ω，其中*u*和*v*是整数，ω有两种形式，取决于参数*D*。如果*D*不等于四的倍数加一，那么：

  -
    \(\omega = \sqrt{D}\)

如果*D*等于四的倍数加一，那么：

  -
    \(\omega = \frac{1 + \sqrt{D}}{2}\)

如果二次整数环有像[上文用来比较高斯整数的那样的](https://zh.wikipedia.org/wiki/#高斯整数 "wikilink")[范数函数](https://zh.wikipedia.org/wiki/范数_\(域论\) "wikilink")，那么它就是规范欧几里德整环。只有当*D* = −11,
−7, −3, −2, −1, 2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41,
57或73时，二次整数环才是规范欧几里德整环\[155\]。*D* = −1和−3时的二次整数分别叫作[高斯整数和](https://zh.wikipedia.org/wiki/高斯整数 "wikilink")[艾森斯坦整数](../Page/艾森斯坦整数.md "wikilink")。

但如果[范数函数](https://zh.wikipedia.org/wiki/范数_\(域论\) "wikilink")*f*可以是任何欧几里得函数，那么使二次整数环是欧几里得整环的*D*的可能值到目前为止还不确定。\[156\]是欧几里得整环但不是规范欧几里德整环的第一个例子（*D*=69）发表于1994年\[157\]。温伯格於1973年证明，在[广义黎曼猜想成立的前提下](../Page/广义黎曼猜想.md "wikilink")，*D*\>0时的二次整数环是欧几里得整环，當且僅當它是一个[主理想环](https://zh.wikipedia.org/wiki/主理想环 "wikilink")。\[158\]

### 非交换环

辗转相除法也可以应用至非交换环，如[赫尔维茨四元数](https://zh.wikipedia.org/wiki/赫尔维茨四元数 "wikilink")。\[159\]令表示这样一个环中的两个元素。他们有右公约数*δ*如果。同样，他们有左公约数*δ*如果。因为乘法不符合交换律，也就有两个版本的辗转相除法，一个计算右公约数，一个计算左公约数。例如对于右公约数，辗转相除法求最大公约数的第一步可以写成：

  -

其中ψ<sub>0</sub>是商，ρ<sub>0</sub>是余数。对于左公约数，第一步过程是：

  -

不管是哪一种，这个过程都会重复到最大左公约数或者最大右公约数计算出，像在欧几里得整环中一样，的“大小”一定小于，并且對於只有有限种的可能大小，这样才能保证算法能够结束。

由辗转相除法得出的大多数结果都适用于非交换环。例如，[贝祖等式表明最大右公约数可以表示成](https://zh.wikipedia.org/wiki/贝祖等式 "wikilink")的倍数和的倍数的和，即，存在使：

  -

对于最大左公约数，等式如下：

  -

贝祖等式可以用来解非交换环的丢番图方程。

## 推广至其他数学结构

[TorusKnot3D.png](https://zh.wikipedia.org/wiki/File:TorusKnot3D.png "fig:TorusKnot3D.png")。\[160\]\]\]

辗转相除法有三个性质保证它不会永远进行下去。第一，它可以写成一系列递归式：

  -

其中每一个余数都比前一个余数小，|*r*<sub>*k*</sub>| \< |*r*<sub>*k*−1</sub>|。第二，余数的大小有嚴格下限，如|*r*<sub>*k*</sub>| ≥ 0。第三，小于|*r*<sub>*k*</sub>|的数的数量是有限的。辗转相除法推广至其他数学结构，如\[161\]和[超限](../Page/超限数.md "wikilink")[序数](../Page/序数.md "wikilink")\[162\]时仍保持这种性质。

辗转相除法的一个重要推广是[代数几何中](../Page/代数几何.md "wikilink")[格罗布纳基的概念](https://zh.wikipedia.org/wiki/格罗布纳基 "wikilink")。像前文所述，*a*和*b*的最大公约数*g*
是它们的[理想的生成元素](../Page/理想_\(环论\).md "wikilink")。也就是说，对任何整数*s*和*t*，存在另一个整数*m*使：

  -

虽然这对一元多项式也成立，但是对多元多项式就不成立了。\[163\]在多元多项式的情况下，生成元素的有限集合*g*<sub>1</sub>、*g*<sub>2</sub>……可以定义如下：

  -

其中*s*、*t*和*m*<sub>*k*</sub>是多元多项式。\[164\]任何这样的多元多项式*f*可以表示成生成多项式的和加上惟一的余数多项式*r*,
通常叫做多项式*f*的一般形式。

  -

虽然商多项式*q*<sub>*k*</sub>可能不惟一。\[165\]这些生成多项式的集合就叫做格罗布纳基。\[166\]

## 参考文献

### 引用

### 来源

  - 书籍

<!-- end list -->

  -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -
  -
## 外部链接

  - [Demonstrations of Euclid's
    algorithm](http://www.math.sc.edu/~sumner/numbertheory/euclidean/euclidean.html)

  -
  - [Euclid's Algorithm](http://www.cut-the-knot.org/blue/Euclid.shtml)
    at
    [cut-the-knot](https://zh.wikipedia.org/wiki/cut-the-knot "wikilink")

  -
  - [The Euclidean
    Algorithm](http://www.mathpages.com/home/kmath384.htm) at MathPages

  - [Euclid's Game](http://www.cut-the-knot.org/blue/EuclidAlg.shtml) at
    [cut-the-knot](https://zh.wikipedia.org/wiki/cut-the-knot "wikilink")

  - [Music and Euclid's
    algorithm](http://plus.maths.org/issue40/features/wardhaugh/index.html)

[Category:数论算法](https://zh.wikipedia.org/wiki/Category:数论算法 "wikilink")
[Category:数论](https://zh.wikipedia.org/wiki/Category:数论 "wikilink")

1.  [Godfried
    Toussaint](https://zh.wikipedia.org/wiki/Godfried_Toussaint "wikilink"),
    "The Euclidean algorithm generates traditional musical rhythms,"
    *Proceedings of BRIDGES: Mathematical Connections in Art, Music, and
    Science*, Banff, Alberta, Canada, July 31 to August 3, 2005, pp.
    47–56.

2.  Stark, p. 16.

3.  Stark, p. 21.

4.  LeVeque, p. 32.

5.  Leveque, p. 31.

6.

7.  Schroeder, pp. 21–22.

8.  Schroeder, p. 19.

9.

10. Schroeder, pp. 216–219.

11.
12. Stark, p. 25.

13. Ore, pp. 47–48.

14.  (Section 1.2.1: Mathematical Induction, pp. 11–21.)

15. Rosen, pp. 18–21.

16. Rosen, pp. 21–24.

17.

18. Rosen, p. 492.

19.

20. Stark, pp. 16–20.

21. Stark, p. 18.

22.
23. 高德纳, p. 320.

24.

25.

26. Cohn, pp. 104–110.

27. 高德纳, pp. 319–320.

28. 高德纳, pp. 318–319.

29. Stillwell, p. 14.

30. Ore, p. 43.

31.

32.
33.
34. 高德纳, p. 318.

35.

36.

37.

38.
39.

40.

41.

42.

43. Stillwell, p. 31.

44. Rosen, pp. 86–87.

45. Tattersall, p. 70.

46.

47. Ore, pp. 247–248.

48.

49. Tattersall, p. 70.

50. Tattersall, pp. 72–76.

51.
52.
53. 狄利克雷, pp. 29–31.

54.

55.

56.

57.

58.

59.

60.

61.

62. Rosen, p. 95.

63.

64.

65. Rosen, p. 81.

66. Cohn, p. 104.

67. Rosen, p. 91.

68. Leveque, p. 33.

69. Schroeder, p. 23.

70. Rosen, pp. 90–93.

71.

72.
73.

74. Stark, pp. 26–36.

75. Ore, p. 44.

76.
77. Stark, pp. 281–292.

78. Rosen, pp. 119–125.

79. Schroeder, pp. 106–107.

80. Schroeder, pp. 108–109.

81. Rosen, pp. 120–121.

82. Stark, p. 47.

83. Schroeder, pp. 107–109.

84. Stillwell, pp. 186–187.

85. Schroeder, p. 134.

86. "Error correction coding: mathematical methods and algorithms", page
    266, Todd K. Moon, John Wiley and Sons, 2005, ISBN 978-0-471-64800-0

87. Rosen, pp. 143–170.

88. Schroeder, pp. 194–195.

89.

90.

91. 高德纳, pp. 369–371.

92.

93.

94.

95. 高德纳, pp. 380–384.

96. 高德纳, pp. 339–364.

97.

98.

99.

100. 高德纳, p. 344.

101. Ore, p. 45.

102.
103. 高德纳, p. 343.

104. Mollin, p. 21.

105. LeVeque, p. 35.

106.
107. Mollin, pp. 21–22.

108.
109. 高德纳, p. 353.

110. 高德纳, p. 357.

111.

112.

113.

114.

115.

116. 高德纳, p. 354.

117.

118. 高德纳, p. 355.

119.
120. 高德纳, p. 356.

121. 高德纳, pp. 257–261.

122. 高德纳, p. 352.

123.

124. Cohen, p. 14.

125. Cohen, pp. 14–15, 17–18.

126.
127.
128. 高德纳, pp. 321–323.

129.

130.

131. 高德纳, p. 328.

132.

133.

134.

135.

136.

137.  Volume 1423 in *Lecture notes in Computer Science*.

138.

139.
140.

141.
142.

143.

144.

145. Cox, pp. 37–46.

146. Schroeder, pp. 254–259.

147.
148.
149.  See also *Werke*, **2**:67–148.

150.

151. Stark, p. 290.

152. Cohn, pp. 104–105.

153.
154.

155.
156.

157.
158.

159.

160.

161.

162.

163. Cox, p. 65.

164. Cox, pp. 73–79.

165. Cox, pp. 79–86.

166. Cox, p. 74.
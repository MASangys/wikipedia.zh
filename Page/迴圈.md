**迴圈**是[計算機科學運算領域的用語](https://zh.wikipedia.org/wiki/計算機科學 "wikilink")，也是一種常見的[控制流程](../Page/控制流程.md "wikilink")。迴圈是一段在程式中只出現一次，但可能會連續執行多次的程式碼。迴圈中的程式碼會執行特定的次數，或者是執行到特定條件成立時結束迴圈，或者是針對某一集合中的所有項目都執行一次。

在一些[函數程式語言](https://zh.wikipedia.org/wiki/函數程式語言 "wikilink")（例如[Haskell](../Page/Haskell.md "wikilink")和[Scheme](../Page/Scheme.md "wikilink")）中會使用[递归或](../Page/递归_\(计算机科学\).md "wikilink")[不动点组合子](../Page/不动点组合子.md "wikilink")來達到迴圈的效果，其中[尾部递归是一種特別的递归](https://zh.wikipedia.org/wiki/尾部递归 "wikilink")，很容易轉換為[迭代](../Page/迭代.md "wikilink")。\[1\]

## 指定執行次數的迴圈(for loop)

大部份程式語言都提供迴圈的指令，可以依指定的次數重覆執行一段程式。

若指定的次數N小於1，程式語言會忽略整個迴圈不去執行，若指定的次數N為1，則迴圈只會執行一次。

在迴圈進行時，[迴圈计数器也會隨著變化](https://zh.wikipedia.org/wiki/迴圈计数器 "wikilink")，大部份的程式語言可以允許迴圈计数器上數或是下數，每次的變化量可以是1或是其他不為0的數值。

`   FOR I = 1 TO N            `**`for`**` I := 1 `**`to`**` N `**`do`**` `**`begin`**
`       xxx                       xxx`
`   NEXT I                    `**`end`**`;`

`   DO I = 1,N                `**`for`**` ( I=1; I<=N; ++I ) {`
`       xxx                       xxx`
`   END DO                    }`

在許多程式語言中，迴圈计数器要使用整數才能得到準確的結果。由於硬體的限制，在迴圈计数器使用[浮點數時](https://zh.wikipedia.org/wiki/浮點數 "wikilink")，結果可能會不符預期，如以下的迴圈
**for** X := 0.1 **step** 0.1 **to** 1.0 **do**
依其四捨五入的誤差、硬體及編譯器的差異，不一定會執行10次，可能只會執行9次。而且X的數值可能會有些誤差，不是預期的0.1, 0.2, 0.3, ..., 1.0。

## 指定條件的迴圈(while loop/doWhile loop)

大多數的程式語言都有指令，可以在特定條件成立時繼續迴圈的進行，或是特定條件不成立時繼續迴圈的進行，進行到特定條件成立為止。前者一般會標示while，後者一般會標示until。

其判斷條件可能在迴圈一開始就進行，或是在迴圈最後才進行。前者的迴圈不一定會執行，而後者1的迴圈至少會執行一次。

`   DO WHILE (test)           `**`repeat`**` `
`       xxx                       xxx `
`   LOOP                      `**`until`**` test;`

`   `**`while`**` (test) {            `**`do`**
`       xxx                       xxx`
`   }                         `**`while`**` (test);`

## 指定集合的迴圈

許多程式語言支援一種特別的迴圈，可以針對一個陣列中的元素或是一個集合中的所有成員進行迴圈中的指令，包括[Ada](../Page/Ada.md "wikilink")、[D語言](../Page/D語言.md "wikilink")、[Smalltalk](../Page/Smalltalk.md "wikilink")、[Perl](../Page/Perl.md "wikilink")、[Java](../Page/Java.md "wikilink")、[C\#](../Page/C♯.md "wikilink")、[Visual Basic](../Page/Visual_Basic.md "wikilink")、[Ruby](../Page/Ruby.md "wikilink")、[Python](../Page/Python.md "wikilink")、[JavaScript](../Page/JavaScript.md "wikilink")、[Fortran 95等程式語言都有這類的迴圈結構](https://zh.wikipedia.org/wiki/Fortran#Fortran_95 "wikilink")：

`   someCollection `**`do`**`: [:eachElement |xxx].`

`   `**`foreach`**` (item; myCollection) { xxx }`

`   `**`foreach`**` someArray { xxx }`

`   Collection`<String>` coll; `**`for`**` (String s : coll) {}`

`   `**`foreach`**` (`**`string`**` s `**`in`**` myStringCollection) { xxx }`

`   $someCollection | ForEach-Object { $_ }`
`   `
`   `**`forall`**` ( index = first:last:step... )`

## 泛用迴圈結構

有些程式語言有泛用迴圈結構，可以用來表示指定次數或指定條件的迴圈，像C語言的for指令或是[Common Lisp語言中的do指令都是這類的例子](../Page/Common_Lisp.md "wikilink")，不過為了程式的可讀性考量，在這些程式語言中還是儘量使用一些含義較明確的指令（如while指令）。

## 無窮迴圈

[無窮迴圈](../Page/無窮迴圈.md "wikilink")一般會用在有一段程式需要永遠執行，或是該程式在沒有發生特殊事件（如故障）時需要永遠執行的場合，例如一個事件驅動的程式需要持續執行迴圈，處理發生的事件，直到使用者結束或中斷程式為止。

若在指定條件的迴圈中，其判斷條件用到的變數數值永遠不會改變，這種程式錯誤也會使得此迴圈變成無窮迴圈。

## 提早結束整個迴圈

當使用指定次數的迴圈查表時，會希望在查到需要的資料時就可以直接結束迴圈的進行，有些程式語言可以用`break`或`exit`的指令達到這様的功能，這些指令會結束這個迴圈，接著會執行迴圈後面的指令。若此迴圈在副程式中，也可以用`return`中斷迴圈的進行， 同時離開副程式。

以下是[Ada](../Page/Ada.md "wikilink")程式語言的一個範例，利用`exit ... when...`的方式中提早結束迴圈。

``` ada
with Ada.Text IO;
with Ada.Integer Text IO;

procedure Print_Squares is
    X : Integer;
begin
    Read_Data : loop
        Ada.Integer Text IO.Get(X);
    exit Read_Data when X = 0;
        Ada.Text IO.Put (X * X);
        Ada.Text IO.New_Line;
    end loop Read_Data;
end Print_Squares;
```

[Python](../Page/Python.md "wikilink")支援一個特別的條件判斷式，可以根據最近使用迴圈是否曾用`break`提早結束而做不同的處理，舉例如下：

``` python
for n in set_of_numbers:
    if isprime(n):
        print "Set contains a prime number"
        break
else:
    print "Set did not contain any prime numbers"
```

上例中的`else`子句是`for`迴圈的一部份，不是內層`if`區塊的一部份。Python語言的`for`迴圈及`while` 迴圈都支援`else`子句，當迴圈沒有用`break`提早結束時就會執行。

## 迴圈的特殊指令

有時在使用迴圈的程式中會希望在特定情形下跳過目前迴圈區塊的指令，回到迴圈開始執行下一個迴圈，一般這類的指令會命名為`continue`、`skip`或`next`，其效果是提早結束這次迴圈的進行，繼續進行下一個迴圈，若此迴圈已經是最後一次執行，這類指令會結束迴圈的進行，繼續進行後續的指令。

像Perl及Ruby等程式語言有`redo`指令，可以重新執行目前的迴圈，若在指定次數的迴圈中，其迴圈計數器的數值不會變化。Ruby程式語言有`retry`指令，可以讓迴圈計數器回到初值，重新執行整個迴圈。

## 迴圈變式及迴圈不變式

及[迴圈不變式是判斷迴圈正確性的工具](https://zh.wikipedia.org/wiki/迴圈不變式 "wikilink")\[2\]。

迴圈變式是一個初值不為負的整數表示式，在每次執行迴圈時迴圈變式的數值需減少，但在正常的迴圈執行過程中迴圈變式的數值不會變成負值。迴圈變式用來確保迴圈會結束。

迴圈不變式是一個和迴圈有關的判斷式，在第一次進入迴圈之前，迴圈不變式的值需為真，在後續每一次執行迴圈時，其值也要為真。當迴圈正確的結束時，其終止條件和迴圈不變式都會成立。迴圈不變式可用來監控在迴圈進行時，某一指定性質的狀態。

像是[Eiffel](../Page/Eiffel.md "wikilink")之類的程式語言本身就有支援迴圈變式及迴圈不變式，其他語言可能需要有附加元件才能支持此功能，例如[Java](../Page/Java.md "wikilink")就需要配合規範的[loop statements](http://www.eecs.ucf.edu/~leavens/JML//jmlrefman/jmlrefman_12.html#SEC168)才能支持此機能。

## 不同語言的迴圈比較表

<table>
<thead>
<tr class="header">
<th><p><a href="https://zh.wikipedia.org/wiki/程式語言" title="wikilink">程式語言</a></p></th>
<th><p>條件判斷式</p></th>
<th><p>迴圈</p></th>
<th><p>early exit</p></th>
<th><p>continuation</p></th>
<th><p>redo</p></th>
<th><p>retry</p></th>
<th><p>正確性判斷機制</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>迴圈啟始</p></td>
<td><p>迴圈中間</p></td>
<td><p>迴圈結尾</p></td>
<td><p>指定次數</p></td>
<td><p>指定集合</p></td>
<td><p>泛用</p></td>
<td><p>無窮</p></td>
<td><p>迴圈變式</p></td>
</tr>
<tr class="even">
<td><p><a href="../Page/Ada.md" title="wikilink">Ada</a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/C語言" title="wikilink">C</a></p></td>
<td></td>
<td></td>
<td></td>
<td><p></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/C++.md" title="wikilink">C++</a></p></td>
<td></td>
<td></td>
<td></td>
<td><p></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/C♯.md" title="wikilink">C#</a></p></td>
<td></td>
<td></td>
<td></td>
<td><p></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/Common_Lisp.md" title="wikilink">Common Lisp</a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/Eiffel.md" title="wikilink">Eiffel</a></p></td>
<td></td>
<td></td>
<td></td>
<td><p></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/F♯.md" title="wikilink">F#</a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Fortran#FORTRAN_77" title="wikilink">FORTRAN 77</a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="https://zh.wikipedia.org/wiki/Fortran#FORTRAN_90" title="wikilink">FORTRAN 90</a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Fortran#FORTRAN_95" title="wikilink">FORTRAN 95及後續版本</a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/Haskell.md" title="wikilink">Haskell</a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/Java.md" title="wikilink">Java</a></p></td>
<td></td>
<td></td>
<td></td>
<td><p></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/JavaScript.md" title="wikilink">JavaScript</a></p></td>
<td></td>
<td></td>
<td></td>
<td><p></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/OCaml.md" title="wikilink">OCaml</a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/PHP.md" title="wikilink">PHP</a></p></td>
<td></td>
<td></td>
<td></td>
<td><p> </p></td>
<td><p></p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/Perl.md" title="wikilink">Perl</a></p></td>
<td></td>
<td></td>
<td></td>
<td><p> </p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/Python.md" title="wikilink">Python</a></p></td>
<td></td>
<td></td>
<td></td>
<td><p></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/REBOL.md" title="wikilink">REBOL</a></p></td>
<td><p></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p></p></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/Ruby.md" title="wikilink">Ruby</a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="https://zh.wikipedia.org/wiki/Standard_ML" title="wikilink">Standard ML</a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><a href="../Page/Visual_Basic_.NET.md" title="wikilink">Visual Basic .NET</a></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><a href="../Page/Windows_PowerShell.md" title="wikilink">Windows PowerShell</a></p></td>
<td></td>
<td></td>
<td></td>
<td><p></p></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

1.  此項只考慮專用的無窮迴圈程式結構，因此`while (true)`和`for ( ; ; )`都不算在內。

2.  C語言的`for (`*`init`*` ;  `*`test`*` ;  `*`increment`*`)`迴圈是一個通用的迴圈指令，累加量也不一定要為1。

3.  在C、C++及C\#中，跳出多層迴圈可以用label和goto指令達到。

4.  在PHP 5中已[支援](http://www.php.net/manual/en/language.oop5.iterations.php)配合物件的迴圈。

5.  指定次數的迴圈可以用重覆incrementing list或generator的方式來達到其效果，例如Python中的`range()`。

6.  可以用[异常处理](../Page/异常处理.md "wikilink")來跳出多層迴圈。

7.  沒有專門指令，但`while`指令可以用作此用途。

8.  沒有專門指令，但使用者可以定義通用迴圈指令。

9.  正在計劃的[C++0x標準中已加入](https://zh.wikipedia.org/wiki/C++0x "wikilink")[以範圍為基礎的 for 迴圈](https://zh.wikipedia.org/wiki/C++0x#以範圍為基礎的_for_迴圈 "wikilink")。[标准模板库](../Page/标准模板库.md "wikilink")（STL）中有`std::for_each`[模板函數](../Page/模板_\(C++\).md "wikilink")，可以對STL容器（container）的每個元素重複呼叫一個一元函數\[3\]。製作STL容器的[巨集](../Page/巨集.md "wikilink")也可以達到類似的效果\[4\]。

10. 利用整數區間的迭代可以達到指定次數迴圈的效果， early exit可以用多增加一個exit的條件來達成。

11. Eiffel支援保留字`retry`，不過是用在[契约式设计](../Page/契约式设计.md "wikilink")的[異常處理](https://zh.wikipedia.org/wiki/異常處理 "wikilink")，不是迴圈的流程控制指令。

12. 需要配合（JML）。

## 參考資料

[Category:控制流程](https://zh.wikipedia.org/wiki/Category:控制流程 "wikilink")

1.
2.
3.  [for_each](http://www.sgi.com/tech/stl/for_each.html). Sgi.com. Retrieved on 2010-11-09.
4.  [Chapter 1. Boost.Foreach](http://boost-sandbox.sourceforge.net/libs/foreach/doc/html/). Boost-sandbox.sourceforge.net (2009-12-19). Retrieved on 2010-11-09.
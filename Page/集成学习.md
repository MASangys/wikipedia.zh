在[统计学](../Page/统计学.md "wikilink")和[机器学习](../Page/机器学习.md "wikilink")中，**集成学习**方法使用多种学习算法来获得比单独使用任何单独的学习算法更好的[预测性能](https://zh.wikipedia.org/wiki/预测 "wikilink")。\[1\]\[2\]\[3\]不像统计力学中的[系综](../Page/系综.md "wikilink")通常是无限的，机器学习集合仅由一组具体的有限的可替代模型组成，但通常允许在这些可替代方案中存在更灵活的结构。

## 概述

[监督学习算法通常被描述为执行搜索假设空间的任务以找到合适的假设](https://zh.wikipedia.org/wiki/监督学习 "wikilink")，该假设将对特定问题做出良好预测。即使假设空间包含非常适合特定问题的假设，也可能很难找到一个很好的假设。集成学习结合多个假设，形成一个（希望）更好的假设。术语集成通常保留用于使用相同基础学习器生成多个假设的方法。多分类器系统的更广泛术语还包括由非相同基础学习器得到的假设的结合。这种方法和现象也被另一个术语“群智”所描述，该术语来自多个DREAM生物医学数据科学挑战。

评估集成学习的预测通常需要比评估单个模型的预测更多的计算，因此集成可以被认为是通过执行大量额外计算来补偿差的学习算法的方式。诸如[决策树](../Page/决策树.md "wikilink")之类的快速算法通常用于集合方法（如[随机森林](../Page/随机森林.md "wikilink")），尽管较慢的算法也可以从集成方法中受益。

通过类比，集成技术也已用于[无监督学习场景中](../Page/無監督式學習網路.md "wikilink")，如共识聚类或[异常检测](../Page/异常检测.md "wikilink")。

## 集成理论

集成学习本身是一种监督学习算法，因为它可以被训练然后用于进行预测。因此，训练后的集成模型代表了一个假设，但这个假设不一定被包含在构建它的模型的假设空间内。因此，可以证明集成学习在它们可以表示的功能方面具有更大的灵活性。理论上，这种灵活性使他们能够比单一模型更多地[过拟合训练数据](https://zh.wikipedia.org/wiki/过拟合 "wikilink")，但在实践中，一些集成算法（如[Bagging算法](../Page/Bagging算法.md "wikilink")）倾向于减少对训练数据过拟合相关的问题。

根据经验，当模型之间存在显著差异时，集成往往会产生更好的结果。<ref>

<div>

Kuncheva,L.和Whitaker,C.,措施的多样性中的分类器的合奏， *学习机*,51,pp.181-207，2003年

</div>

</ref><ref>

<div>

Sollich,P.和克罗,A., *学习合唱团：如何过拟合可能是有用的*，先进的神经信息处理系统，第8卷，pp.190-196之，1996年。

</div>

</ref>因此，许多集成方法试图促进它们组合的模型之间的多样性。<ref>

<div>

Brown,G.和Wyatt,J.和Harris,R.和Yao，X.、多样化创作方法：调查和分类., *信息的融合*，6个(1)，第5-20，2005年。

</div>

</ref><ref>

<div>

*[准确性和多样性乐团的文Categorisers](http://www.clei.cl/cleiej/papers/v8i2p1.pdf) *的。 J.J.García Adeva,Ulises Cerviño，R.Calvo,CLEI Journal,Vol. 8,No.2,pp.1-12月，2005年。

</div>

</ref>尽管可能不是直观的，更随机的算法（如随机决策树）可用于产生比非常有意识的算法（如熵减少决策树）更强大的集成模型。<ref>

<div>

嗬,T.,随机决定的森林， *诉讼程序的第三次国际会议文件的分析和认识*，pp.278-282，1995年。

</div>

</ref>然而，使用各种强大的学习算法已被证明是比使用试图愚弄模型以促进多样性的技术更有效。<ref>

<div>

Gashler,M.和吉罗的载体，C.和Martinez,T., *[决定树团：小型异构是更好的比较大的均匀](http://axon.cs.byu.edu/papers/gashler2008icmla.pdf)*，第七次国际会议上学习机和应用程序，2008年，pp.900-905., [DOI10.1109/ICMLA的。2008年。154](http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=4796917)

</div>

</ref>

## 集成模型大小

虽然集成中的组成分类器的数量对预测的准确性具有很大影响，但是解决该问题的研究数量有限。先验地确定集成模型的大小以及大数据流的体积和速度使得这对于在线集成分类器来说更加重要，其中大多数统计测试被用于确定适当数量的组件。最近，理论框架表明对于集成模型存在理想数量的分类器，具有多于或少于该数量的分类器将使精度变差，这被称为“集成构建效果递减规律”。理论框架表明，使用与类标签数相同的独立分类器可以达到最高的准确度。\[4\] \[5\]

## 常见的集成类型

### 贝叶斯最优分类器

贝叶斯最优分类器是一种分类技术，它是假设空间中所有假设的集合。平均而言，没有其他集成模型可以超越它。<ref>

<div>

[汤姆M.Mitchell](https://zh.wikipedia.org/wiki/Tom_M._Mitchell "wikilink"), *机学习*，1997年，第175

</div>

</ref>朴素贝叶斯最优分类器假定数据在类上有条件地独立并使计算更可行，如果该假设为真，则对每个假设进行投票，该投票与从系统采样训练数据集的可能性成比例。为了促进有限大小的训练数据，每个假设的投票也乘以该假设的先验概率。贝叶斯最优分类器可以用以下等式表示：

  -
    \(y=\underset{c_j \in C}{\mathrm{argmax}} \sum_{h_i \in H}{P(c_j|h_i)P(T|h_i)P(h_i)}\)

其中 \(y\)是预测标签， \(C\)是所有可能类的集合， \(H\)是假设空间， \(P\)是*概率*， \(T\)是训练数据。 作为集成，贝叶斯最优分类器表示不一定在\(H\)中的假设。然而，由贝叶斯最优分类器表示的假设是集合空间中的最优假设（所有可能的集合的空间仅由\(H\)中的假设组成）。

这个公式可以用[贝叶斯定理](../Page/贝叶斯定理.md "wikilink")重新表述，贝叶斯定理表明后验与先验的可能性成正比：

  -
    \(P(h_i|T) \propto P(T|h_i)P(h_i)\)

因此，

  -
    \(y=\underset{c_j \in C}{\mathrm{argmax}} \sum_{h_i \in H}{P(c_j|h_i)P(h_i|T)}\)

### Bootstrap聚合（Bagging）

Bootstrap聚合（Bootstrap Aggregating，[Bagging](../Page/Bagging算法.md "wikilink")）使集成模型中的每个模型在投票时具有相同的权重。为了减小模型方差，Baging使用随机抽取的子训练集训练集成中的每个模型。例如，[随机森林](../Page/随机森林.md "wikilink")算法将随机决策树与Bagging相结合，以实现更高的分类准确度。<ref>

<div>

Breiman，L.，装袋预测， *学习机*,24(2)，pp.123-140，1996年。

</div>

</ref>

### Boosting

[Boosting通过在训练新模型实例时更注重先前模型错误分类的实例来增量构建集成模型](https://zh.wikipedia.org/wiki/Boosting_\(meta-algorithm\) "wikilink")。在某些情况下，Boosting已被证明比Bagging可以得到更好的准确率，不过它也更倾向于对训练数据过拟合。目前比较常见的增强实现有[AdaBoost](../Page/AdaBoost.md "wikilink")等算法。

### 贝叶斯参数平均

贝叶斯参数平均（Bayesian Parameter Averaging，BPA）是一种集成方法，它试图通过对假设空间中的假设进行抽样来近似贝叶斯最优分类器，并使用贝叶斯定律将它们组合起来。\[6\]与贝叶斯最优分类器不同，贝叶斯模型平均（Bayesian Model Averaging，BMA）可以实际实现。通常使用诸如[MCMC的](https://zh.wikipedia.org/wiki/MCMC "wikilink")[蒙特卡罗方法对假设进行采样](https://zh.wikipedia.org/wiki/蒙特卡罗方法 "wikilink")。例如，可以使用[吉布斯采样](../Page/吉布斯采样.md "wikilink")来绘制代表分布\(P(T|H)\)的假设。已经证明，在某些情况下，当以这种方式绘制假设并根据贝叶斯定律求平均时，该算法具有预期误差，该误差被限制为贝叶斯最优分类器的预期误差的两倍。<ref>

<div>

大卫Haussler，迈克尔\*柯恩斯和罗伯特\*E Schapire的。 *边界在这样复杂的贝学习使用信息理论和VC尺寸*的。 学习机，14:83-113，1994年

</div>

</ref>尽管这种技术理论正确，但早期工作中的实验结果表明，与简单的集成方法如Bagging相比，该方法促进了过拟合并且表现更差；\[7\] however, these conclusions appear to be based on a misunderstanding of the purpose of Bayesian model averaging vs. model combination.\[8\]然而，这些结论似乎是基于对目的的误解贝叶斯模型平均与模型组合。\[9\]此外，BMA的理论和实践取得了相当大的进展，最近的严格证明证明了BMA在高维设置中变量选择和估计的准确性，\[10\]并提供了实验证据，强调了BMA中的稀疏执行先验在缓解过拟合方面的作用。\[11\]

### 贝叶斯模型组合

贝叶斯模型组合（BMC）是对贝叶斯模型平均（BMA）的算法校正。 它不是单独对整体中的每个模型进行采样，而是从可能的集合空间中进行采样（模型权重从具有均匀参数的Dirichlet分布中随机抽取） 这种修改克服了BMA趋向于将所有权重赋予单个模型的趋势 尽管BMC在计算上比BMA更昂贵，但它往往会产生显着更好的结果 BMC的结果显示平均值优于（具有统计显着性）BMA和Bagging。\[12\]

使用贝叶斯定律来计算模型权重需要计算给定每个模型的数据的概率，通常集成中的模型都不是生成训练数据的分布，因此对于该项，它们都正确地接收到接近于零的值。如果集成足够大以对整个模型空间进行采样，这将很有效，但这种情况很少发生。因此，训练数据中的每个模式将使集成权重朝向最接近训练数据分布的集合中的模型移动，这实质上减少了用于进行模型选择的不必要的复杂方法。

集成的可能权重可以看作是躺在单面上，在单形的每个顶点处，所有权重都被赋予集成中的单个模型。BMA会聚到最接近训练数据分布的顶点。相比之下，BMC汇聚到这种分布投射到单纯形态的点上。换句话说，它不是选择最接近生成分布的一个模型，而是寻找最接近生成分布的模型的组合。

BMA的结果通常可以通过使用交叉验证从一系列模型中选择最佳模型来近似。同样地，可以通过使用交叉验证来近似来自BMC的结果，以从可能的权重的随机采样中选择最佳的集成组合。

### 桶模型

“桶模型”（英语：bucket of models）是一种使用模型选择算法为每个问题选择最佳模型的集成方法。当仅使用一个问题进行测试时，一组模型不会产生比集成中的最佳模型更好的结果，但是当针对许多问题进行评估时，它通常会产生比集成中的任何模型更好的结果。

最常见的方法用于模型的选择是[交叉验证](../Page/交叉驗證.md "wikilink")。它用以下伪代码描述：

`For each model m in the bucket:`
`  Do c times: (where 'c' is some constant)`
`    Randomly divide the training dataset into two datasets: A, and B.`
`    Train m with A`
`    Test m with B`
`Select the model that obtains the highest average score`

交叉验证选择可以概括为：“使用训练集尝试所有选择，并选择最有效的方法”。<ref>

<div>

肯定Dzeroski，伯纳德善光，可 *[是相结合的分类更好于选择最好的一个](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.108.6096)*机学,2004,pp.255--273

</div>

</ref>

门控是交叉验证选择的一般化。它涉及训练另一种学习模型，以确定桶中哪些模型最适合解决问题。通常，[感知器](../Page/感知器.md "wikilink")被应用于门控模型。它可用于选择“最佳”模型，或者可用于为桶中每个模型的预测提供线性权重。

当使用具有大量问题的桶模型时，可能希望避免需要花费很长时间训练的一些模型。地标学习是一种寻求解决这一问题的元学习方法，它涉及仅训练桶中的快速（但不精确）算法，然后使用这些算法的性能来帮助确定哪种慢（但准确）算法最有可能做得最好。<ref>

<div>

Bensusan,Hilan和吉罗载Christophe G.,发现任务区通过里程碑式的学习表演，PKDD'00:诉讼程序的第4次欧洲会议关于原则的数据挖掘和知识发现，Springer-Verlag，2000年，第325页--330

</div>

</ref>

### Stacking

堆叠（英语：Stacking）（有时称为堆叠泛化）涉及训练学习算法以组合其他几种学习算法的预测。首先，使用可用数据训练所有其他算法，然后训练组合器算法以使用其他算法的所有预测作为附加输入进行最终预测。如果使用任意组合器算法，那么堆叠理论上可以表示本文中描述的任何集合技术，但实际上，通常用[逻辑回归模型作为组合器](../Page/邏輯迴歸.md "wikilink")。

Stacking通常比任何一个经过训练的模型都能产生更好的性能，<ref>

<div>

沃伯特，D.， *堆叠的概括。*的， 神经网络,5(2),pp.241-259., 1992年

</div>

</ref>它已成功用于监督学习任务（如回归、\[13\] 分类和距离学习 \[14\]）和无监督学习（如密度估计）。<ref>

<div>

史密斯，P.和沃伯特,D.H *的直线相结合的密度估计通过叠*，机器 学习的期刊，36,59-83，1999年

</div>

</ref> Stacking也被用于评估Bagging的错误率。\[15\]<ref>

<div>

沃伯特，D.，和麦克瑞德，W.G.， *一个有效的方法来估计装袋的概括错误*、学习机杂志，35,41-55来，1999年

</div>

</ref> 据报道，它的表现超过了贝叶斯模型的平均值。<ref>

<div>

克拉克,B., *Bayes模型平均和堆叠当的模式近似的错误不可忽视*，Journal of机学习的研究，pp683-712，2003年

</div>

</ref>在Netflix竞赛中两个表现最好的人使用混合方法（英语：Blending），这可以被认为是一种Stacking形式。\[16\]

## 实现库

  - [R](../Page/R语言.md "wikilink")：至少有三个软件包提供贝叶斯模型平均工具，\[17\]包括BMS（贝叶斯模型选择）包、\[18\]BAS（贝叶斯自适应采样的首字母缩写）包、\[19\]和BMA包。\[20\]H2O包提供了许多机器学习模型，包括一个集成模型，也可以使用[Spark进行训练](../Page/Apache_Spark.md "wikilink")。
  - [Python](../Page/Python.md "wikilink")：[Scikit-learn](https://zh.wikipedia.org/wiki/Scikit-learn "wikilink")，一个用于Python机器学习的软件包，提供用于集成学习的软件包，包括用于Bagging和平均方法的软件包。
  - [MATLAB](../Page/MATLAB.md "wikilink")：分类集成在统计和机器学习工具箱中实现。\[21\]

## 集成学习应用

近年来，由于计算能力不断提高，允许在合理的时间范围内训练大型集成模型，其应用数量也越来越多。\[22\]集成分类器的一些应用包括：

### 遥感

#### 土地覆盖测绘

土地覆盖测绘是[地球观测卫星传感器的主要应用之一](https://zh.wikipedia.org/wiki/地球观测卫星 "wikilink")，利用[遥感](../Page/遥感.md "wikilink")和地理空间数据识别位于目标区域表面的材料和物体。一般来说，目标材料的类别包括道路、建筑物、河流、湖泊和植被。\[23\]基于[人工神经网络](../Page/人工神经网络.md "wikilink")\[24\]、[核主成分分析](../Page/核主成分分析.md "wikilink")（KPCA）\[25\]、[Boosting](https://zh.wikipedia.org/wiki/Boosting_\(meta-algorithm\) "wikilink")\[26\]决策树、[随机森林](../Page/随机森林.md "wikilink")\[27\]和自动设计多分类器系统\[28\]等不同的集成学习方法可以有效识别土地覆盖物。

#### 变化的检测

变化检测是一种[图像分析问题](https://zh.wikipedia.org/wiki/图像分析 "wikilink")，识别土地覆盖随时间变化的地方。变化检测广泛应用于[城市发展](../Page/城市發展.md "wikilink")、森林和植被动态、土地利用和灾害监测等领域。\[29\]集成分类器在变化检测中的最早应用是通过多数投票、贝叶斯平均和最大后验概率设计的。\[30\]

### 计算机安全

#### 分布式拒绝服务

[分布式拒绝服务攻击是互联网服务提供商可能遭受的最具威胁性的网络攻击之一](https://zh.wikipedia.org/wiki/分布式拒绝服务 "wikilink")。\[31\]通过组合单个分类器的输出，集成分类器减少了检测和区分此类攻击与[Slashdot效应](../Page/Slashdot效应.md "wikilink")的总误差。\[32\]

#### 恶意软件检测

使用机器学习技术对[计算机病毒](../Page/计算机病毒.md "wikilink")、[计算机蠕虫](https://zh.wikipedia.org/wiki/计算机蠕虫 "wikilink")、[特洛伊木马](../Page/特洛伊木马_\(电脑\).md "wikilink")、[勒索软件和](../Page/勒索軟體.md "wikilink")[间谍软件](../Page/间谍软件.md "wikilink")等[恶意软件](../Page/恶意软件.md "wikilink")代码进行分类，其灵感来自[文本分类问题](../Page/文档分类.md "wikilink")。\[33\] 集成学习系统在这方面已经显示出适当的功效。\[34\]\[35\]

#### 入侵检测

[入侵检测系统](../Page/入侵检测系统.md "wikilink")监控[计算机网络](../Page/计算机网络.md "wikilink")或[计算机系统](https://zh.wikipedia.org/wiki/计算机系统 "wikilink")，以识别入侵者代码，如异常检测过程。集成学习成功地帮助这种监控系统减少了它们的总误差。\[36\]\[37\]

### 人脸识别

人脸识别最近已经成为最受欢迎的模式识别研究领域之一，它通过他/她的数字图像来处理人的识别或验证。\[38\]

基于Gabor Fisher分类器和独立分量分析预处理技术的分层集成是该领域中最早使用的一些集成方法。\[39\]\[40\]\[41\]

### 情感识别

语音识别主要基于深度学习，因为谷歌、微软和IBM这一领域的大多数业内人士都表示，他们的语音识别的核心技术是基于这种方法。基于语音与集成学习的情感识别也可以有令人满意的表现。\[42\]\[43\]

它也被成功用于面部情绪识别。\[44\]\[45\]\[46\]

### 欺诈检测

欺诈检测涉及银行欺诈的识别，例如[洗钱](../Page/洗錢.md "wikilink")、信用卡欺诈和[电信欺诈](../Page/电信诈骗.md "wikilink")，它们具有广泛的机器学习研究和应用领域。由于集成学习提高了正常行为建模的稳健性，因此有人提出将其作为检测银行和信用卡系统中此类欺诈案件和活动的有效技术。\[47\]\[48\]

### 金融决策

预测业务失败的准确性是财务决策中非常关键的问题。因此，不同的集成分类器被提出用于预测[金融危机](../Page/金融危机.md "wikilink")和财务困境。\[49\]此外，在基于交易的操纵问题中，交易者试图通过买卖活动来操纵[股票价格](../Page/股價指數.md "wikilink")，集成分类器需要分析股票市场数据的变化并检测股票价格操纵的可疑症状。\[50\]

### 医学

集成分类器已成功应用于[神经科学](../Page/神经科学.md "wikilink")、[蛋白质组学](../Page/蛋白质组学.md "wikilink")和[医学诊断](https://zh.wikipedia.org/wiki/醫學診斷 "wikilink")，例如基于MRI数据集的神经认知障碍（即[阿尔茨海默氏症或肌强直性营养不良](https://zh.wikipedia.org/wiki/阿尔茨海默氏症 "wikilink")）检测。\[51\]\[52\]\[53\]

## 参考文献

<references group="">

</references>

[Category:集成学习](https://zh.wikipedia.org/wiki/Category:集成学习 "wikilink") [Category:机器学习](https://zh.wikipedia.org/wiki/Category:机器学习 "wikilink") [Category:有未审阅翻译的页面](https://zh.wikipedia.org/wiki/Category:有未审阅翻译的页面 "wikilink")

1.

2.

3.

4.

5.

6.

7.

8.

9.

10.

11.

12.

13. Breiman, L., *Stacked Regression*, Machine Learning, 24, 1996

14.

15.

16.

17.

18.

19.

20.

21.

22.

23.

24.

25.

26.

27.
28.

29.

30.

31.

32.

33.

34.

35.

36.

37.

38.

39.

40.

41.

42.

43.

44.

45.

46.

47.

48.

49.

50.

51.

52.

53.
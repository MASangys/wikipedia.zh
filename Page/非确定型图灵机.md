> 本文内容由[非确定型图灵机](https://zh.wikipedia.org/wiki/非确定型图灵机)转换而来。


如果不加特殊说明，通常所说的[图灵机](../Page/图灵机.md "wikilink")都是确定型图灵机。**非确定型图灵机**和[确定型图灵机的不同之处在于](https://zh.wikipedia.org/wiki/确定型图灵机 "wikilink")，在计算的每一时刻，根据当前状态和读写头所读的符号，机器存在多种状态转移方案，机器将任意地选择其中一种方案继续运作，直到最后停机为止。具体而言，其状态转移函数为

\[\delta: Q \times \Gamma \to 2^{Q \times \Gamma \times \{L, R\}}\] 其中\(Q\)是状态集合，\(\Gamma\)是带字母表，\(L, R\)分别表示读写头向左和向右移动；符号\(2^{A}\) 表示集合\(A\)的幂集，即

\[2^A  = \{ S~|~S \subseteq A \}\]

例如，设非确定型图灵机\(M\)的当前状态为\(q\)，当前读写头所读的符号为\(x\)，若

\[\delta(q,x) = \{ (q_1, x_1, d_1), (q_2, x_2, d_2), \ldots , (q_k, x_k, d_k)\}\] 则\(M\)将*任意地*选择一个\((q_i, x_i, d_i)\)，按其进行操作，然后进入下一步计算。

非确定型图灵机\(M\)在输入串\(\omega\)上的计算过程可以表示为一棵树，不同的分支对应着每一步计算的不同的可能性。只要有任意一个分支进入接受状态，则称\(M\)接受\(\omega\)；只要有任意一个分支进入拒绝状态，则称\(M\)拒绝\(\omega\)；某些分支可能永远无法停机，但只要有一个分支可以进入接受或拒绝状态，我们就说\(M\)在输入\(\omega\)上可停机。注意，我们规定\(M\)必须是无矛盾的，即它不能有某个分支接受\(\omega\)而同时另一个分支拒绝\(\omega\)，这样有矛盾的非确定型图灵机是不合法的。

**定理**：对于任意一个非确定型图灵机\(M\)，存在一个确定型图灵机\(M'\)，使得它们的语言相等，即\(L(M) = L(M')\)。

**证明**：因为非确定型图灵机的计算过程就是一棵树，因此我们只需遍历该树就可以模拟其计算过程。一个简单的想法是利用[深度优先搜索](../Page/深度优先搜索.md "wikilink")来遍历\(M\)的计算树，但这样行不通，因为\(M\)的某些计算分支可能永远不停机！所以我们可以采用一种在算法设计中称为[迭代加深搜索的技巧来遍历](https://zh.wikipedia.org/wiki/迭代加深搜索 "wikilink")\(M\)的计算树。具体证明如下：

对于非确定型图灵机\(M\)，构造一个确定型图灵机\(M'\)如下：

1.  令\(k= 1\)；
2.  深度优先地模拟\(M\)的每个分支的计算，但每个分支最多只计算\(k\)步，如果某个计算分支在\(k\)步内可以停机，则\(M'\)也停机，并将该计算分支的计算结果输出。
3.  令\(k\)增加 1，跳转到上一步继续执行。

显然，若\(M\)有某个分支可以停机，则此\(M'\)也一定会找到该分支并停机。因此\(L(M) = L(M')\)。

**定理2**：如果语言L被非确定型图灵机\(M\)在多项式时间内接受，则一定存在多项式P使得语言L被时间复杂度为\(O(2^{P(n)})\)的确定型图灵机程序所接受。

定理2说明了为什么在证明[P](../Page/P_\(複雜度\).md "wikilink") = [NP之前](../Page/NP_\(複雜度\).md "wikilink")，所有的NPC问题都只有指数时间复杂度算法。

## 参见

  - [图灵机](../Page/图灵机.md "wikilink")
  - [複雜度類P](../Page/P_\(複雜度\).md "wikilink")
  - [複雜度類NP](../Page/NP_\(複雜度\).md "wikilink")
  - [P/NP问题](https://zh.wikipedia.org/wiki/P/NP问题 "wikilink")

[Category:图灵机](https://zh.wikipedia.org/wiki/Category:图灵机 "wikilink")
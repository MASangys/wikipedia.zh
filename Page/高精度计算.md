> 本文内容由[高精度计算](https://zh.wikipedia.org/wiki/高精度计算)转换而来。


**高精度计算**是一种[程序设计](../Page/程序设计.md "wikilink")的[算法](../Page/算法.md "wikilink")。由于[中央處理器的](https://zh.wikipedia.org/wiki/中央處理器 "wikilink")[字長限制](https://zh.wikipedia.org/wiki/字_\(計算機\) "wikilink")，如32位CPU中一个整数最大只能取值4,294,967,295。因此在进行更大范围的数值计算中，往往要采取模拟手段。通常通过分离字符的方法通过数字[数组](../Page/数组.md "wikilink")进行输入。通过数组倒序输出。通过模拟[竖式计算进行计算](https://zh.wikipedia.org/wiki/竖式 "wikilink")。一般而言，主要模拟的是按位运算，可以用不同的[進位制達成不同的目的](https://zh.wikipedia.org/wiki/進位制 "wikilink")。

有許多程式庫支援高精度計算，最著名的是[GNU多重精度運算庫](https://zh.wikipedia.org/wiki/GNU多重精度運算庫 "wikilink")。另外，[Java](../Page/Java.md "wikilink")和[Pascal也有原生的高精度运算支持](../Page/Pascal_\(程式語言\).md "wikilink")

## 種類

  - 高精度加法
  - 高精度減法
  - 高精度乘法
  - 高精度除法

## 高精度加法

### 简介

高精度加法是[信息学的一种重要算法](https://zh.wikipedia.org/wiki/信息学 "wikilink")。这种算法使用多个[存储单位进行计算](https://zh.wikipedia.org/wiki/存储单位 "wikilink")，因此它的计算范围超过一般使用一个存储单位的算法。也是一些[信息学竞赛的常考题目](https://zh.wikipedia.org/wiki/信息学竞赛 "wikilink")。

### 基本算法

以358934760892734899+38960302975237462为例：

1、计算结果的位数

358934760892734899共18位

38960302975237462 共17位

故结果不会超过19位。

2、将要计算的数字分割成多段，按照顺序排列（这里以0-32767作为每一存储单位存储的数的限制）：

|    |      |      |      |      |
| -- | ---- | ---- | ---- | ---- |
| 35 | 8934 | 7608 | 9273 | 4899 |
| 3  | 8960 | 3029 | 7523 | 7462 |

（为提高空间利用效率，可以一个存储单位存储多位数。）

3、将两数相加。

|        | 35 | 8934  | 7608  | 9273  | 4899  |
| ------ | -- | ----- | ----- | ----- | ----- |
|        | 3  | 8960  | 3029  | 7523  | 7462  |
| 和（不进位） | 38 | 17894 | 10637 | 16796 | 12361 |
| 和（进位后） | 39 | 7895  | 0638  | 6797  | 2361  |

4、输出结果。

从高位到低位依次输出。除最高位以外，其他低位上不足4位的要在前面补上0。

### 代码实现

pascal：

``` pascal numberLines
var
  a,b,c:array[1..201] of integer;
  n:string;
  lena,lenb,lenc,i,x:integer;
begin
  readln(n);
  lena:=length(n);
  for i:=1 to lena do a[lena-i+1]:=ord(n[i])-ord('0');
  readln(n);
  lenb:=length(n);
  for i:=1 to lenb do b[lenb-i+1]:=ord(n[i])-ord('0');
  i:=1; x:=0;
  while (i<=lena) or(i<=lenb) do
  begin
    c[i]:=a[i]+b[i]+x;
    x := c[i] div 10;
    c[i] := c[i] mod 10;
    i := i + 1;
  end;
  if x>0 then
  begin
    lenc:=i;
    c[i]:=x;
  end
  else lenc:=i-1;
  for i:=lenc downto 1 do write(c[i]);
end.
```

c++：

``` c++ numberLines
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

short a[510],b[510];
char ca[510],cb[510];
short ans[510];
short len;

void add(short a[],short b[])
{
    for(int i=0;i<len;++i)
    {
        ans[i]+=a[i]+b[i];
        if(ans[i]>=10)
        {
            ans[i+1]+=ans[i]/10;
            ans[i]%=10;
        }
    }
    if(ans[len])
        len++;
    else
    {
        while((!ans[len-1])&&len>1)
        {
            len--;
        }
    }
    return;
}

short zhuan(char a)
{
    return a-'0';
}

int main()
{
    scanf("%s",ca);
    scanf("%s",cb);//gets有bug（空格的问题），有些题库（如洛谷）不给过。
    short lena=strlen(ca);
    short lenb=strlen(cb);
    len=max(lena,lenb);
    for(short i=0;i<lena;++i)
    {
        a[lena-i-1]=zhuan(ca[i]);
    }
    for(short i=0;i<lenb;++i)
    {
        b[lenb-i-1]=zhuan(cb[i]);
    }
    add(a,b);
    for(short i=len-1;i>=0;--i)
    {
        putchar(ans[i]+'0');
    }
    return 0;
}
```

## 模板题

高精度加法：

OpenJudge：http://noi.openjudge.cn/ch0106/10/

洛谷：https://www.luogu.org/problemnew/show/P1601

## 参见

[高精度加法](https://zh.wikipedia.org/wiki/高精度加法 "wikilink")

[高精度减法](https://zh.wikipedia.org/wiki/高精度减法 "wikilink")

[Category:計算機算術](https://zh.wikipedia.org/wiki/Category:計算機算術 "wikilink")